[05/04 17:22:21      0s] 
[05/04 17:22:21      0s] Cadence Innovus(TM) Implementation System.
[05/04 17:22:21      0s] Copyright 2019 Cadence Design Systems, Inc. All rights reserved worldwide.
[05/04 17:22:21      0s] 
[05/04 17:22:21      0s] Version:	v19.11-s128_1, built Tue Aug 20 20:54:34 PDT 2019
[05/04 17:22:21      0s] Options:	-stylus 
[05/04 17:22:21      0s] Date:		Sun May  4 17:22:21 2025
[05/04 17:22:21      0s] Host:		engnx06a.utdallas.edu (x86_64 w/Linux 4.18.0-553.46.1.el8_10.x86_64) (8cores*32cpus*AMD EPYC 7F32 8-Core Processor 512KB)
[05/04 17:22:21      0s] OS:		Red Hat Enterprise Linux release 8.10 (Ootpa)
[05/04 17:22:21      0s] 
[05/04 17:22:21      0s] License:
[05/04 17:22:21      0s] 		invs	Innovus Implementation System	19.1	checkout succeeded
[05/04 17:22:21      0s] 		8 CPU jobs allowed with the current license(s). Use set_multi_cpu_usage to set your required CPU count.
[05/04 17:22:25      4s] 
[05/04 17:22:25      4s] 
[05/04 17:22:32      8s] @(#)CDS: Innovus v19.11-s128_1 (64bit) 08/20/2019 20:54 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/04 17:22:32      8s] @(#)CDS: NanoRoute 19.11-s128_1 NR190815-2055/19_11-UB (database version 18.20, 469.7.1) {superthreading v1.51}
[05/04 17:22:32      8s] @(#)CDS: AAE 19.11-s034 (64bit) 08/20/2019 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/04 17:22:32      8s] @(#)CDS: CTE 19.11-s040_1 () Aug  1 2019 08:53:57 ( )
[05/04 17:22:32      8s] @(#)CDS: SYNTECH 19.11-e010_1 () Jul 15 2019 20:31:02 ( )
[05/04 17:22:32      8s] @(#)CDS: CPE v19.11-s006
[05/04 17:22:32      8s] @(#)CDS: IQuantus/TQuantus 19.1.2-s245 (64bit) Thu Aug 1 10:22:01 PDT 2019 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/04 17:22:32      8s] @(#)CDS: OA 22.60-p020 Mon May 13 19:21:36 2019
[05/04 17:22:32      8s] @(#)CDS: SGN 18.10-d003 (18-Jul-2018) (64 bit executable, Qt5.9.1)
[05/04 17:22:32      8s] @(#)CDS: RCDB 11.14.18
[05/04 17:22:32      8s] @(#)CDS: STYLUS 19.10-s008_1 (06/27/2019 02:55 PDT)
[05/04 17:22:32      8s] Create and set the environment variable TMPDIR to /usr/tmp/innovus_temp_255034_engnx06a.utdallas.edu_oma190007_gnYzeu.

[05/04 17:22:32      8s] Create and set the environment variable TMPDIR to /usr/tmp/innovus_temp_255034_engnx06a.utdallas.edu_oma190007_gnYzeu.
[05/04 17:22:32      8s] 
[05/04 17:22:32      8s] Change the soft stacksize limit to 0.2%RAM (514 mbytes). Set global soft_stack_size_limit to change the value.
[05/04 17:22:34      8s] 
[05/04 17:22:34      8s] **INFO:  MMMC transition support version v31-84 
[05/04 17:22:34      8s] 
[05/04 17:22:35      9s] @innovus 1> read_db MSDAP_FINAL
[05/04 17:22:50     10s] report_message: '-start_cmd/-end_cmd' can not be nested. Interior calls do nothing. Ignore.
#% Begin load design ... (date=05/04 17:22:50, mem=614.5M)
[05/04 17:22:50     10s] ##  Process: 7             (User Set)               
[05/04 17:22:50     10s] ##     Node: (not set)                           
[05/04 17:22:50     10s] 
[05/04 17:22:50     10s] ##  Check design process and node:  
[05/04 17:22:50     10s] ##  Design tech node is not set.
[05/04 17:22:50     10s] 
[05/04 17:22:50     10s] Applying the recommended capacitance filtering threshold values for 7nm process node: total_c_th=0, relative_c_th=1 and coupling_c_th=0.1.
[05/04 17:22:50     10s] 	These values will be used by all post-route extraction engines, including TQuantus, IQuantus and Quantus QRC extraction.
[05/04 17:22:50     10s] 	Capacitance filtering mode(extract_rc_cap_filter_mode option of the set_db) is 'relative_and_coupling' for all engines.
[05/04 17:22:50     10s] 	The accuracy mode for post_route extract_rc_effort_level low extraction will be set to 'high'.
[05/04 17:22:50     10s] 	Default value for EffortLevel(extract_rc_effort_level option of the set_db) in post_route extraction mode will be 'medium' if Quantus QRC technology file is specified else 'low'.
[05/04 17:22:50     10s] **WARN: (IMPDBTCL-321):	The attribute 'timing_enable_separate_device_slew_effect_sensitivities' still works but will be obsolete in a future major release. You should remove it from your script before the next major release to avoid errors.
[05/04 17:22:50     10s] #USet: HiLayer Color Conflict For Pin-Track Alignment = 1.
[05/04 17:22:50     10s] Set Default Input Pin Transition as 0.1 ps.
[05/04 17:22:50     10s] #USet: HiLayer Color Conflict For Pin-Track Alignment = 1.
[05/04 17:22:50     10s] Loading design 'MSDAP' saved by 'Innovus' '19.11-s128_1' on 'Sat May 3 15:05:23 2025'.
[05/04 17:22:50     10s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_SS_nldm_201020.lib' ...
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_SS_nldm_201020.lib, Line 11365)
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_SS_nldm_201020.lib, Line 14263)
[05/04 17:22:50     11s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_RVT_SS_nldm_201020' 
[05/04 17:22:50     11s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_SS_nldm_201020.lib' ...
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_SS_nldm_201020.lib, Line 11365)
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_SS_nldm_201020.lib, Line 14263)
[05/04 17:22:50     11s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_LVT_SS_nldm_201020' 
[05/04 17:22:50     11s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_SS_nldm_201020.lib' ...
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_SS_nldm_201020.lib, Line 11365)
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_SS_nldm_201020.lib, Line 14263)
[05/04 17:22:50     11s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_SLVT_SS_nldm_201020' 
[05/04 17:22:50     11s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_SS_nldm_201020.lib' ...
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_SS_nldm_201020.lib, Line 11365)
[05/04 17:22:50     11s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_SS_nldm_201020.lib, Line 14263)
[05/04 17:22:50     11s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_SRAM_SS_nldm_201020' 
[05/04 17:22:50     11s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_RVT_SS_nldm_201020.lib' ...
[05/04 17:22:51     12s] Read 42 cells in library 'asap7sc7p5t_AO_RVT_SS_nldm_201020' 
[05/04 17:22:51     12s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_LVT_SS_nldm_201020.lib' ...
[05/04 17:22:52     12s] Read 42 cells in library 'asap7sc7p5t_AO_LVT_SS_nldm_201020' 
[05/04 17:22:52     12s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_SLVT_SS_nldm_201020.lib' ...
[05/04 17:22:53     13s] Read 42 cells in library 'asap7sc7p5t_AO_SLVT_SS_nldm_201020' 
[05/04 17:22:53     13s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_SRAM_SS_nldm_201020.lib' ...
[05/04 17:22:54     14s] Read 42 cells in library 'asap7sc7p5t_AO_SRAM_SS_nldm_201020' 
[05/04 17:22:54     14s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_RVT_SS_nldm_201020.lib' ...
[05/04 17:22:54     15s] Read 34 cells in library 'asap7sc7p5t_OA_RVT_SS_nldm_201020' 
[05/04 17:22:54     15s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_LVT_SS_nldm_201020.lib' ...
[05/04 17:22:55     16s] Read 34 cells in library 'asap7sc7p5t_OA_LVT_SS_nldm_201020' 
[05/04 17:22:55     16s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_SLVT_SS_nldm_201020.lib' ...
[05/04 17:22:56     16s] Read 34 cells in library 'asap7sc7p5t_OA_SLVT_SS_nldm_201020' 
[05/04 17:22:56     16s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_SRAM_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] Read 34 cells in library 'asap7sc7p5t_OA_SRAM_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_RVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_RVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_RVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] Read 33 cells in library 'asap7sc7p5t_SEQ_RVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] Read 33 cells in library 'asap7sc7p5t_SEQ_LVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_SS_nldm_201020.lib)
[05/04 17:22:57     17s] Read 33 cells in library 'asap7sc7p5t_SEQ_SLVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SRAM_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SRAM_SS_nldm_201020.lib)
[05/04 17:22:57     17s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SRAM_SS_nldm_201020.lib)
[05/04 17:22:57     17s] Read 33 cells in library 'asap7sc7p5t_SEQ_SRAM_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_RVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] Read 37 cells in library 'asap7sc7p5t_INVBUF_RVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_LVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] Read 37 cells in library 'asap7sc7p5t_INVBUF_LVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_SLVT_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] Read 37 cells in library 'asap7sc7p5t_INVBUF_SLVT_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_SRAM_SS_nldm_201020.lib' ...
[05/04 17:22:57     17s] Read 37 cells in library 'asap7sc7p5t_INVBUF_SRAM_SS_nldm_201020' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib' ...
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_lower_threshold_pct_rise' not specified in the library, using .lib default of '20%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_lower_threshold_pct_fall' not specified in the library, using .lib default of '20%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_upper_threshold_pct_rise' not specified in the library, using .lib default of '80%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_upper_threshold_pct_fall' not specified in the library, using .lib default of '80%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] Read 1 cells in library 'SRAM1RW128x12_PVT_0P63V_100C' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib' ...
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_lower_threshold_pct_rise' not specified in the library, using .lib default of '20%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_lower_threshold_pct_fall' not specified in the library, using .lib default of '20%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_upper_threshold_pct_rise' not specified in the library, using .lib default of '80%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'slew_upper_threshold_pct_fall' not specified in the library, using .lib default of '80%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] Read 1 cells in library 'SRAM1RW256x8_PVT_0P63V_100C' 
[05/04 17:22:57     17s] Reading PVT_0P63V_100C.setup_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P63V_100C.lib' ...
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'input_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_rise' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] **WARN: (TECHLIB-9108):	 'output_threshold_pct_fall' not specified in the library, using .lib default of '50%'. (File /home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P63V_100C.lib, Line 1)
[05/04 17:22:57     17s] Message <TECHLIB-9108> has exceeded the message display limit of '20'. Use 'set_message -no_limit -id list_of_msgIDs' to reset the message limit.
[05/04 17:22:57     18s] Read 1 cells in library 'SRAM2RW16x8_PVT_0P63V_100C' 
[05/04 17:22:57     18s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_FF_nldm_201020.lib' ...
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_FF_nldm_201020.lib, Line 11387)
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_RVT_FF_nldm_201020.lib, Line 14287)
[05/04 17:22:57     18s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_RVT_FF_nldm_201020' 
[05/04 17:22:57     18s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_FF_nldm_201020.lib' ...
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_FF_nldm_201020.lib, Line 11365)
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_LVT_FF_nldm_201020.lib, Line 14263)
[05/04 17:22:57     18s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_LVT_FF_nldm_201020' 
[05/04 17:22:57     18s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_FF_nldm_201020.lib' ...
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_FF_nldm_201020.lib, Line 11365)
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SLVT_FF_nldm_201020.lib, Line 14263)
[05/04 17:22:57     18s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_SLVT_FF_nldm_201020' 
[05/04 17:22:57     18s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_FF_nldm_201020.lib' ...
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_FF_nldm_201020.lib, Line 11365)
[05/04 17:22:57     18s] **WARN: (TECHLIB-1277):	The attribute 'input_signal_level' has been defined for output pin 'CON'. 'input_signal_level' cannot be defined at this level and is being ignored. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SIMPLE_SRAM_FF_nldm_201020.lib, Line 14263)
[05/04 17:22:57     18s] Read 56 cells in library 'asap7sc7p5t_SIMPLE_SRAM_FF_nldm_201020' 
[05/04 17:22:57     18s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_RVT_FF_nldm_201020.lib' ...
[05/04 17:22:58     19s] Read 42 cells in library 'asap7sc7p5t_AO_RVT_FF_nldm_201020' 
[05/04 17:22:58     19s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_LVT_FF_nldm_201020.lib' ...
[05/04 17:22:59     19s] Read 42 cells in library 'asap7sc7p5t_AO_LVT_FF_nldm_201020' 
[05/04 17:22:59     19s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_SLVT_FF_nldm_201020.lib' ...
[05/04 17:23:00     20s] Read 42 cells in library 'asap7sc7p5t_AO_SLVT_FF_nldm_201020' 
[05/04 17:23:00     20s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_AO_SRAM_FF_nldm_201020.lib' ...
[05/04 17:23:00     21s] Read 42 cells in library 'asap7sc7p5t_AO_SRAM_FF_nldm_201020' 
[05/04 17:23:00     21s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_RVT_FF_nldm_201020.lib' ...
[05/04 17:23:01     22s] Read 34 cells in library 'asap7sc7p5t_OA_RVT_FF_nldm_201020' 
[05/04 17:23:01     22s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_LVT_FF_nldm_201020.lib' ...
[05/04 17:23:02     23s] Read 34 cells in library 'asap7sc7p5t_OA_LVT_FF_nldm_201020' 
[05/04 17:23:02     23s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_SLVT_FF_nldm_201020.lib' ...
[05/04 17:23:03     23s] Read 34 cells in library 'asap7sc7p5t_OA_SLVT_FF_nldm_201020' 
[05/04 17:23:03     23s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_OA_SRAM_FF_nldm_201020.lib' ...
[05/04 17:23:03     24s] Read 34 cells in library 'asap7sc7p5t_OA_SRAM_FF_nldm_201020' 
[05/04 17:23:03     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_RVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] Read 33 cells in library 'asap7sc7p5t_SEQ_RVT_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_FF_nldm_201020.lib)
[05/04 17:23:04     24s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_LVT_FF_nldm_201020.lib)
[05/04 17:23:04     24s] Read 33 cells in library 'asap7sc7p5t_SEQ_LVT_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2057 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_FF_nldm_201020.lib)
[05/04 17:23:04     24s] **ERROR: (TECHLIB-1171):	The attribute 'values' of group 'fall_constraint' on line 2074 has one or more values which are greater than 100sec. This may lead to unexpected analysis results. (File /proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SLVT_FF_nldm_201020.lib)
[05/04 17:23:04     24s] Read 33 cells in library 'asap7sc7p5t_SEQ_SLVT_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_SEQ_SRAM_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] Read 33 cells in library 'asap7sc7p5t_SEQ_SRAM_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_RVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] Read 37 cells in library 'asap7sc7p5t_INVBUF_RVT_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_LVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     24s] Read 37 cells in library 'asap7sc7p5t_INVBUF_LVT_FF_nldm_201020' 
[05/04 17:23:04     24s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_SLVT_FF_nldm_201020.lib' ...
[05/04 17:23:04     25s] Read 37 cells in library 'asap7sc7p5t_INVBUF_SLVT_FF_nldm_201020' 
[05/04 17:23:04     25s] Reading PVT_0P77V_0C.hold_set timing library '/proj/cad/library/asap7/asap7sc7p5t_27/LIB/NLDM/asap7sc7p5t_INVBUF_SRAM_FF_nldm_201020.lib' ...
[05/04 17:23:04     25s] Read 37 cells in library 'asap7sc7p5t_INVBUF_SRAM_FF_nldm_201020' 
[05/04 17:23:04     25s] Reading PVT_0P77V_0C.hold_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW128x12_lib/SRAM1RW128x12_PVT_0P77V_0C.lib' ...
[05/04 17:23:04     25s] Read 1 cells in library 'SRAM1RW128x12_PVT_0P77V_0C' 
[05/04 17:23:04     25s] Reading PVT_0P77V_0C.hold_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM1RW256x8_lib/SRAM1RW256x8_PVT_0P77V_0C.lib' ...
[05/04 17:23:04     25s] Read 1 cells in library 'SRAM1RW256x8_PVT_0P77V_0C' 
[05/04 17:23:04     25s] Reading PVT_0P77V_0C.hold_set timing library '/home/eng/t/txg150930/workspace/ASIC/Memory/lib/SRAM2RW16x8_lib/SRAM2RW16x8_PVT_0P77V_0C.lib' ...
[05/04 17:23:04     25s] Read 1 cells in library 'SRAM2RW16x8_PVT_0P77V_0C' 
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/asap7_tech_4x_201209.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/asap7sc7p5t_27_R_4x_201211.lef ...
[05/04 17:23:04     25s] Set DBUPerIGU to M1 pitch 576.
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/asap7sc7p5t_27_L_4x_201211.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/asap7sc7p5t_27_SL_4x_201211.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/asap7sc7p5t_27_SRAM_4x_201211.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/SRAM1RW128x12_x4.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/SRAM1RW256x8_x4.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading LEF file /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/lef/SRAM2RW16x8_x4.lef ...
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] viaInitial starts at Sun May  4 17:23:04 2025
[05/04 17:23:04     25s] viaInitial ends at Sun May  4 17:23:04 2025
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] ##  Check design process and node:  
[05/04 17:23:04     25s] ##  Design tech node is not set.
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] Loading view definition file from MSDAP_FINAL/viewDefinition.tcl
[05/04 17:23:04     25s] % Begin Load netlist data ... (date=05/04 17:23:04, mem=680.1M)
[05/04 17:23:04     25s] *** Begin netlist parsing (mem=864.3M) ***
[05/04 17:23:04     25s] Created 811 new cells from 46 timing libraries.
[05/04 17:23:04     25s] Reading netlist ...
[05/04 17:23:04     25s] Backslashed names will retain backslash and a trailing blank character.
[05/04 17:23:04     25s] Reading verilogBinary netlist '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/MSDAP.v.bin'
[05/04 17:23:04     25s] Reading binary database version 2 in 1-threaded mode
[05/04 17:23:04     25s] 
[05/04 17:23:04     25s] *** Memory Usage v#1 (Current mem = 871.332M, initial mem = 270.188M) ***
[05/04 17:23:04     25s] *** End netlist parsing (cpu=0:00:00.0, real=0:00:00.0, mem=871.3M) ***
[05/04 17:23:04     25s] % End Load netlist data ... (date=05/04 17:23:04, total cpu=0:00:00.0, real=0:00:00.0, peak res=763.1M, current mem=763.1M)
[05/04 17:23:04     25s] Set top cell to MSDAP.
[05/04 17:23:05     26s] Hooked 1622 DB cells to tlib cells.
[05/04 17:23:05     26s] Starting recursive module instantiation check.
[05/04 17:23:05     26s] No recursion found.
[05/04 17:23:05     26s] Building hierarchical netlist for Cell MSDAP ...
[05/04 17:23:05     26s] *** Netlist is unique.
[05/04 17:23:05     26s] Set DBUPerIGU to techSite asap7sc7p5t width 864.
[05/04 17:23:05     26s] Setting Std. cell height to 4320 DBU (smallest netlist inst).
[05/04 17:23:05     26s] ** info: there are 1678 modules.
[05/04 17:23:05     26s] ** info: there are 3033 stdCell insts.
[05/04 17:23:05     26s] ** info: there are 14 macros.
[05/04 17:23:06     26s] 
[05/04 17:23:06     26s] *** Memory Usage v#1 (Current mem = 993.746M, initial mem = 270.188M) ***
[05/04 17:23:06     26s] *info: set bottom ioPad orient R0
[05/04 17:23:06     26s] Set Default Net Delay as 1000 ps.
[05/04 17:23:06     26s] Set Default Net Load as 0.5 pF. 
[05/04 17:23:06     26s] Set Default Input Pin Transition as 0.1 ps.
[05/04 17:23:06     26s] Loading preference file MSDAP_FINAL/gui.pref.tcl ...
[05/04 17:23:06     26s] ##  Process: 7             (User Set)               
[05/04 17:23:06     26s] ##     Node: (not set)                           
[05/04 17:23:06     26s] 
[05/04 17:23:06     26s] ##  Check design process and node:  
[05/04 17:23:06     26s] ##  Design tech node is not set.
[05/04 17:23:06     26s] 
[05/04 17:23:06     26s] Applying the recommended capacitance filtering threshold values for 7nm process node: total_c_th=0, relative_c_th=1 and coupling_c_th=0.1.
[05/04 17:23:06     26s] 	These values will be used by all post-route extraction engines, including TQuantus, IQuantus and Quantus QRC extraction.
[05/04 17:23:06     26s] 	Capacitance filtering mode(extract_rc_cap_filter_mode option of the set_db) is 'relative_and_coupling' for all engines.
[05/04 17:23:06     26s] 	The accuracy mode for post_route extract_rc_effort_level low extraction will be set to 'high'.
[05/04 17:23:06     26s] 	Default value for EffortLevel(extract_rc_effort_level option of the set_db) in post_route extraction mode will be 'medium' if Quantus QRC technology file is specified else 'low'.
[05/04 17:23:06     26s] **WARN: (IMPTCM-77):	Option "-drouteStartIteration" for command setNanoRouteMode is obsolete and will be removed in a future release. The obsolete option still works in this release but to avoid this warning and to ensure compatibility with future releases, remove the obsolete option from your script.
[05/04 17:23:06     27s] Offset for stripe breaking is set to 0.
[05/04 17:23:06     27s] The power planner will set stripe antenna targets to stripe.
[05/04 17:23:06     27s] Extraction setup Delayed 
[05/04 17:23:06     27s] *Info: initialize multi-corner CTS.
[05/04 17:23:06     27s] Reading timing constraints file '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/mmmc/modes/my_constraint_mode/my_constraint_mode.sdc' ...
[05/04 17:23:06     27s] Current (total cpu=0:00:27.3, real=0:00:45.0, peak res=1183.2M, current mem=1111.1M)
[05/04 17:23:06     27s] MSDAP
[05/04 17:23:06     27s] INFO (CTE): Constraints read successfully.
[05/04 17:23:06     27s] Ending "Constraint file reading stats" (total cpu=0:00:00.0, real=0:00:00.0, peak res=1129.0M, current mem=1129.0M)
[05/04 17:23:06     27s] Current (total cpu=0:00:27.4, real=0:00:45.0, peak res=1183.2M, current mem=1129.0M)
[05/04 17:23:06     27s] Reading latency file '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/mmmc/views/PVT_0P63V_100C.setup_view/latency.sdc' ...
[05/04 17:23:06     27s] Reading latency file '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/mmmc/views/PVT_0P77V_0C.hold_view/latency.sdc' ...
[05/04 17:23:06     27s] Creating Cell Server ...(0, 1, 1, 1)
[05/04 17:23:06     27s] Summary for sequential cells identification: 
[05/04 17:23:06     27s]   Identified SBFF number: 68
[05/04 17:23:06     27s]   Identified MBFF number: 0
[05/04 17:23:06     27s]   Identified SB Latch number: 0
[05/04 17:23:06     27s]   Identified MB Latch number: 0
[05/04 17:23:06     27s]   Not identified SBFF number: 0
[05/04 17:23:06     27s]   Not identified MBFF number: 0
[05/04 17:23:06     27s]   Not identified SB Latch number: 0
[05/04 17:23:06     27s]   Not identified MB Latch number: 0
[05/04 17:23:06     27s]   Number of sequential cells which are not FFs: 64
[05/04 17:23:06     27s] Total number of combinational cells: 676
[05/04 17:23:06     27s] Total number of sequential cells: 132
[05/04 17:23:06     27s] Total number of tristate cells: 0
[05/04 17:23:06     27s] Total number of level shifter cells: 0
[05/04 17:23:06     27s] Total number of power gating cells: 0
[05/04 17:23:06     27s] Total number of isolation cells: 0
[05/04 17:23:06     27s] Total number of power switch cells: 0
[05/04 17:23:06     27s] Total number of pulse generator cells: 0
[05/04 17:23:06     27s] Total number of always on buffers: 0
[05/04 17:23:06     27s] Total number of retention cells: 0
[05/04 17:23:06     27s] List of usable buffers: BUFx10_ASAP7_75t_SRAM BUFx12f_ASAP7_75t_SRAM BUFx16f_ASAP7_75t_SRAM BUFx2_ASAP7_75t_SRAM BUFx3_ASAP7_75t_SRAM BUFx5_ASAP7_75t_SRAM BUFx4f_ASAP7_75t_SRAM BUFx6f_ASAP7_75t_SRAM HB1xp67_ASAP7_75t_SRAM BUFx10_ASAP7_75t_SL BUFx12_ASAP7_75t_SL BUFx12f_ASAP7_75t_SL BUFx16f_ASAP7_75t_SL BUFx24_ASAP7_75t_SL BUFx2_ASAP7_75t_SL BUFx3_ASAP7_75t_SL BUFx4_ASAP7_75t_SL BUFx5_ASAP7_75t_SL BUFx4f_ASAP7_75t_SL BUFx6f_ASAP7_75t_SL BUFx8_ASAP7_75t_SL HB1xp67_ASAP7_75t_SL HB2xp67_ASAP7_75t_SL HB3xp67_ASAP7_75t_SL BUFx10_ASAP7_75t_L BUFx12_ASAP7_75t_L BUFx12f_ASAP7_75t_L BUFx16f_ASAP7_75t_L BUFx24_ASAP7_75t_L BUFx2_ASAP7_75t_L BUFx3_ASAP7_75t_L BUFx4_ASAP7_75t_L BUFx5_ASAP7_75t_L BUFx4f_ASAP7_75t_L BUFx6f_ASAP7_75t_L BUFx8_ASAP7_75t_L HB1xp67_ASAP7_75t_L HB2xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_L BUFx10_ASAP7_75t_R BUFx12_ASAP7_75t_R BUFx12f_ASAP7_75t_R BUFx16f_ASAP7_75t_R BUFx24_ASAP7_75t_R BUFx2_ASAP7_75t_R BUFx3_ASAP7_75t_R BUFx4_ASAP7_75t_R BUFx5_ASAP7_75t_R BUFx4f_ASAP7_75t_R BUFx6f_ASAP7_75t_R BUFx8_ASAP7_75t_R HB1xp67_ASAP7_75t_R HB2xp67_ASAP7_75t_R
[05/04 17:23:06     27s] Total number of usable buffers: 53
[05/04 17:23:06     27s] List of unusable buffers:
[05/04 17:23:06     27s] Total number of unusable buffers: 0
[05/04 17:23:06     27s] List of usable inverters: CKINVDCx10_ASAP7_75t_SRAM CKINVDCx12_ASAP7_75t_SRAM CKINVDCx11_ASAP7_75t_SRAM CKINVDCx14_ASAP7_75t_SRAM CKINVDCx16_ASAP7_75t_SRAM CKINVDCx20_ASAP7_75t_SRAM CKINVDCx8_ASAP7_75t_SRAM CKINVDCx5p33_ASAP7_75t_SRAM CKINVDCx6p67_ASAP7_75t_SRAM CKINVDCx9p33_ASAP7_75t_SRAM INVx11_ASAP7_75t_SRAM INVx13_ASAP7_75t_SRAM INVx1_ASAP7_75t_SRAM INVx2_ASAP7_75t_SRAM INVx3_ASAP7_75t_SRAM INVx4_ASAP7_75t_SRAM INVx5_ASAP7_75t_SRAM INVx6_ASAP7_75t_SRAM INVx8_ASAP7_75t_SRAM INVxp67_ASAP7_75t_SRAM INVxp33_ASAP7_75t_SRAM CKINVDCx10_ASAP7_75t_SL CKINVDCx12_ASAP7_75t_SL CKINVDCx11_ASAP7_75t_SL CKINVDCx14_ASAP7_75t_SL CKINVDCx16_ASAP7_75t_SL CKINVDCx20_ASAP7_75t_SL CKINVDCx8_ASAP7_75t_SL CKINVDCx5p33_ASAP7_75t_SL CKINVDCx6p67_ASAP7_75t_SL CKINVDCx9p33_ASAP7_75t_SL INVx11_ASAP7_75t_SL INVx13_ASAP7_75t_SL INVx1_ASAP7_75t_SL INVx2_ASAP7_75t_SL INVx3_ASAP7_75t_SL INVx4_ASAP7_75t_SL INVx5_ASAP7_75t_SL INVx6_ASAP7_75t_SL INVx8_ASAP7_75t_SL INVxp67_ASAP7_75t_SL INVxp33_ASAP7_75t_SL CKINVDCx10_ASAP7_75t_L CKINVDCx12_ASAP7_75t_L CKINVDCx11_ASAP7_75t_L CKINVDCx14_ASAP7_75t_L CKINVDCx16_ASAP7_75t_L CKINVDCx20_ASAP7_75t_L CKINVDCx8_ASAP7_75t_L CKINVDCx5p33_ASAP7_75t_L CKINVDCx6p67_ASAP7_75t_L CKINVDCx9p33_ASAP7_75t_L INVx11_ASAP7_75t_L INVx13_ASAP7_75t_L INVx1_ASAP7_75t_L INVx2_ASAP7_75t_L INVx3_ASAP7_75t_L INVx4_ASAP7_75t_L INVx5_ASAP7_75t_L INVx6_ASAP7_75t_L INVx8_ASAP7_75t_L INVxp67_ASAP7_75t_L INVxp33_ASAP7_75t_L CKINVDCx10_ASAP7_75t_R CKINVDCx12_ASAP7_75t_R CKINVDCx11_ASAP7_75t_R CKINVDCx14_ASAP7_75t_R CKINVDCx16_ASAP7_75t_R CKINVDCx20_ASAP7_75t_R CKINVDCx8_ASAP7_75t_R CKINVDCx5p33_ASAP7_75t_R CKINVDCx6p67_ASAP7_75t_R CKINVDCx9p33_ASAP7_75t_R INVx11_ASAP7_75t_R INVx13_ASAP7_75t_R INVx1_ASAP7_75t_R INVx2_ASAP7_75t_R INVx3_ASAP7_75t_R INVx4_ASAP7_75t_R INVx5_ASAP7_75t_R INVx6_ASAP7_75t_R INVx8_ASAP7_75t_R INVxp67_ASAP7_75t_R INVxp33_ASAP7_75t_R
[05/04 17:23:06     27s] Total number of usable inverters: 84
[05/04 17:23:06     27s] List of unusable inverters:[05/04 17:23:06     27s] Creating Cell Server, finished. 
[05/04 17:23:06     27s] 

[05/04 17:23:06     27s] Total number of unusable inverters: 0
[05/04 17:23:06     27s] List of identified usable delay cells: BUFx12_ASAP7_75t_SRAM BUFx24_ASAP7_75t_SRAM BUFx4_ASAP7_75t_SRAM BUFx8_ASAP7_75t_SRAM HB2xp67_ASAP7_75t_SRAM HB3xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SL HB4xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_R HB4xp67_ASAP7_75t_R
[05/04 17:23:06     27s] Total number of identified usable delay cells: 11
[05/04 17:23:06     27s] List of identified unusable delay cells:
[05/04 17:23:06     27s] Total number of identified unusable delay cells: 0
[05/04 17:23:06     27s] Deleting Cell Server ...
[05/04 17:23:06     27s] Reading floorplan file - MSDAP_FINAL/MSDAP.fp.gz (mem = 1268.9M).
[05/04 17:23:06     27s] % Begin Load floorplan data ... (date=05/04 17:23:06, mem=1152.6M)
[05/04 17:23:06     27s] 2025/05/04 17:23:06 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:06     27s] 2025/05/04 17:23:06 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] *info: reset 3722 existing net BottomPreferredLayer and AvoidDetour
[05/04 17:23:07     27s] net ignore based on current view = 0
[05/04 17:23:07     27s] Deleting old partition specification.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] Set FPlanBox to (0 0 947520 721152)
[05/04 17:23:07     27s] There are 17 members in group AO.
[05/04 17:23:07     27s]  ... processed partition successfully.
[05/04 17:23:07     27s] Reading binary special route file MSDAP_FINAL/MSDAP.fp.spr.gz (Created by Innovus v19.11-s128_1 on Sat May  3 15:05:18 2025, version: 1)
[05/04 17:23:07     27s] Ending "Read special route file" (total cpu=0:00:00.0, real=0:00:00.0, peak res=1156.4M, current mem=1156.4M)
[05/04 17:23:07     27s] There are 27 nets with weight being set
[05/04 17:23:07     27s] There are 30 nets with bottomPreferredRoutingLayer being set
[05/04 17:23:07     27s] There are 27 nets with avoidDetour being set
[05/04 17:23:07     27s] Extracting standard cell pins and blockage ...... 
[05/04 17:23:07     27s] **WARN: (IMPTR-2104):	Layer M10: Pitch=1280 is less than min width=640 + min spacing=32000.
[05/04 17:23:07     27s] Temporarily expand pitch on layer M10 from 1280 to 11520 (9x).
[05/04 17:23:07     27s] **ERROR: (IMPTR-2101):	Layer M10: Pitch=11520x9 is still less than min width=32000 + min spacing=640.
[05/04 17:23:07     27s] **WARN: (IMPTR-2108):	For layer M10, the gaps of 561 out of 561 tracks are narrower than 8.160um (space 8.000 + width 0.160).
[05/04 17:23:07     27s] Type 'man IMPTR-2108' for more detail.
[05/04 17:23:07     27s]  As a result, your trialRoute congestion could be incorrect.
[05/04 17:23:07     27s] Pin and blockage extraction finished
[05/04 17:23:07     27s] Delete all existing relative floorplan constraints.
[05/04 17:23:07     27s] % End Load floorplan data ... (date=05/04 17:23:07, total cpu=0:00:00.1, real=0:00:01.0, peak res=1156.8M, current mem=1156.8M)
[05/04 17:23:07     27s] Reading congestion map file MSDAP_FINAL/MSDAP.route.congmap.gz ...
[05/04 17:23:07     27s] % Begin Load SymbolTable ... (date=05/04 17:23:07, mem=1157.1M)
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] Suppress "**WARN ..." messages.
[05/04 17:23:07     27s] routingBox: (-1024 -1024) (948544 722176)
[05/04 17:23:07     27s] coreBox:    (0 0) (947520 721152)
[05/04 17:23:07     27s] Un-suppress "**WARN ..." messages.
[05/04 17:23:07     27s] % End Load SymbolTable ... (date=05/04 17:23:07, total cpu=0:00:00.0, real=0:00:00.0, peak res=1159.0M, current mem=1159.0M)
[05/04 17:23:07     27s] Loading place ...
[05/04 17:23:07     27s] % Begin Load placement data ... (date=05/04 17:23:07, mem=1159.0M)
[05/04 17:23:07     27s] Reading placement file - MSDAP_FINAL/MSDAP.place.gz.
[05/04 17:23:07     27s] ** Reading stdCellPlacement_binary (Created by Innovus v19.11-s128_1 on Sat May  3 15:05:19 2025, version# 2) ...
[05/04 17:23:07     27s] Read Views for adaptive view pruning ...
[05/04 17:23:07     27s] Read 0 views from Binary DB for adaptive view pruning
[05/04 17:23:07     27s] *** Checked 4 GNC rules.
[05/04 17:23:07     27s] *** applyConnectGlobalNets disabled.
[05/04 17:23:07     27s] *** Completed restorePlace (cpu=0:00:00.0 real=0:00:00.0 mem=1272.2M) ***
[05/04 17:23:07     27s] Total net length = 3.759e+04 (2.058e+04 1.702e+04) (ext = 2.274e+03)
[05/04 17:23:07     27s] % End Load placement data ... (date=05/04 17:23:07, total cpu=0:00:00.1, real=0:00:00.0, peak res=1161.9M, current mem=1161.9M)
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] Reading PG file MSDAP_FINAL/MSDAP.pg.gz
[05/04 17:23:07     27s] *** Completed restorePGFile (cpu=0:00:00.0 real=0:00:00.0 mem=1268.2M) ***
[05/04 17:23:07     27s] % Begin Load routing data ... (date=05/04 17:23:07, mem=1162.1M)
[05/04 17:23:07     27s] Reading routing file - MSDAP_FINAL/MSDAP.route.gz.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] Reading Innovus routing data (Created by Innovus v19.11-s128_1 on Sat May  3 15:05:19 2025 Format: 19.1) ...
[05/04 17:23:07     27s] *** Total 3232 nets are successfully restored.
[05/04 17:23:07     27s] *** Completed restoreRoute (cpu=0:00:00.0 real=0:00:00.0 mem=1269.2M) ***
[05/04 17:23:07     27s] % End Load routing data ... (date=05/04 17:23:07, total cpu=0:00:00.0, real=0:00:00.0, peak res=1166.1M, current mem=1166.1M)
[05/04 17:23:07     27s] Loading Drc markers ...
[05/04 17:23:07     27s] 2025/05/04 17:23:07 WARNING This OS does not appear to be a Cadence supported Linux configuration.
[05/04 17:23:07     27s] 2025/05/04 17:23:07 For more info, please run CheckSysConf in <cdsRoot/tools.lnx86/bin/checkSysConf <productId>
[05/04 17:23:07     27s] ... 527 markers are loaded ...
[05/04 17:23:07     27s] ... 527 geometry drc markers are loaded ...
[05/04 17:23:07     27s] ... 0 antenna drc markers are loaded ...
[05/04 17:23:07     27s] TAT_INFO: restoreCongMap REAL = 0 : CPU = 0 : MEM = 0.
[05/04 17:23:07     27s] Reading property file MSDAP_FINAL/MSDAP.prop
[05/04 17:23:07     27s] *** Completed restoreProperty (cpu=0:00:00.0 real=0:00:00.0 mem=1274.2M) ***
[05/04 17:23:07     27s] Restoring CPF database ...
[05/04 17:23:07     27s] Creating Cell Server ...(0, 1, 1, 1)
[05/04 17:23:07     27s] Summary for sequential cells identification: 
[05/04 17:23:07     27s]   Identified SBFF number: 68
[05/04 17:23:07     27s]   Identified MBFF number: 0
[05/04 17:23:07     27s]   Identified SB Latch number: 0
[05/04 17:23:07     27s]   Identified MB Latch number: 0
[05/04 17:23:07     27s]   Not identified SBFF number: 0
[05/04 17:23:07     27s]   Not identified MBFF number: 0
[05/04 17:23:07     27s]   Not identified SB Latch number: 0
[05/04 17:23:07     27s]   Not identified MB Latch number: 0
[05/04 17:23:07     27s]   Number of sequential cells which are not FFs: 64
[05/04 17:23:07     27s] Total number of combinational cells: 676
[05/04 17:23:07     27s] Total number of sequential cells: 132
[05/04 17:23:07     27s] Total number of tristate cells: 0
[05/04 17:23:07     27s] Total number of level shifter cells: 0
[05/04 17:23:07     27s] Total number of power gating cells: 0
[05/04 17:23:07     27s] Total number of isolation cells: 0
[05/04 17:23:07     27s] Total number of power switch cells: 0
[05/04 17:23:07     27s] Total number of pulse generator cells: 0
[05/04 17:23:07     27s] Total number of always on buffers: 0
[05/04 17:23:07     27s] Total number of retention cells: 0
[05/04 17:23:07     27s] List of usable buffers: BUFx10_ASAP7_75t_SRAM BUFx12f_ASAP7_75t_SRAM BUFx16f_ASAP7_75t_SRAM BUFx2_ASAP7_75t_SRAM BUFx3_ASAP7_75t_SRAM BUFx5_ASAP7_75t_SRAM BUFx4f_ASAP7_75t_SRAM BUFx6f_ASAP7_75t_SRAM HB1xp67_ASAP7_75t_SRAM BUFx10_ASAP7_75t_SL BUFx12_ASAP7_75t_SL BUFx12f_ASAP7_75t_SL BUFx16f_ASAP7_75t_SL BUFx24_ASAP7_75t_SL BUFx2_ASAP7_75t_SL BUFx3_ASAP7_75t_SL BUFx4_ASAP7_75t_SL BUFx5_ASAP7_75t_SL BUFx4f_ASAP7_75t_SL BUFx6f_ASAP7_75t_SL BUFx8_ASAP7_75t_SL HB1xp67_ASAP7_75t_SL HB2xp67_ASAP7_75t_SL HB3xp67_ASAP7_75t_SL BUFx10_ASAP7_75t_L BUFx12_ASAP7_75t_L BUFx12f_ASAP7_75t_L BUFx16f_ASAP7_75t_L BUFx24_ASAP7_75t_L BUFx2_ASAP7_75t_L BUFx3_ASAP7_75t_L BUFx4_ASAP7_75t_L BUFx5_ASAP7_75t_L BUFx4f_ASAP7_75t_L BUFx6f_ASAP7_75t_L BUFx8_ASAP7_75t_L HB1xp67_ASAP7_75t_L HB2xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_L BUFx10_ASAP7_75t_R BUFx12_ASAP7_75t_R BUFx12f_ASAP7_75t_R BUFx16f_ASAP7_75t_R BUFx24_ASAP7_75t_R BUFx2_ASAP7_75t_R BUFx3_ASAP7_75t_R BUFx4_ASAP7_75t_R BUFx5_ASAP7_75t_R BUFx4f_ASAP7_75t_R BUFx6f_ASAP7_75t_R BUFx8_ASAP7_75t_R HB1xp67_ASAP7_75t_R HB2xp67_ASAP7_75t_R
[05/04 17:23:07     27s] Total number of usable buffers: 53
[05/04 17:23:07     27s] List of unusable buffers:
[05/04 17:23:07     27s] Total number of unusable buffers: 0
[05/04 17:23:07     27s] List of usable inverters: CKINVDCx10_ASAP7_75t_SRAM CKINVDCx12_ASAP7_75t_SRAM CKINVDCx11_ASAP7_75t_SRAM CKINVDCx14_ASAP7_75t_SRAM CKINVDCx16_ASAP7_75t_SRAM CKINVDCx20_ASAP7_75t_SRAM CKINVDCx8_ASAP7_75t_SRAM CKINVDCx5p33_ASAP7_75t_SRAM CKINVDCx6p67_ASAP7_75t_SRAM CKINVDCx9p33_ASAP7_75t_SRAM INVx11_ASAP7_75t_SRAM INVx13_ASAP7_75t_SRAM INVx1_ASAP7_75t_SRAM INVx2_ASAP7_75t_SRAM INVx3_ASAP7_75t_SRAM INVx4_ASAP7_75t_SRAM INVx5_ASAP7_75t_SRAM INVx6_ASAP7_75t_SRAM INVx8_ASAP7_75t_SRAM INVxp67_ASAP7_75t_SRAM INVxp33_ASAP7_75t_SRAM CKINVDCx10_ASAP7_75t_SL CKINVDCx12_ASAP7_75t_SL CKINVDCx11_ASAP7_75t_SL CKINVDCx14_ASAP7_75t_SL CKINVDCx16_ASAP7_75t_SL CKINVDCx20_ASAP7_75t_SL CKINVDCx8_ASAP7_75t_SL CKINVDCx5p33_ASAP7_75t_SL CKINVDCx6p67_ASAP7_75t_SL CKINVDCx9p33_ASAP7_75t_SL INVx11_ASAP7_75t_SL INVx13_ASAP7_75t_SL INVx1_ASAP7_75t_SL INVx2_ASAP7_75t_SL INVx3_ASAP7_75t_SL INVx4_ASAP7_75t_SL INVx5_ASAP7_75t_SL INVx6_ASAP7_75t_SL INVx8_ASAP7_75t_SL INVxp67_ASAP7_75t_SL INVxp33_ASAP7_75t_SL CKINVDCx10_ASAP7_75t_L CKINVDCx12_ASAP7_75t_L CKINVDCx11_ASAP7_75t_L CKINVDCx14_ASAP7_75t_L CKINVDCx16_ASAP7_75t_L CKINVDCx20_ASAP7_75t_L CKINVDCx8_ASAP7_75t_L CKINVDCx5p33_ASAP7_75t_L CKINVDCx6p67_ASAP7_75t_L CKINVDCx9p33_ASAP7_75t_L INVx11_ASAP7_75t_L INVx13_ASAP7_75t_L INVx1_ASAP7_75t_L INVx2_ASAP7_75t_L INVx3_ASAP7_75t_L INVx4_ASAP7_75t_L INVx5_ASAP7_75t_L INVx6_ASAP7_75t_L INVx8_ASAP7_75t_L INVxp67_ASAP7_75t_L INVxp33_ASAP7_75t_L CKINVDCx10_ASAP7_75t_R CKINVDCx12_ASAP7_75t_R CKINVDCx11_ASAP7_75t_R CKINVDCx14_ASAP7_75t_R CKINVDCx16_ASAP7_75t_R CKINVDCx20_ASAP7_75t_R CKINVDCx8_ASAP7_75t_R CKINVDCx5p33_ASAP7_75t_R CKINVDCx6p67_ASAP7_75t_R CKINVDCx9p33_ASAP7_75t_R INVx11_ASAP7_75t_R INVx13_ASAP7_75t_R INVx1_ASAP7_75t_R INVx2_ASAP7_75t_R INVx3_ASAP7_75t_R INVx4_ASAP7_75t_R INVx5_ASAP7_75t_R INVx6_ASAP7_75t_R INVx8_ASAP7_75t_R INVxp67_ASAP7_75t_R INVxp33_ASAP7_75t_R
[05/04 17:23:07     27s] Total number of usable inverters: 84
[05/04 17:23:07     27s] List of unusable inverters:
[05/04 17:23:07     27s] Total number of unusable inverters: 0
[05/04 17:23:07     27s] List of identified usable delay cells: BUFx12_ASAP7_75t_SRAM BUFx24_ASAP7_75t_SRAM BUFx4_ASAP7_75t_SRAM BUFx8_ASAP7_75t_SRAM HB2xp67_ASAP7_75t_SRAM HB3xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SL HB4xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_R HB4xp67_ASAP7_75t_R
[05/04 17:23:07     27s] Total number of identified usable delay cells: 11
[05/04 17:23:07     27s] List of identified unusable delay cells:[05/04 17:23:07     27s] Creating Cell Server, finished. 
[05/04 17:23:07     27s] 

[05/04 17:23:07     27s] Total number of identified unusable delay cells: 0
[05/04 17:23:07     27s] Deleting Cell Server ...
[05/04 17:23:07     27s] Verifying CPF level_shifter rules ...
[05/04 17:23:07     27s] Verifying CPF isolation rules ...
[05/04 17:23:07     27s] -noImplicitRules false                     # bool, default=false, private
[05/04 17:23:07     27s] No isolation cell in libraries.
[05/04 17:23:07     27s] No level shifter cell in libraries.
[05/04 17:23:07     27s] restoreCpf: cpu=0:00:00.12 real=0:00:00.00
[05/04 17:23:07     27s] Start generating vias ...
[05/04 17:23:07     27s] #WARNING (NRDB-2012) The ENCLOSURE statement in layer V3 has the syntax for overhang values without END/SIDE keywords but contains CUTCLASS attribute and the cut defined in the CUTCLASS is rectangular. The new syntax 'END overhang1 SIDE overhang2' must be used in this case. Without the END/SIDE keywords, the larger value is assigned as end overhang and smaller value is assigned as side overhang. 
[05/04 17:23:07     27s] #WARNING (NRDB-2012) The ENCLOSURE statement in layer V3 has the syntax for overhang values without END/SIDE keywords but contains CUTCLASS attribute and the cut defined in the CUTCLASS is rectangular. The new syntax 'END overhang1 SIDE overhang2' must be used in this case. Without the END/SIDE keywords, the larger value is assigned as end overhang and smaller value is assigned as side overhang. 
[05/04 17:23:07     27s] #WARNING (NRDB-2012) The ENCLOSURE statement in layer V5 has the syntax for overhang values without END/SIDE keywords but contains CUTCLASS attribute and the cut defined in the CUTCLASS is rectangular. The new syntax 'END overhang1 SIDE overhang2' must be used in this case. Without the END/SIDE keywords, the larger value is assigned as end overhang and smaller value is assigned as side overhang. 
[05/04 17:23:07     27s] #WARNING (NRFL-369) Ignoring MINIMUMCUT rules with number of cuts less than 2.
[05/04 17:23:07     27s] #WARNING (NRFL-369) Ignoring MINIMUMCUT rules with number of cuts less than 2.
[05/04 17:23:07     27s] #WARNING (NRDB-407) pitch for LAYER Pad is defined too small, reset to 1280
[05/04 17:23:07     27s] #Skip building auto via since it is not turned on.
[05/04 17:23:07     27s] Via generation completed.
[05/04 17:23:07     27s] Extraction setup Started 
[05/04 17:23:07     27s] Initializing multi-corner RC extraction with 2 active RC Corners ...
[05/04 17:23:07     27s] Process node set using 'set_design_mode' is less than or equal to 32nm, for which captable file(s) would be ignored as preRoute extraction would instead use technology file. For post_route extraction, default value for effort level would be 'medium' and effort level 'low' would not be allowed.
[05/04 17:23:08     28s] Generating auto layer map file.
[05/04 17:23:08     28s] Restore PreRoute Pattern Extraction data successful in header.
[05/04 17:23:08     28s] Loading preRoute extracted patterns from file 'MSDAP_FINAL/MSDAP.techData.gz' ...
[05/04 17:23:08     28s] Restore PreRoute Pattern Extraction data failed.
[05/04 17:23:08     28s] Importing multi-corner technology file(s) for preRoute extraction...
[05/04 17:23:08     28s] /home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/mmmc/qrcTechFile_typ03_scaled4xV06
[05/04 17:23:09     29s] Generating auto layer map file.
[05/04 17:23:10     30s] Completed (cpu: 0:00:02.3 real: 0:00:03.0)
[05/04 17:23:10     30s] Set Shrink Factor to 1.00000
[05/04 17:23:10     30s] Summary of Active RC-Corners : 
[05/04 17:23:10     30s]  
[05/04 17:23:10     30s]  Analysis View: PVT_0P63V_100C.setup_view
[05/04 17:23:10     30s]     RC-Corner Name        : PVT_0P63V_100C.setup_rc
[05/04 17:23:10     30s]     RC-Corner Index       : 0
[05/04 17:23:10     30s]     RC-Corner Temperature : 100 Celsius
[05/04 17:23:10     30s]     RC-Corner Cap Table   : ''
[05/04 17:23:10     30s]     RC-Corner PreRoute Res Factor         : 1
[05/04 17:23:10     30s]     RC-Corner PreRoute Cap Factor         : 1
[05/04 17:23:10     30s]     RC-Corner PostRoute Res Factor        : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PostRoute Cap Factor        : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PostRoute XCap Factor       : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PreRoute Clock Res Factor   : 1	[Derived from postRoute_res (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PreRoute Clock Cap Factor   : 1	[Derived from postRoute_cap (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PostRoute Clock Cap Factor  : 1 {1 1 1} 	[Derived from postRoute_cap (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PostRoute Clock Res Factor  : 1 {1 1 1} 	[Derived from postRoute_res (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner Technology file: '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/mmmc/qrcTechFile_typ03_scaled4xV06'
[05/04 17:23:10     30s]  
[05/04 17:23:10     30s]  Analysis View: PVT_0P77V_0C.hold_view
[05/04 17:23:10     30s]     RC-Corner Name        : PVT_0P77V_0C.hold_rc
[05/04 17:23:10     30s]     RC-Corner Index       : 1
[05/04 17:23:10     30s]     RC-Corner Temperature : 0 Celsius
[05/04 17:23:10     30s]     RC-Corner Cap Table   : ''
[05/04 17:23:10     30s]     RC-Corner PreRoute Res Factor         : 1
[05/04 17:23:10     30s]     RC-Corner PreRoute Cap Factor         : 1
[05/04 17:23:10     30s]     RC-Corner PostRoute Res Factor        : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PostRoute Cap Factor        : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PostRoute XCap Factor       : 1 {1 1 1}
[05/04 17:23:10     30s]     RC-Corner PreRoute Clock Res Factor   : 1	[Derived from postRoute_res (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PreRoute Clock Cap Factor   : 1	[Derived from postRoute_cap (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PostRoute Clock Cap Factor  : 1 {1 1 1} 	[Derived from postRoute_cap (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner PostRoute Clock Res Factor  : 1 [05/04 17:23:10     30s] Technology file '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/mmmc/qrcTechFile_typ03_scaled4xV06' associated with first view 'PVT_0P63V_100C.setup_view' will be used as the primary corner for the multi-corner extraction.
{1 1 1} 	[Derived from postRoute_res (effortLevel low)]
[05/04 17:23:10     30s]     RC-Corner Technology file: '/home/013/o/om/oma190007/cad/msdap_new/Scripts/Impl/MSDAP_FINAL/libs/mmmc/qrcTechFile_typ03_scaled4xV06'
[05/04 17:23:10     30s] LayerId::1 widthSet size::1
[05/04 17:23:10     30s] LayerId::2 widthSet size::1
[05/04 17:23:10     30s] LayerId::3 widthSet size::1
[05/04 17:23:10     30s] LayerId::4 widthSet size::1
[05/04 17:23:10     30s] LayerId::5 widthSet size::1
[05/04 17:23:10     30s] LayerId::6 widthSet size::1
[05/04 17:23:10     30s] LayerId::7 widthSet size::1
[05/04 17:23:10     30s] LayerId::8 widthSet size::1
[05/04 17:23:10     30s] LayerId::9 widthSet size::1
[05/04 17:23:10     30s] LayerId::10 widthSet size::1
[05/04 17:23:10     30s] Initializing multi-corner resistance tables ...
[05/04 17:23:10     30s] Default value for post_route extraction mode's extract_rc_effort_level (extract_rc_effort_level option of set_db) changed to 'medium'.
[05/04 17:23:10     30s] Offset for stripe breaking is set to 0.
[05/04 17:23:10     30s] The power planner will set stripe antenna targets to stripe.
[05/04 17:23:10     30s] % Begin Load power constraints ... (date=05/04 17:23:10, mem=1252.6M)
[05/04 17:23:10     30s] source MSDAP_FINAL/MSDAP_power_constraints.tcl
[05/04 17:23:10     30s] 'set_default_switching_activity' finished successfully.
[05/04 17:23:10     30s] % End Load power constraints ... (date=05/04 17:23:10, total cpu=0:00:00.0, real=0:00:00.0, peak res=1253.1M, current mem=1253.1M)
[05/04 17:23:10     30s] % Begin load AAE data ... (date=05/04 17:23:10, mem=1253.1M)
[05/04 17:23:10     30s] AAE DB initialization (MEM=1380.89 CPU=0:00:00.2 REAL=0:00:00.0) 
[05/04 17:23:10     30s] % End load AAE data ... (date=05/04 17:23:10, total cpu=0:00:00.4, real=0:00:00.0, peak res=1260.7M, current mem=1260.7M)
[05/04 17:23:10     30s] Restoring CCOpt config...
[05/04 17:23:10     30s] Creating Cell Server ...(0, 0, 0, 0)
[05/04 17:23:10     30s] Summary for sequential cells identification: 
[05/04 17:23:10     30s]   Identified SBFF number: 68
[05/04 17:23:10     30s]   Identified MBFF number: 0
[05/04 17:23:10     30s]   Identified SB Latch number: 0
[05/04 17:23:10     30s]   Identified MB Latch number: 0
[05/04 17:23:10     30s]   Not identified SBFF number: 0
[05/04 17:23:10     30s]   Not identified MBFF number: 0
[05/04 17:23:10     30s]   Not identified SB Latch number: 0
[05/04 17:23:10     30s]   Not identified MB Latch number: 0
[05/04 17:23:10     30s]   Number of sequential cells which are not FFs: 64
[05/04 17:23:10     30s]  Visiting view : PVT_0P63V_100C.setup_view
[05/04 17:23:10     30s]    : PowerDomain = AO : Weighted F : unweighted  = 2.60 (1.000) with rcCorner = 0
[05/04 17:23:10     30s]    : PowerDomain = AO : Weighted F : unweighted  = 2.60 (1.000) with rcCorner = -1
[05/04 17:23:10     30s]  Visiting view : PVT_0P77V_0C.hold_view
[05/04 17:23:10     30s]    : PowerDomain = AO : Weighted F : unweighted  = 1.90 (1.000) with rcCorner = 1
[05/04 17:23:10     30s]    : PowerDomain = AO : Weighted F : unweighted  = 1.90 (1.000) with rcCorner = -1
[05/04 17:23:10     30s]  Setting StdDelay to 2.60
[05/04 17:23:10     30s] Creating Cell Server, finished. 
[05/04 17:23:10     30s] 
[05/04 17:23:10     30s]   Extracting original clock gating for Sclk...
[05/04 17:23:10     30s]     clock_tree Sclk contains 354 sinks and 0 clock gates.
[05/04 17:23:10     30s]     Extraction for Sclk complete.
[05/04 17:23:10     30s]   Extracting original clock gating for Sclk done.
[05/04 17:23:10     30s]   Extracting original clock gating for Dclk...
[05/04 17:23:10     30s]     clock_tree Dclk contains 38 sinks and 0 clock gates.
[05/04 17:23:10     30s]     Extraction for Dclk complete.
[05/04 17:23:10     30s]   Extracting original clock gating for Dclk done.
[05/04 17:23:10     30s]   The skew group Dclk/my_constraint_mode was created. It contains 38 sinks and 1 sources.
[05/04 17:23:10     30s]   The skew group Sclk/my_constraint_mode was created. It contains 354 sinks and 1 sources.
[05/04 17:23:10     30s]   The skew group Dclk/my_constraint_mode was created. It contains 38 sinks and 1 sources.
[05/04 17:23:10     30s]   The skew group Sclk/my_constraint_mode was created. It contains 354 sinks and 1 sources.
[05/04 17:23:10     30s] Restoring CCOpt config done.
[05/04 17:23:10     30s] Deleting Cell Server ...
[05/04 17:23:10     30s] Creating Cell Server ...(0, 1, 1, 1)
[05/04 17:23:11     30s] Summary for sequential cells identification: 
[05/04 17:23:11     30s]   Identified SBFF number: 68
[05/04 17:23:11     30s]   Identified MBFF number: 0
[05/04 17:23:11     30s]   Identified SB Latch number: 0
[05/04 17:23:11     30s]   Identified MB Latch number: 0
[05/04 17:23:11     30s]   Not identified SBFF number: 0
[05/04 17:23:11     30s]   Not identified MBFF number: 0
[05/04 17:23:11     30s]   Not identified SB Latch number: 0
[05/04 17:23:11     30s]   Not identified MB Latch number: 0
[05/04 17:23:11     30s]   Number of sequential cells which are not FFs: 64
[05/04 17:23:11     30s] Total number of combinational cells: 676
[05/04 17:23:11     30s] Total number of sequential cells: 132
[05/04 17:23:11     30s] Total number of tristate cells: 0
[05/04 17:23:11     30s] Total number of level shifter cells: 0
[05/04 17:23:11     30s] Total number of power gating cells: 0
[05/04 17:23:11     30s] Total number of isolation cells: 0
[05/04 17:23:11     30s] Total number of power switch cells: 0
[05/04 17:23:11     30s] Total number of pulse generator cells: 0
[05/04 17:23:11     30s] Total number of always on buffers: 0
[05/04 17:23:11     30s] Total number of retention cells: 0
[05/04 17:23:11     30s] List of usable buffers: BUFx10_ASAP7_75t_SRAM BUFx12f_ASAP7_75t_SRAM BUFx16f_ASAP7_75t_SRAM BUFx2_ASAP7_75t_SRAM BUFx3_ASAP7_75t_SRAM BUFx5_ASAP7_75t_SRAM BUFx4f_ASAP7_75t_SRAM BUFx6f_ASAP7_75t_SRAM HB1xp67_ASAP7_75t_SRAM BUFx10_ASAP7_75t_SL BUFx12_ASAP7_75t_SL BUFx12f_ASAP7_75t_SL BUFx16f_ASAP7_75t_SL BUFx24_ASAP7_75t_SL BUFx2_ASAP7_75t_SL BUFx3_ASAP7_75t_SL BUFx4_ASAP7_75t_SL BUFx5_ASAP7_75t_SL BUFx4f_ASAP7_75t_SL BUFx6f_ASAP7_75t_SL BUFx8_ASAP7_75t_SL HB1xp67_ASAP7_75t_SL HB2xp67_ASAP7_75t_SL HB3xp67_ASAP7_75t_SL BUFx10_ASAP7_75t_L BUFx12_ASAP7_75t_L BUFx12f_ASAP7_75t_L BUFx16f_ASAP7_75t_L BUFx24_ASAP7_75t_L BUFx2_ASAP7_75t_L BUFx3_ASAP7_75t_L BUFx4_ASAP7_75t_L BUFx5_ASAP7_75t_L BUFx4f_ASAP7_75t_L BUFx6f_ASAP7_75t_L BUFx8_ASAP7_75t_L HB1xp67_ASAP7_75t_L HB2xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_L BUFx10_ASAP7_75t_R BUFx12_ASAP7_75t_R BUFx12f_ASAP7_75t_R BUFx16f_ASAP7_75t_R BUFx24_ASAP7_75t_R BUFx2_ASAP7_75t_R BUFx3_ASAP7_75t_R BUFx4_ASAP7_75t_R BUFx5_ASAP7_75t_R BUFx4f_ASAP7_75t_R BUFx6f_ASAP7_75t_R BUFx8_ASAP7_75t_R HB1xp67_ASAP7_75t_R HB2xp67_ASAP7_75t_R
[05/04 17:23:11     30s] Total number of usable buffers: 53
[05/04 17:23:11     30s] List of unusable buffers:
[05/04 17:23:11     30s] Total number of unusable buffers: 0
[05/04 17:23:11     30s] List of usable inverters: CKINVDCx10_ASAP7_75t_SRAM CKINVDCx12_ASAP7_75t_SRAM CKINVDCx11_ASAP7_75t_SRAM CKINVDCx14_ASAP7_75t_SRAM CKINVDCx16_ASAP7_75t_SRAM CKINVDCx20_ASAP7_75t_SRAM CKINVDCx8_ASAP7_75t_SRAM CKINVDCx5p33_ASAP7_75t_SRAM CKINVDCx6p67_ASAP7_75t_SRAM CKINVDCx9p33_ASAP7_75t_SRAM INVx11_ASAP7_75t_SRAM INVx13_ASAP7_75t_SRAM INVx1_ASAP7_75t_SRAM INVx2_ASAP7_75t_SRAM INVx3_ASAP7_75t_SRAM INVx4_ASAP7_75t_SRAM INVx5_ASAP7_75t_SRAM INVx6_ASAP7_75t_SRAM INVx8_ASAP7_75t_SRAM INVxp67_ASAP7_75t_SRAM INVxp33_ASAP7_75t_SRAM CKINVDCx10_ASAP7_75t_SL CKINVDCx12_ASAP7_75t_SL CKINVDCx11_ASAP7_75t_SL CKINVDCx14_ASAP7_75t_SL CKINVDCx16_ASAP7_75t_SL CKINVDCx20_ASAP7_75t_SL CKINVDCx8_ASAP7_75t_SL CKINVDCx5p33_ASAP7_75t_SL CKINVDCx6p67_ASAP7_75t_SL CKINVDCx9p33_ASAP7_75t_SL INVx11_ASAP7_75t_SL INVx13_ASAP7_75t_SL INVx1_ASAP7_75t_SL INVx2_ASAP7_75t_SL INVx3_ASAP7_75t_SL INVx4_ASAP7_75t_SL INVx5_ASAP7_75t_SL INVx6_ASAP7_75t_SL INVx8_ASAP7_75t_SL INVxp67_ASAP7_75t_SL INVxp33_ASAP7_75t_SL CKINVDCx10_ASAP7_75t_L CKINVDCx12_ASAP7_75t_L CKINVDCx11_ASAP7_75t_L CKINVDCx14_ASAP7_75t_L CKINVDCx16_ASAP7_75t_L CKINVDCx20_ASAP7_75t_L CKINVDCx8_ASAP7_75t_L CKINVDCx5p33_ASAP7_75t_L CKINVDCx6p67_ASAP7_75t_L CKINVDCx9p33_ASAP7_75t_L INVx11_ASAP7_75t_L INVx13_ASAP7_75t_L INVx1_ASAP7_75t_L INVx2_ASAP7_75t_L INVx3_ASAP7_75t_L INVx4_ASAP7_75t_L INVx5_ASAP7_75t_L INVx6_ASAP7_75t_L INVx8_ASAP7_75t_L INVxp67_ASAP7_75t_L INVxp33_ASAP7_75t_L CKINVDCx10_ASAP7_75t_R CKINVDCx12_ASAP7_75t_R CKINVDCx11_ASAP7_75t_R CKINVDCx14_ASAP7_75t_R CKINVDCx16_ASAP7_75t_R CKINVDCx20_ASAP7_75t_R CKINVDCx8_ASAP7_75t_R CKINVDCx5p33_ASAP7_75t_R CKINVDCx6p67_ASAP7_75t_R CKINVDCx9p33_ASAP7_75t_R INVx11_ASAP7_75t_R INVx13_ASAP7_75t_R INVx1_ASAP7_75t_R INVx2_ASAP7_75t_R INVx3_ASAP7_75t_R INVx4_ASAP7_75t_R INVx5_ASAP7_75t_R INVx6_ASAP7_75t_R INVx8_ASAP7_75t_R INVxp67_ASAP7_75t_R INVxp33_ASAP7_75t_R[05/04 17:23:11     30s] Creating Cell Server, finished. 
[05/04 17:23:11     30s] 

[05/04 17:23:11     30s] Total number of usable inverters: 84
[05/04 17:23:11     30s] List of unusable inverters:
[05/04 17:23:11     30s] Total number of unusable inverters: 0
[05/04 17:23:11     30s] List of identified usable delay cells: BUFx12_ASAP7_75t_SRAM BUFx24_ASAP7_75t_SRAM BUFx4_ASAP7_75t_SRAM BUFx8_ASAP7_75t_SRAM HB2xp67_ASAP7_75t_SRAM HB3xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SRAM HB4xp67_ASAP7_75t_SL HB4xp67_ASAP7_75t_L HB3xp67_ASAP7_75t_R HB4xp67_ASAP7_75t_R
[05/04 17:23:11     30s] Total number of identified usable delay cells: 11
[05/04 17:23:11     30s] List of identified unusable delay cells:
[05/04 17:23:11     30s] Total number of identified unusable delay cells: 0
[05/04 17:23:11     30s] Deleting Cell Server ...
[05/04 17:23:11     30s] **WARN: (IMPCTE-107):	The following globals have been obsoleted since version . They will be removed in the next release. 
[05/04 17:23:11     30s] timing_enable_separate_device_slew_effect_sensitivities
[05/04 17:23:11     30s] timing_enable_default_delay_arc
[05/04 17:23:11     30s] #% End load design ... (date=05/04 17:23:11, total cpu=0:00:20.2, real=0:00:21.0, peak res=1355.6M, current mem=1265.7M)
[05/04 17:23:11     30s] report_message: '-start_cmd/-end_cmd' can not be nested. Interior calls do nothing. Ignore.
[05/04 17:23:11     30s] 
[05/04 17:23:11     30s] *** Summary of all messages that are not suppressed in this session:
[05/04 17:23:11     30s] Severity  ID               Count  Summary                                  
[05/04 17:23:11     30s] WARNING   IMPDBTCL-321         1  The attribute '%s' still works but will ...
[05/04 17:23:11     30s] ERROR     IMPTR-2101           1  Layer %s: Pitch=%dx%d is still less than...
[05/04 17:23:11     30s] WARNING   IMPTR-2104           1  Layer %s: Pitch=%d is less than min widt...
[05/04 17:23:11     30s] WARNING   IMPTR-2108           1  For layer M%d, the gaps of %d out of %d ...
[05/04 17:23:11     30s] WARNING   IMPCTE-107           1  The following globals have been obsolete...
[05/04 17:23:11     30s] WARNING   IMPTCM-77            1  Option "%s" for command %s is obsolete a...
[05/04 17:23:11     30s] ERROR     TECHLIB-1171        12  The attribute '%s' of group '%s' on line...
[05/04 17:23:11     30s] WARNING   TECHLIB-1277        16  The %s '%s' has been defined for %s %s '...
[05/04 17:23:11     30s] WARNING   TECHLIB-9108        20   '%s' not specified in the library, usin...
[05/04 17:23:11     30s] *** Message Summary: 41 warning(s), 13 error(s)
[05/04 17:23:11     30s] 
[05/04 17:23:11     30s] 0
[05/04 17:23:11     30s] @innovus 2> set calibre_home [exec realpath [exec dirname [exec which calibre]]/..]
/proj/cad/mentor_2021/aoi_cal_2021.1_33.19
[05/04 17:23:16     31s] @innovus 3> source $calibre_home/lib/cal_enc.tcl
#@ Begin verbose source /proj/cad/mentor_2021/aoi_cal_2021.1_33.19/lib/cal_enc.tcl (pre)
[05/04 17:26:12     40s] @file 1: #/************************************************************************CPY11*/
[05/04 17:26:12     40s] @file 2: #/*   Copyright Mentor Graphics Corporation 2018  All Rights Reserved.    CPY12*/
[05/04 17:26:12     40s] @file 3: #/*                                                                       CPY13*/
[05/04 17:26:12     40s] @file 4: #/*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*/
[05/04 17:26:12     40s] @file 5: #/*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*/
[05/04 17:26:12     40s] @file 6: #/*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*/
[05/04 17:26:12     40s] @file 7: #/************************************************************************CPY17*/
[05/04 17:26:12     40s] @file 8:
[05/04 17:26:12     40s] @file 9: if { [info commands mgc_load_calibre]=="" } {
[05/04 17:26:12     40s] @file 10:
[05/04 17:26:12     40s] @file 11: proc mgc_enc_is_common_ui_mode {} {
[05/04 17:26:12     40s]   set isCuiMode 0
[05/04 17:26:12     40s]   if { [info exists ::env(MGC_CALIBRE_INNOVUS_CUI_MODE)] && $::env(MGC_CALIBRE_INNOVUS_CUI_MODE)=="1298096" } {
[05/04 17:26:12     40s]     if { [info commands eval_legacy] == "eval_legacy" } {
[05/04 17:26:12     40s]       set isCuiMode 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]   }
[05/04 17:26:12     40s]   return $isCuiMode
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] @file 20:
[05/04 17:26:12     40s] @file 21: proc mgc_load_calibre {} {
[05/04 17:26:12     40s]   global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]   if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/04 17:26:12     40s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/04 17:26:12     40s]   }
[05/04 17:26:12     40s]   if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/04 17:26:12     40s]     puts "//   *** Environment variable CALIBRE_HOME or MGC_HOME must be set. ***"
[05/04 17:26:12     40s]     puts "//   *** Calibre interface NOT loaded. ***"
[05/04 17:26:12     40s]     return 0
[05/04 17:26:12     40s]   }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]   set etclf [file join $env(MGC_HOME) lib cal_innovus.tcl]
[05/04 17:26:12     40s]   if { ![file readable $etclf] } {
[05/04 17:26:12     40s]     puts "//   *** Could not read Calibre interface files. ***"
[05/04 17:26:12     40s]     puts "//   *** Calibre interface NOT loaded. ***"
[05/04 17:26:12     40s]     return 0
[05/04 17:26:12     40s]   }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]   if { [info commands eval_legacy]=="eval_legacy" && ![mgc_enc_is_common_ui_mode] } {
[05/04 17:26:12     40s]     eval_legacy "proc mgc_enc_is_common_ui_mode {} { return 0 }"
[05/04 17:26:12     40s]     if { [catch {eval_legacy "source -quiet $etclf"} msg] } {
[05/04 17:26:12     40s]       puts "//  ERROR while loading Calibre interface: $msg"
[05/04 17:26:12     40s]       return 0
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]   } else {
[05/04 17:26:12     40s]     set opt ""
[05/04 17:26:12     40s]     if { [mgc_enc_is_common_ui_mode] } {
[05/04 17:26:12     40s]       set opt "-quiet"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if { [catch "source $opt $etclf" msg] } {
[05/04 17:26:12     40s]       puts "//  ERROR while loading Calibre interface: $msg"
[05/04 17:26:12     40s]       return 0
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]   }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]   return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] @file 59:
[05/04 17:26:12     40s] @file 60: mgc_load_calibre
[05/04 17:26:12     40s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/edi_autofix_cmd.tcl' ...
[05/04 17:26:12     40s] #************************************************************************CPY11*#
[05/04 17:26:12     40s] #*   Copyright Mentor Graphics Corporation 2012  All Rights Reserved.    CPY12*#
[05/04 17:26:12     40s] #*                                                                       CPY13*#
[05/04 17:26:12     40s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/04 17:26:12     40s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/04 17:26:12     40s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/04 17:26:12     40s] #************************************************************************CPY17*#
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc calibre_autofix {args} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # Check if design is loaded
[05/04 17:26:12     40s]     if {[dbgTopCell]==0} {
[05/04 17:26:12     40s]         error "No design loaded!"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {[string compare $args ""]} {
[05/04 17:26:12     40s]         # If setup file is provided from icc_shell
[05/04 17:26:12     40s]         set setup_file $args
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         # If setup file is not provided open Select Setup File form
[05/04 17:26:12     40s]         set types {
[05/04 17:26:12     40s]             {"Tcl Files"     {.tcl} }
[05/04 17:26:12     40s]             {"All files"     *      }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         set setup_file [tk_getOpenFile -title "Select Setup File" -filetypes $types -parent .]
[05/04 17:26:12     40s]         # Selecting file is canceled
[05/04 17:26:12     40s]         if {![string compare $setup_file ""]} {
[05/04 17:26:12     40s]             return
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set fid [open "| $::env(MGC_HOME)/bin/calibre -autofix $setup_file"]
[05/04 17:26:12     40s]     while {[gets $fid line]  >= 0} {
[05/04 17:26:12     40s]         puts $line
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {[catch {close $fid} msg] != 0} {
[05/04 17:26:12     40s]         if {[string match "*WARNING*" $msg]} {
[05/04 17:26:12     40s]             puts $msg
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             error $msg
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         global errorCode
[05/04 17:26:12     40s]         if {"CHILDSTATUS" == [lindex $errorCode 0]} {
[05/04 17:26:12     40s]             set exit_status [lindex $errorCode 2]
[05/04 17:26:12     40s]             puts "exit status is $exit_status"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set fid [open $setup_file r]
[05/04 17:26:12     40s]     while {[gets $fid value]  >= 0} {
[05/04 17:26:12     40s]         if [string match "*set_output_dir*" $value] {
[05/04 17:26:12     40s]             set words [regexp -all -inline {\S+} $value]
[05/04 17:26:12     40s]             set first [lindex $words 0]
[05/04 17:26:12     40s]             if {![string match "#*" $first]} {
[05/04 17:26:12     40s]                 set dir [lindex $words 1]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         } elseif [string match "*set_output_def_file*" $value] {
[05/04 17:26:12     40s]             set words [regexp -all -inline {\S+} $value]
[05/04 17:26:12     40s]             set first [lindex $words 0]
[05/04 17:26:12     40s]             if {![string match "#*" $first]} {
[05/04 17:26:12     40s]                 set def [lindex $words 1]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         } elseif [string match "*set_output_eco_file*" $value] {
[05/04 17:26:12     40s]             set words [regexp -all -inline {\S+} $value]
[05/04 17:26:12     40s]             set first [lindex $words 0]
[05/04 17:26:12     40s]             if {![string match "#*" $first]} {
[05/04 17:26:12     40s]                 set eco [lindex $words 1]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         } 
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {![info exists dir]} {
[05/04 17:26:12     40s]         # set_output_dir command is not in the setup file or commented
[05/04 17:26:12     40s]         set dir Autofix
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {![info exists def]} {
[05/04 17:26:12     40s]         # set_output_def_file command is not in the setup file or commented
[05/04 17:26:12     40s]         set def calibre_autofix.def
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {[info exists eco] && $eco eq "edi"} {
[05/04 17:26:12     40s]         source $dir/calibre_autofix.tcl
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         defIn -specialnets -nets $dir/$def
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc useECOFile {$dir} {
[05/04 17:26:12     40s]     set rVal 0
[05/04 17:26:12     40s]     if {[file readable $dir/calibre_autofix.tcl]} {
[05/04 17:26:12     40s]         set rVal 1
[05/04 17:26:12     40s]     } 
[05/04 17:26:12     40s]     return $rVal
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/edi_autofix_cmd.tcl'.
[05/04 17:26:12     40s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/encounter.tcl' ...
[05/04 17:26:12     40s] #************************************************************************CPY11*#
[05/04 17:26:12     40s] #*   Copyright Mentor Graphics Corporation 2004  All Rights Reserved.    CPY12*#
[05/04 17:26:12     40s] #*                                                                       CPY13*#
[05/04 17:26:12     40s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/04 17:26:12     40s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/04 17:26:12     40s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/04 17:26:12     40s] #*                                                                       CPY17*#
[05/04 17:26:12     40s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/04 17:26:12     40s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/04 17:26:12     40s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/04 17:26:12     40s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/04 17:26:12     40s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/04 17:26:12     40s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/04 17:26:12     40s] #*   particular purpose.                                                 CPY1E*#
[05/04 17:26:12     40s] #*                                                                       CPY1F*#
[05/04 17:26:12     40s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/04 17:26:12     40s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/04 17:26:12     40s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/04 17:26:12     40s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/04 17:26:12     40s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/04 17:26:12     40s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/04 17:26:12     40s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/04 17:26:12     40s] #*   to the claim                                                        CPY1N*#
[05/04 17:26:12     40s] #************************************************************************CPY1O*#
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ##################################################################################
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # encounter.tcl: Calibre-RVE server in the Encounter environment
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] ##################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ##################################################################################
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # This file contains TCL code that opens a server socket and listens for
[05/04 17:26:12     40s] # Calibre-RVE commands on that socket.
[05/04 17:26:12     40s] # 
[05/04 17:26:12     40s] # This file should be sourced in the Encounter environment as follows:
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # source encounter.tcl
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] ##################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @package require Tcl 8.0
[05/04 17:26:12     40s] @package require Tk  8.0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc cmn_source_widgets {} {
[05/04 17:26:12     40s] 	global _ui_vars _ui_fonts
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set geom [wm geom .]
[05/04 17:26:12     40s] 	set _ui_vars(MainGeometry) $geom
[05/04 17:26:12     40s] 	scan $geom "%dx%d+%d+%d" w h x y
[05/04 17:26:12     40s] 	set _ui_vars(wmframeW) [expr [winfo rootx .] - $x]
[05/04 17:26:12     40s] 	set _ui_vars(wmframeH) [expr [winfo rooty .] - $y]
[05/04 17:26:12     40s] 	
[05/04 17:26:12     40s] 	set _ui_fonts(Mono) -Adobe-Courier-Medium-R-Normal--*-150-*-*-*-*-*-*
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	global tcl_platform
[05/04 17:26:12     40s] 	if {$tcl_platform(platform) == "windows"} {
[05/04 17:26:12     40s] 		set _ui_vars(IsPC) 1
[05/04 17:26:12     40s] 		set _ui_vars(PathSeparator) ";"
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		set _ui_vars(IsPC) 0
[05/04 17:26:12     40s] 		set _ui_vars(PathSeparator) ":"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @cmn_source_widgets
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/04 17:26:12     40s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc uimessage_Note {pw msg} {
[05/04 17:26:12     40s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type ok -icon info
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] @proc uimessage_Error {pw msg} {
[05/04 17:26:12     40s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type ok -icon error
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc uimessage_YesNo {pw msg} {
[05/04 17:26:12     40s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type yesno -icon question
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_integer_only {P} {
[05/04 17:26:12     40s] 	if { $P=="-" } {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	} elseif { [regexp {[ \t\n]} $P] } {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return [string is integer $P]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_no_white_spaces {P} {
[05/04 17:26:12     40s] 	if { [regexp {[ \t\n]} $P] } {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ###############################################################################
[05/04 17:26:12     40s] # uiutils_MakeScrolledText --
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # Provides an easy way of creating text widget with scrollbars
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # Arguments:
[05/04 17:26:12     40s] #   <f>          = Frame that will contain everything(gets created below)
[05/04 17:26:12     40s] #   <scrollbars> = What type of scrollbars will be used:
[05/04 17:26:12     40s] #                    {vt, hz, both, none}
[05/04 17:26:12     40s] #   [args]       = The remaining args that get passed to text widget creation
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # Returned Value:
[05/04 17:26:12     40s] #   Handle to internal text widget
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] @proc uiutils_MakeScrolledText {f scrollbars args} {
[05/04 17:26:12     40s] 	global _ui_vars
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s] 	if ![winfo exists $f] {frame $f}
[05/04 17:26:12     40s] 	set main $f
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$scrollbars == "both"} {
[05/04 17:26:12     40s] 		eval text $main.txt $args \
[05/04 17:26:12     40s] 			-yscroll {[list dynsbar2::scrollSet [list grid $main.vt -row 0 -column 1 -sticky ns]]} \
[05/04 17:26:12     40s] 			-xscroll {[list dynsbar2::scrollSet [list grid $main.hz -row 1 -column 0 -sticky we]]}
[05/04 17:26:12     40s] 		scrollbar $main.vt -orient verti -command "$main.txt yview"
[05/04 17:26:12     40s] 		scrollbar $main.hz -orient horiz -command "$main.txt xview"
[05/04 17:26:12     40s] 	} elseif {$scrollbars == "vt"} {
[05/04 17:26:12     40s] 		eval text $main.txt $args \
[05/04 17:26:12     40s] 			-yscroll {[list dynsbar2::scrollSet [list grid $main.vt -row 0 -column 1 -sticky ns]]}
[05/04 17:26:12     40s] 		scrollbar $main.vt -command "$main.txt yview"
[05/04 17:26:12     40s] 	} elseif {$scrollbars == "hz"} {
[05/04 17:26:12     40s] 		eval text $main.txt $args \
[05/04 17:26:12     40s] 			-xscroll {[list dynsbar2::scrollSet [list grid $main.hz -row 1 -column 0 -sticky we]]}
[05/04 17:26:12     40s] 		scrollbar $main.hz -orient horiz -command "$main.txt xview"
[05/04 17:26:12     40s] 	} elseif {$scrollbars == "none"} {
[05/04 17:26:12     40s] 		eval text $main.txt $args
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return {}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s] 	grid $main.txt -row 0 -column 0 -sticky news
[05/04 17:26:12     40s] 	grid rowconfig $main 0 -weight 1
[05/04 17:26:12     40s] 	grid columnconfig $main 0 -weight 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $main.txt
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] #################################################################
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # uiprocs_PositionWindow -- Positions a window relative to the
[05/04 17:26:12     40s] #                     specified parent.
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] # Arguments:
[05/04 17:26:12     40s] #    <w>      = Window to be positioned
[05/04 17:26:12     40s] #    <parent> = Parent window it should be relative to
[05/04 17:26:12     40s] #    [mode]   = Defines relative position to parent
[05/04 17:26:12     40s] #    [showit] = Show window after setting geometry?
[05/04 17:26:12     40s] #
[05/04 17:26:12     40s] @proc uiprocs_PositionWindow {w parent {mode "center"} {showit {1}}} {
[05/04 17:26:12     40s]    global _ui_vars
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s]    # First we will withdraw the window so user
[05/04 17:26:12     40s]    # doesn't see repaints caused by geometry change
[05/04 17:26:12     40s]    wm withdraw $w
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s]    # Due to a problem in Tk4.x that exists on the PC, we must
[05/04 17:26:12     40s]    # force toplevel windows to be resizable for purposes of
[05/04 17:26:12     40s]    # letting Tk calculate geometry data. The effect of this
[05/04 17:26:12     40s]    # problem was that some dialogs would be sized incorrectly.
[05/04 17:26:12     40s]    set curr ""
[05/04 17:26:12     40s]    if {[winfo class $w] == "Toplevel"} {
[05/04 17:26:12     40s]       set curr [wm resizable $w] ;# save existing state
[05/04 17:26:12     40s]       wm resizable $w 1 1        ;# temporarily force resizable
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # It is critical that we "update" before
[05/04 17:26:12     40s]    # querying for geometry information
[05/04 17:26:12     40s]    update
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Now it's safe to restore the resizable state of "w"
[05/04 17:26:12     40s]    if {$curr != ""} { eval wm resizable $w $curr }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Get screen info
[05/04 17:26:12     40s]    set edge_right [winfo screenwidth .]
[05/04 17:26:12     40s]    set edge_bottom [winfo screenheight .]
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s]    # Get parent info.  We first check if it's a toplevel
[05/04 17:26:12     40s]    # window by seeing if we can get wm geometry info.  We
[05/04 17:26:12     40s]    # really only want the x/y values from the "wm geometry"
[05/04 17:26:12     40s]    # call since they take into account the window's frame.
[05/04 17:26:12     40s]    if {[catch {wm geometry $parent} geom] != 0} {
[05/04 17:26:12     40s]       # If it's not a toplevel window then get the
[05/04 17:26:12     40s]       # "root-relative" x/y values
[05/04 17:26:12     40s]       set p_x      [winfo rootx $parent]
[05/04 17:26:12     40s]       set p_y      [winfo rooty $parent]
[05/04 17:26:12     40s]    } else {
[05/04 17:26:12     40s]       scan $geom "%dx%d+%d+%d" width height p_x p_y
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    set p_width  [winfo width $parent]
[05/04 17:26:12     40s]    set p_height [winfo height $parent]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Get info for target window(if curr size info
[05/04 17:26:12     40s]    # is not yet known then we have to use "requested" info)
[05/04 17:26:12     40s]    set w_width  [winfo width $w]
[05/04 17:26:12     40s]    set w_height [winfo height $w]
[05/04 17:26:12     40s]    if {$w_width == 1} {
[05/04 17:26:12     40s]       set w_width  [winfo reqwidth $w]
[05/04 17:26:12     40s]       set w_height [winfo reqheight $w]
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    set x {}
[05/04 17:26:12     40s]    set y {}
[05/04 17:26:12     40s]    switch $mode {
[05/04 17:26:12     40s]       "center" {
[05/04 17:26:12     40s]          set x [expr {$p_x + ($p_width/2) - ($w_width/2)}]
[05/04 17:26:12     40s]          set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/04 17:26:12     40s]          # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]          if {$x < 0} { set x 0 } \
[05/04 17:26:12     40s]          elseif {[expr {$x + $w_width + (2* $_ui_vars(wmframeW))}] > $edge_right} {
[05/04 17:26:12     40s]             set x [expr {$x - ($x + $w_width + (2* $_ui_vars(wmframeW)) - $edge_right)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {$y < 0} { set y 0 }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       "bottom" {
[05/04 17:26:12     40s]          set x $p_x
[05/04 17:26:12     40s]          set y [expr {$p_y + $p_height}]
[05/04 17:26:12     40s]          # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]          if {$x < 0} {set x 0} \
[05/04 17:26:12     40s]          elseif {[expr {$x + $w_width + (2* $_ui_vars(wmframeW))}] > $edge_right} {
[05/04 17:26:12     40s]             set x [expr {$x - ($x + $w_width + (2* $_ui_vars(wmframeW)) - $edge_right)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {$y < 0} { set y 0 } \
[05/04 17:26:12     40s]          elseif {[expr {$y + $w_height}] > $edge_bottom} {
[05/04 17:26:12     40s]             incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          # Check if we need to account for window manager decoration frame width
[05/04 17:26:12     40s]          if {($parent == ".") || \
[05/04 17:26:12     40s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/04 17:26:12     40s]             set y [expr {$y + $_ui_vars(wmframeH) + 5}] 
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       "screencenter" {
[05/04 17:26:12     40s]          set x [expr {($edge_right/2) - ($w_width/2)}]
[05/04 17:26:12     40s]          set y [expr {($edge_bottom/2) - ($w_height/2)}]
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       "right" -
[05/04 17:26:12     40s]       "righttop" -
[05/04 17:26:12     40s]       "rightmiddle" -
[05/04 17:26:12     40s]       "rightbottom" {
[05/04 17:26:12     40s]          set x [expr {$p_x + $p_width}]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]          # Check if we need to account for window manager decoration frame width
[05/04 17:26:12     40s]          if {($parent == ".") || \
[05/04 17:26:12     40s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/04 17:26:12     40s]             set x [expr {$x + (2* $_ui_vars(wmframeW)) + 2}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {[expr {$x + $w_width}] > $edge_right} {
[05/04 17:26:12     40s]             # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]             set x [expr {$x - ($x + $w_width - $edge_right)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {($mode == "right") || ($mode == "righttop")} {
[05/04 17:26:12     40s]             set y [expr {$p_y}]
[05/04 17:26:12     40s]          } elseif {$mode == "rightmiddle"} {
[05/04 17:26:12     40s]             set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/04 17:26:12     40s]          } elseif {$mode == "rightbottom"} {
[05/04 17:26:12     40s]             set y [expr {$p_y + $p_height - $w_height}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       "left" {
[05/04 17:26:12     40s]          set x [expr {$p_x - $w_width}]
[05/04 17:26:12     40s]          set y $p_y
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]          # Check if we need to account for window manager decoration frame width
[05/04 17:26:12     40s]          if {($parent == ".") || \
[05/04 17:26:12     40s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/04 17:26:12     40s]             set x [expr {$x - (2* $_ui_vars(wmframeW)) - 2}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]          if {$x < 0} { set x 0 }
[05/04 17:26:12     40s]          if {$y < 0} { set y 0 } \
[05/04 17:26:12     40s]          elseif {[expr {$y + $w_height}] > $edge_bottom} {
[05/04 17:26:12     40s]             incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       "straddleright" -
[05/04 17:26:12     40s]       "straddlerightbottom" {
[05/04 17:26:12     40s]          set x [expr {$p_x + $p_width - ($w_width / 2)}]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]          # Check if we need to account for window manager decoration frame width
[05/04 17:26:12     40s]          if {($parent == ".") || \
[05/04 17:26:12     40s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/04 17:26:12     40s]             set x [expr {$x + $_ui_vars(wmframeW) + 1}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {[expr {$x + $w_width}] > $edge_right} {
[05/04 17:26:12     40s]             # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]             set x [expr {$x - ($x + $w_width - $edge_right)}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          if {$mode == "straddleright"} {
[05/04 17:26:12     40s]             set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/04 17:26:12     40s]          } else {
[05/04 17:26:12     40s]             set y [expr {$p_y + $p_height - ($w_height/2)}]
[05/04 17:26:12     40s]             
[05/04 17:26:12     40s]             # Adjust so window doesn't go off the screen
[05/04 17:26:12     40s]             if {[expr {$y + $w_height}] > $edge_bottom} {
[05/04 17:26:12     40s]                incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]          # Check if we need to account for window manager decoration frame width
[05/04 17:26:12     40s]          if {($parent == ".") || \
[05/04 17:26:12     40s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/04 17:26:12     40s]             set y [expr {$y - $_ui_vars(wmframeH) - 2}]
[05/04 17:26:12     40s]          }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    
[05/04 17:26:12     40s]    wm geometry $w +$x+$y
[05/04 17:26:12     40s]    if {$_ui_vars(IsPC)} {
[05/04 17:26:12     40s]       update idletasks     ;# required on pc to get positioning to occur
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Now we can show the window(if requested)
[05/04 17:26:12     40s]    if {$showit == 1} {
[05/04 17:26:12     40s]       wm deiconify $w
[05/04 17:26:12     40s]       #raise $w
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # Dynamic scrolling, take two . . . 
[05/04 17:26:12     40s] @namespace eval dynsbar2 {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	namespace export scrollSet hierScrollSet
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc scrollSet {pcmd first last} {
[05/04 17:26:12     40s] 		ScrollSet $pcmd $first $last
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# hier adheres to old scrolling set subcommand format
[05/04 17:26:12     40s] 	proc hierScrollSet {pcmd tU wU fU lU} {
[05/04 17:26:12     40s] 		incr tU -1 ; # Bug in hw_hier.c? Gives us one more than the number of rows.
[05/04 17:26:12     40s] 		if {$tU==0} {
[05/04 17:26:12     40s] 			set first 0.0
[05/04 17:26:12     40s] 			set last 1.0
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			set first [expr {double($fU) / $tU}]
[05/04 17:26:12     40s] 			set last  [expr {double($lU) / $tU}]
[05/04 17:26:12     40s] 			if {$first<0.0} {set first 0.0}
[05/04 17:26:12     40s] 			if {$last>1.0} {set last 1.0}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		ScrollSet $pcmd $first $last
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc ScrollSet {pcmd first last} {
[05/04 17:26:12     40s] 		set sbar [lindex $pcmd 1]
[05/04 17:26:12     40s] 		$sbar set $first $last
[05/04 17:26:12     40s] 		if {($first!=$last) && (($first>0) || (($last>0) && ($last<1)))} {
[05/04 17:26:12     40s] 			eval $pcmd
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @namespace eval mgc_enc {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	variable cmap
[05/04 17:26:12     40s]     variable hlTextObjs
[05/04 17:26:12     40s]     variable hlEdgeObjs
[05/04 17:26:12     40s]     variable hlPolyObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(ENV_VARNAME) "MGC_CALIBRE_LAYOUT_SERVER"
[05/04 17:26:12     40s] 	set env(MGC_CALIBRE_LAYOUT_SERVER_NAME) "Cadence:Encounter"
[05/04 17:26:12     40s] 	set env(MGC_CGI_MONITOR_STDIN) 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # Turn on support for shorthand text highlight command
[05/04 17:26:12     40s]     set env(MGC_RVE_HILIGHT_SHORT_TEXT_CMDS) 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(DEFAULT_PORT) 9189
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(RFILE_BUSY) 0
[05/04 17:26:12     40s] 	set vars(hl_objects) {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(hl_layer) "rve_0"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(hl_layer_basen) rve
[05/04 17:26:12     40s] 	set vars(hl_layer_index) 0
[05/04 17:26:12     40s] 	set vars(max_hl_layer) 0
[05/04 17:26:12     40s] 	set vars(got_show_layers) 0
[05/04 17:26:12     40s] 	set vars(show_layers_lsw_is_current) 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(server_sid) ""
[05/04 17:26:12     40s] 	set vars(last_client_sid) ""
[05/04 17:26:12     40s] 	set vars(client_sockets)    {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(SRANGE_START) 5000
[05/04 17:26:12     40s] 	set vars(SRANGE_END)   9999
[05/04 17:26:12     40s] 	set vars(socket_number) -1
[05/04 17:26:12     40s] 	set vars(socket_host)   ""
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set vars(runcode_version) 4.4
[05/04 17:26:12     40s]     set vars(protocol_version) 4.6
[05/04 17:26:12     40s]     set vars(optionalCommands) [list    \
[05/04 17:26:12     40s]         "mgc_rve_get_poly"              \
[05/04 17:26:12     40s]     ]
[05/04 17:26:12     40s]     set vars(CI_trigger_keys) [list]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     variable userCmds
[05/04 17:26:12     40s]     array set userCmds {}
[05/04 17:26:12     40s]     set vars(userCmdIdx) 0
[05/04 17:26:12     40s]     set vars(menuCmds) [list]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     array set hlTextObjs {}
[05/04 17:26:12     40s]     array set hlEdgeObjs {}
[05/04 17:26:12     40s]     array set hlPolyObjs {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# Name Other is intended for -stippleData option in setLayerPreference, we don't support it here since it don't have stipple name 
[05/04 17:26:12     40s] 	set vars(rve_supported_patterns) [list None Solid Horizontal Vertical Grid Slash Backslash Cross Brick Other]
[05/04 17:26:12     40s] 	set vars(OptionsFile) ".rveencdb"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	foreach type {"GDS" "Verilog" "DEF"} {
[05/04 17:26:12     40s] 		if {![info exists vars(exportOptions$type)]} {
[05/04 17:26:12     40s] 			set vars(exportOptions$type) ""
[05/04 17:26:12     40s]             if {$type eq "Verilog"} {
[05/04 17:26:12     40s]                 if {[info exists env(MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE)]} {
[05/04 17:26:12     40s]                     set vlog_cnfig_file $env(MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE)
[05/04 17:26:12     40s]                     if {[file exists $vlog_cnfig_file]} {
[05/04 17:26:12     40s]                         if {![catch {set rf [open $vlog_cnfig_file r]}]} {
[05/04 17:26:12     40s]                             set vars(exportOptionsVerilog) [read $rf]
[05/04 17:26:12     40s]                             close $rf
[05/04 17:26:12     40s]                         } else {
[05/04 17:26:12     40s]                             puts "Can't open MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE \"$vlog_cnfig_file\" for reading"
[05/04 17:26:12     40s]                         }
[05/04 17:26:12     40s]                     } else {
[05/04 17:26:12     40s]                         puts "Can't find MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE \"$vlog_cnfig_file\""
[05/04 17:26:12     40s]                     }
[05/04 17:26:12     40s]                 }
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		if {![info exists vars(showDlgRunTime$type)]} {
[05/04 17:26:12     40s] 			set vars(showDlgRunTime$type) 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::initRveHighlightPatterns {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	for {set i 0} {$i<16} {incr i} {
[05/04 17:26:12     40s] 		set vars(rve_${i}_color)    red
[05/04 17:26:12     40s] 		set vars(rve_${i}_pattern) None
[05/04 17:26:12     40s] 		set vars(rve_${i}_selectable) 1
[05/04 17:26:12     40s] 		set vars(rve_${i}_width)      1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if { [lsearch [package names] BLT]<0 } {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# 16X16 named bitmap patterns supported in Encounter
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_None {
[05/04 17:26:12     40s] 		#define none16x16_width 16
[05/04 17:26:12     40s] 		#define none16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char none16x16_bits[] = {
[05/04 17:26:12     40s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/04 17:26:12     40s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/04 17:26:12     40s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Solid {
[05/04 17:26:12     40s] 		#define solid16x16_width 16
[05/04 17:26:12     40s] 		#define solid16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char solid16x16_bits[] = {
[05/04 17:26:12     40s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
[05/04 17:26:12     40s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
[05/04 17:26:12     40s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Horizontal {
[05/04 17:26:12     40s] 		#define horizontal16x16_width 16
[05/04 17:26:12     40s] 		#define horizontal16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char horizontal16x16_bits[] = {
[05/04 17:26:12     40s] 			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
[05/04 17:26:12     40s] 			0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/04 17:26:12     40s] 			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Vertical {
[05/04 17:26:12     40s] 		#define vertical16x16_width 16
[05/04 17:26:12     40s] 		#define vertical16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char vertical16x16_bits[] = {
[05/04 17:26:12     40s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
[05/04 17:26:12     40s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
[05/04 17:26:12     40s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Grid {
[05/04 17:26:12     40s] 		#define grid16x16_width 16
[05/04 17:26:12     40s] 		#define grid16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char grid16x16_bits[] = {
[05/04 17:26:12     40s] 			0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00,
[05/04 17:26:12     40s] 			0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
[05/04 17:26:12     40s] 			0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Slash {
[05/04 17:26:12     40s] 		#define slash16x16_width 16
[05/04 17:26:12     40s] 		#define slash16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char slash16x16_bits[] = {
[05/04 17:26:12     40s] 			0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x88, 0x88, 0x44, 0x44,
[05/04 17:26:12     40s] 			0x22, 0x22, 0x11, 0x11, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11,
[05/04 17:26:12     40s] 			0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Backslash {
[05/04 17:26:12     40s] 		#define backslash16x16_width 16
[05/04 17:26:12     40s] 		#define backslash16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char backslash16x16_bits[] = {
[05/04 17:26:12     40s] 			0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22,
[05/04 17:26:12     40s] 			0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88,
[05/04 17:26:12     40s] 			0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Cross {
[05/04 17:26:12     40s] 		#define cross16x16_width 16
[05/04 17:26:12     40s] 		#define cross16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char cross16x16_bits[] = {
[05/04 17:26:12     40s] 			0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99, 0x99, 0x99, 0x66, 0x66,
[05/04 17:26:12     40s] 			0x66, 0x66, 0x99, 0x99, 0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99,
[05/04 17:26:12     40s] 			0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	blt::bitmap define ::mgc_enc::Pattern_Brick {
[05/04 17:26:12     40s] 		#define brick16x16_width 16
[05/04 17:26:12     40s] 		#define brick16x16_height 16
[05/04 17:26:12     40s] 		static unsigned char brick16x16_bits[] = {
[05/04 17:26:12     40s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
[05/04 17:26:12     40s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
[05/04 17:26:12     40s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff};
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	set vars(rve_pattern_loaded) 1
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] } ;
[05/04 17:26:12     40s] # mgc_enc::loadRveFillPatterns
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::rve_highlight_pattern_changed {i c menuBtn name1 name2 op} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set sPattern $vars(rve_${i}_pattern)
[05/04 17:26:12     40s] 	$c delete all ;# clean up the canvas
[05/04 17:26:12     40s] 	set cw [$c cget -width]
[05/04 17:26:12     40s] 	set ch [$c cget -height]
[05/04 17:26:12     40s] 	set width 1
[05/04 17:26:12     40s] 	if { [info exists vars(rve_${i}_width)] && [string is integer -strict $vars(rve_${i}_width)] } {
[05/04 17:26:12     40s] 		set width $vars(rve_${i}_width)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set color red
[05/04 17:26:12     40s] 	if { [info exists vars(rve_${i}_color)] } {
[05/04 17:26:12     40s] 		set color $vars(rve_${i}_color)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set item [$c create rectangle 1 1 $cw $ch -width $width -outline $color -fill $color]
[05/04 17:26:12     40s] 	if { [info exists vars(rve_pattern_loaded)] && $sPattern!="Other" } {
[05/04 17:26:12     40s] 		$c itemconfigure $item -stipple ::mgc_enc::Pattern_$sPattern
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::rve_choose_color {i} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set color [tk_chooseColor -initialcolor red -title "Choose highlight color for rve_$i"]
[05/04 17:26:12     40s] 	if { $color!="" } {
[05/04 17:26:12     40s] 		set vars(rve_${i}_color) $color
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setExportOptions {type options show_dlg_at_runtime} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(exportOptions$type) $options
[05/04 17:26:12     40s] 	set vars(showDlgRunTime$type) $show_dlg_at_runtime
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getExportOptions {type} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lOptions [list $vars(exportOptions$type) $vars(showDlgRunTime$type)]
[05/04 17:26:12     40s] 	return $lOptions
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ShowError {err} {
[05/04 17:26:12     40s] 	puts stderr $err
[05/04 17:26:12     40s] 	uimessage_Error . "Calibre Error: $err"
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ShowNote {msg} {
[05/04 17:26:12     40s] 	uimessage_Note . $msg
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::TranscriptMessage {msg} {
[05/04 17:26:12     40s] 	puts stdout $msg
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SendCmdToClient {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set last_client $vars(last_client_sid)
[05/04 17:26:12     40s] 	if {$last_client!=""} {
[05/04 17:26:12     40s] 		catch {puts $last_client "$args\n"} msg
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetReturnVal {bool} {
[05/04 17:26:12     40s] 	return $bool
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::DesignLoaded {{show_msg 0}} {
[05/04 17:26:12     40s] 	if {[getTopCell]==0} {
[05/04 17:26:12     40s] 		if {$show_msg} {
[05/04 17:26:12     40s] 			mgc_enc::ShowNote "No design loaded!"
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			error "No design loaded!"
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckCellMapping {rvecell editcell msg} {
[05/04 17:26:12     40s] 	variable cmap
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set map_cell $rvecell
[05/04 17:26:12     40s] 	if {[info exists cmap($rvecell)]} {
[05/04 17:26:12     40s] 		set map_cell $cmap($rvecell)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[string compare $map_cell $editcell]} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if {![uimessage_YesNo . $msg]} {
[05/04 17:26:12     40s] 			return 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set cmap($rvecell) $editcell
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckHighlightContext {fname editcell {is_import 0}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set f [open $fname r]
[05/04 17:26:12     40s] 	set line1 [split [gets $f]]
[05/04 17:26:12     40s] 	set line2 [gets $f]
[05/04 17:26:12     40s] 	close $f
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[string compare [lindex $line1 0] "mgc_rve_context"]==0} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set fcell [string trim [lindex $line1 1] "\""]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if {$is_import} {
[05/04 17:26:12     40s] 			set msg "Import data from RVE cell \"${fcell}\"\ninto Encounter cell \"${editcell}\"?"
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			set msg "Show highlights from RVE cell \"${fcell}\"\nin Encounter cell \"${editcell}\"?"
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if {![CheckCellMapping $fcell $editcell $msg]} {
[05/04 17:26:12     40s] 			return [SetReturnVal 0]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {!$is_import} {
[05/04 17:26:12     40s] 		set reset 0
[05/04 17:26:12     40s] 		if {$line2=="mgc_rve_delete_markers"} {
[05/04 17:26:12     40s] 			set reset 1
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		setHighlightColor $reset
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return [SetReturnVal 1]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckExportContext {rvecell editcell} {
[05/04 17:26:12     40s] 	if {![CheckCellMapping $rvecell $editcell "Export Encounter cell \"${editcell}\"\nas Calibre cell \"${rvecell}\"?"]} {
[05/04 17:26:12     40s] 		return [SetReturnVal 0]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return [SetReturnVal 1]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CloseClientSockets {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	foreach client_sid $vars(client_sockets) {
[05/04 17:26:12     40s] 		if {$client_sid!=""} {
[05/04 17:26:12     40s] 			close $client_sid
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(client_sockets) {}
[05/04 17:26:12     40s] 	set vars(last_client_sid) ""
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CloseClientSocket {cid} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	close $cid
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set newlist {}
[05/04 17:26:12     40s] 	foreach client_sid $vars(client_sockets) {
[05/04 17:26:12     40s] 		if {$client_sid!=$cid} {
[05/04 17:26:12     40s] 			lappend newlist $client_sid
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(client_sockets) $newlist
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$cid==$vars(last_client_sid)} {
[05/04 17:26:12     40s] 		set vars(last_client_sid) ""
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CloseServerSocket {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	if {$vars(server_sid)!=""} {
[05/04 17:26:12     40s] 		close $vars(server_sid)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(server_sid) ""
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CloseServer {} {
[05/04 17:26:12     40s] 	CloseClientSockets
[05/04 17:26:12     40s] 	CloseServerSocket
[05/04 17:26:12     40s] 	exit 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::AutoSeekSocket {{host ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	
[05/04 17:26:12     40s] 	set s_start $vars(SRANGE_START)
[05/04 17:26:12     40s] 	set s_end   $vars(SRANGE_END)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set host [string trim $host]
[05/04 17:26:12     40s] 	set retval 1
[05/04 17:26:12     40s] 	for {set i $s_start} {$i <= $s_end} {incr i} {
[05/04 17:26:12     40s] 	    if { $host eq "" } {
[05/04 17:26:12     40s] 		if { [IsPortAvailable $i] } {
[05/04 17:26:12     40s] 			set retval [catch {socket -server mgc_enc::AcceptConnection $i} vars(server_sid)]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	    } else {
[05/04 17:26:12     40s] 		set retval [catch {socket -myaddr $host -server mgc_enc::AcceptConnection $i} vars(server_sid)]
[05/04 17:26:12     40s] 	    }
[05/04 17:26:12     40s] 	    if { $retval==0 } { return $i }
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(server_sid) ""
[05/04 17:26:12     40s] 	if { $host eq "" } { set host "localhost" }
[05/04 17:26:12     40s] 	set msg "Could not initialize layout server socket\non $host at any port between $s_start and $s_end.\n\nPlease specify a different socket number or host name\nby using the command:\n\nmgc_enc::initServerSocket <port_number> \[host_name\]\n"
[05/04 17:26:12     40s] 	if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/04 17:26:12     40s] 		append msg "\nRealTime will be disabled!"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	ShowError $msg
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] #-------------------------------------------------------------------------------
[05/04 17:26:12     40s] # DR1273859/1374383/1376672: Need to ensure no other socket connection is listening on network addresses for this port
[05/04 17:26:12     40s] #-------------------------------------------------------------------------------
[05/04 17:26:12     40s] @proc mgc_enc::IsPortAvailable {portNum} {
[05/04 17:26:12     40s] 	set netaddr "127.0.0.1"   ;# not localhost as this may resolve to ipv6 ::1 and successfully connect when 127.0.0.1:port is in use
[05/04 17:26:12     40s] 	set retval [catch {socket -myaddr $netaddr -server mgc_enc::AcceptConnection $portNum} sid]
[05/04 17:26:12     40s] 	if { $retval==0 } {
[05/04 17:26:12     40s] 		close $sid
[05/04 17:26:12     40s] 		set retval [catch {socket -myaddr [info hostname] -server mgc_enc::AcceptConnection $portNum} sid]
[05/04 17:26:12     40s] 		if { $retval==0 } {
[05/04 17:26:12     40s] 			close $sid
[05/04 17:26:12     40s] 			return 1
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::OnServerChangeEvent {PreOrPost host portNum} {
[05/04 17:26:12     40s] 	if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/04 17:26:12     40s] 		if { [info procs ::calibre::realtime::${PreOrPost}EncServerChangeEvent]!="" } {
[05/04 17:26:12     40s] 			::calibre::realtime::${PreOrPost}EncServerChangeEvent $host $portNum
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CreateServerSocket {portNum {host ""} {autoSeek 1}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if { $portNum=="" || [regexp "\[^0-9\]+" $portNum] } {
[05/04 17:26:12     40s] 		ShowError "Invalid port-number specified ($portNum)."
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# Notify RealTime server to prevent it from exiting.
[05/04 17:26:12     40s] 	OnServerChangeEvent "Pre" $vars(socket_host) $vars(socket_number)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	CloseClientSockets
[05/04 17:26:12     40s] 	CloseServerSocket
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set announce_number 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set host [string trim $host]
[05/04 17:26:12     40s] 	set retval 1
[05/04 17:26:12     40s] 	if { $host eq "" } {
[05/04 17:26:12     40s] 		if { [IsPortAvailable $portNum] } {
[05/04 17:26:12     40s] 			set retval [catch {socket -server mgc_enc::AcceptConnection $portNum} vars(server_sid)]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		set retval [catch {socket -myaddr $host -server mgc_enc::AcceptConnection $portNum} vars(server_sid)]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	if {$retval} {
[05/04 17:26:12     40s] 		set vars(server_sid) ""
[05/04 17:26:12     40s] 		if {!$autoSeek} {
[05/04 17:26:12     40s] 			set msg "Could not initialize layout server socket\nat $host:$portNum.\n\nPlease specify a different socket number or host name\nby using the command:\n\nmgc_enc::initServerSocket <port_number> \[host_name\]\n"
[05/04 17:26:12     40s] 			if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/04 17:26:12     40s] 				append msg "\nRealTime will be disabled!"
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 			ShowError $msg
[05/04 17:26:12     40s] 			OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/04 17:26:12     40s] 			return 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set msg "Could not initialize Calibre layout-server socket at $host:$portNum. Trying to find free socket ..."
[05/04 17:26:12     40s] 		TranscriptMessage $msg
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set portNum [AutoSeekSocket $host]
[05/04 17:26:12     40s] 		if {$portNum==0} {
[05/04 17:26:12     40s] 			OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/04 17:26:12     40s] 			return 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set announce_number 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if { $host eq "" } {
[05/04 17:26:12     40s] 	    set msg "Calibre layout-server initialized successfully at socket localhost:$portNum"
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 	    set msg "Calibre layout-server initialized successfully at socket $host:$portNum"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	TranscriptMessage $msg
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set env($vars(ENV_VARNAME)) "$host:$portNum"
[05/04 17:26:12     40s] 	if { ![info exists env(MGC_CALIBRE_SCHEMATIC_SERVER)] } {
[05/04 17:26:12     40s] 	    set env(MGC_CALIBRE_SCHEMATIC_SERVER) "$host:$portNum"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(socket_host) $host
[05/04 17:26:12     40s] 	set vars(socket_number) $portNum
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# ER1202567: Innovus RealTime Step 1: Create Infrastructures
[05/04 17:26:12     40s] 	OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::GetDefaultSocket {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set host ""
[05/04 17:26:12     40s] 	if {[info exists env($vars(ENV_VARNAME))]} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set layout_env $env($vars(ENV_VARNAME))
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if {$layout_env==""} {
[05/04 17:26:12     40s] 			# don't initialize the server socket!
[05/04 17:26:12     40s] 			set msg "Environment variable MGC_CALIBRE_LAYOUT_SERVER is set to blank."
[05/04 17:26:12     40s] 			TranscriptMessage $msg
[05/04 17:26:12     40s] 			return 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set colon_index [string first ":" $layout_env]
[05/04 17:26:12     40s]         if {$colon_index==-1} {
[05/04 17:26:12     40s]             set layout_port $layout_env
[05/04 17:26:12     40s]         } elseif {$colon_index==0} {
[05/04 17:26:12     40s]             set layout_port [string range $layout_env 1 end]
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set host [string range $layout_env 0 [expr {$colon_index-1}]]
[05/04 17:26:12     40s]             set layout_port [string range $layout_env [expr {$colon_index+1}] end]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if { $layout_port=="" || [regexp "\[^0-9\]+" $layout_port] } {
[05/04 17:26:12     40s] 			set msg "Invalid port-number specified ($layout_port).\nPlease set environment-variable\n$vars(ENV_VARNAME)\nto <hostname>:<socket number>."
[05/04 17:26:12     40s] 			ShowError $msg
[05/04 17:26:12     40s] 			return -1
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		
[05/04 17:26:12     40s] 		return [list $host $layout_port]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return [list $host $vars(DEFAULT_PORT)]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::initServerSocket {{portNum ""} {host ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set autoSeek 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if { $vars(socket_number)==$portNum && $vars(socket_host)==$host && $vars(server_sid)!="" } {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$portNum=="" || $portNum<=0} {
[05/04 17:26:12     40s] 		set lHostPort [GetDefaultSocket]
[05/04 17:26:12     40s] 		set host    [lindex $lHostPort 0]
[05/04 17:26:12     40s] 		set portNum [lindex $lHostPort 1]
[05/04 17:26:12     40s] 		if {$portNum<=0} {
[05/04 17:26:12     40s] 			# either don't init socket or error in port specification
[05/04 17:26:12     40s] 			return 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set autoSeek 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return [CreateServerSocket $portNum $host $autoSeek]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::AcceptConnection {cid addr port} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	fileevent $cid readable "mgc_enc::ProcessClientInput $cid"
[05/04 17:26:12     40s] 	fconfigure $cid -buffering line -blocking 0
[05/04 17:26:12     40s] 	set vars(last_client_sid) $cid
[05/04 17:26:12     40s] 	lappend vars(client_sockets) $cid
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # Initial acceptance notification
[05/04 17:26:12     40s]     set lElem [fconfigure $cid -sockname]
[05/04 17:26:12     40s]     set hostName [lindex $lElem 1]
[05/04 17:26:12     40s]     set portNum  [lindex $lElem 2]
[05/04 17:26:12     40s]     if { $hostName=="localhost" || $hostName=="localhost.localdomain" } {
[05/04 17:26:12     40s]         set hostName [info hostname] ;# do NOT use localhost as hostName, it doesn't work across different machines
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set viewerName Cadence:Encounter
[05/04 17:26:12     40s]     set display [getDisplayEnvVar]
[05/04 17:26:12     40s]     set featureList "language Tcl runcode $vars(runcode_version)"
[05/04 17:26:12     40s]     foreach cmd $vars(optionalCommands) {
[05/04 17:26:12     40s]         append featureList " $cmd 1"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     eval SendCmdToClient viewer_connected $hostName $portNum $display $viewerName $vars(protocol_version) $featureList
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::calculateTriggerKey {} {
[05/04 17:26:12     40s]     set key [clock seconds]
[05/04 17:26:12     40s]     set mod [expr {$key%10000}]
[05/04 17:26:12     40s]     set key [string range [expr {$key-([pid]*$mod)}] 4 end]
[05/04 17:26:12     40s]     return $key
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # handles client communication: processes input received from RVE
[05/04 17:26:12     40s] @proc mgc_enc::ProcessClientInput {cid} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[gets $cid request] < 0} {
[05/04 17:26:12     40s] 		if { [eof $cid] } {
[05/04 17:26:12     40s] 			CloseClientSocket $cid
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		# process the incoming request
[05/04 17:26:12     40s] 		set old_socket $vars(last_client_sid)
[05/04 17:26:12     40s] 		# ProcessCmd can cause us to try to send something across
[05/04 17:26:12     40s] 		# the socket.  Make sure we talk to the right socket.
[05/04 17:26:12     40s] 		set vars(last_client_sid) $cid
[05/04 17:26:12     40s] 		# 1st send the incoming request to RealTime server
[05/04 17:26:12     40s] 		if {[info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)]} {
[05/04 17:26:12     40s] 			if { [ProcessRealTimeInput $cid $request] } {
[05/04 17:26:12     40s] 				return
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		if {[ProcessCmd $request]} {
[05/04 17:26:12     40s] 			#set vars(last_client_sid) $cid
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			set vars(last_client_sid) $old_socket
[05/04 17:26:12     40s] 			ShowError "Invalid command: \"$request\""
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ProcessRealTimeInput {cid request} {
[05/04 17:26:12     40s] 	# DR1280729: Virtuoso using 100% CPU caused by Mentor's Calibre not able to handle infosec security scan
[05/04 17:26:12     40s] 	# direct usage of [lindex $requst 0] with invalid input can cause Tcl error,
[05/04 17:26:12     40s] 	# set request "R.7 {@ At least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 Die}" ;# remove closing brace 
[05/04 17:26:12     40s] 	#   lindex $request 0 => unmatched open brace in list
[05/04 17:26:12     40s] 	# split can avoid such issue.
[05/04 17:26:12     40s] 	#   split $request => R.7 \{@ At least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 Die
[05/04 17:26:12     40s] 	set lCmds [split $request]
[05/04 17:26:12     40s] 	set cmd [lindex $lCmds 0]
[05/04 17:26:12     40s] 	# ? matches zero or one instance of previous pattern
[05/04 17:26:12     40s] 	# regexp {^(::)?calibre::realtime::*}   calibre::realtime::cmd => 1
[05/04 17:26:12     40s] 	# regexp {^(::)?calibre::realtime::*} ::calibre::realtime::cmd => 1
[05/04 17:26:12     40s] 	# regexp {^(::)?calibre::realtime::*}  :calibre::realtime::cmd => 0
[05/04 17:26:12     40s] 	if { [regexp {^(::)?calibre::realtime::*} $cmd] } {
[05/04 17:26:12     40s] 		# re-directed to RealTime Tcl code
[05/04 17:26:12     40s] 		# Typically, the cmd is ::calibre::realtime::CmdDispatcher
[05/04 17:26:12     40s] 		eval $cmd $cid [lrange $request 1 end]
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ProcessCmd {in_cmd} {
[05/04 17:26:12     40s] #	puts stdout "RVE: $in_cmd"
[05/04 17:26:12     40s] 	set cmd [split $in_cmd]
[05/04 17:26:12     40s] 	set c1 [lindex $cmd 0]
[05/04 17:26:12     40s] 	set rve_signature "mgc_rve_*"
[05/04 17:26:12     40s] 	if {[string match $rve_signature $c1]} {
[05/04 17:26:12     40s] 		return [ProcessRveCmd $in_cmd]
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		puts stdout "RVE: Rejecting unknown command"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ProcessRveCmd {cmdl} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [lindex $cmdl 0]
[05/04 17:26:12     40s] 	set args [lrange $cmdl 1 end]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	switch -- $cmd {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_rfile"	{
[05/04 17:26:12     40s] 			if {[llength $args]==1} {
[05/04 17:26:12     40s] 				set fname [lindex $args 0]
[05/04 17:26:12     40s] 			    return [$cmd $fname]
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_delete_markers" {
[05/04 17:26:12     40s] 			switch [llength $args] {
[05/04 17:26:12     40s] 				0 {
[05/04 17:26:12     40s] 					return [$cmd]
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 				1 {
[05/04 17:26:12     40s] 				    return [eval $cmd [lindex $args 0]]
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 				2 {
[05/04 17:26:12     40s] 					if {[CheckInteger [lindex $args 1]]} {
[05/04 17:26:12     40s] 						return [eval $cmd [lindex $args 0] [lindex $args 1]]
[05/04 17:26:12     40s] 					}
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_get_location" -
[05/04 17:26:12     40s] 		"mgc_rve_get_rectangle" -
[05/04 17:26:12     40s] 		"mgc_rve_get_poly" -
[05/04 17:26:12     40s] 		"mgc_rve_context" {
[05/04 17:26:12     40s] 			if {[llength $args]==2} {
[05/04 17:26:12     40s] 				set cell [lindex $args 0]
[05/04 17:26:12     40s] 				set precision [lindex $args 1]
[05/04 17:26:12     40s] 				if {[CheckInteger $precision]} {
[05/04 17:26:12     40s] 					return [$cmd $cell $precision]
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_zoom" {
[05/04 17:26:12     40s] 			if {[llength $args]==5} {
[05/04 17:26:12     40s] 				set llx [lindex $args 0]
[05/04 17:26:12     40s] 				set lly [lindex $args 1]
[05/04 17:26:12     40s] 				set urx [lindex $args 2]
[05/04 17:26:12     40s] 				set ury [lindex $args 3]
[05/04 17:26:12     40s] 				set zf  [lindex $args 4]
[05/04 17:26:12     40s] 				if {[CheckNumber $llx] && [CheckNumber $lly] && [CheckNumber $urx] && [CheckNumber $ury] && [CheckNumber $zf]} {
[05/04 17:26:12     40s] 					return [$cmd $llx $lly $urx $ury $zf]
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_snet" -
[05/04 17:26:12     40s] 		"mgc_rve_sinst" {
[05/04 17:26:12     40s] 			if {[llength $args]>=4} {
[05/04 17:26:12     40s] 				set cell [lindex $args 0]
[05/04 17:26:12     40s] 				set clear_hl [lindex $args 1]
[05/04 17:26:12     40s] 				set zfactor [lindex $args 2]
[05/04 17:26:12     40s] 				set nets [lrange $args 3 end]
[05/04 17:26:12     40s] 				if {[CheckNumber $zfactor] && [CheckInteger $clear_hl]} {
[05/04 17:26:12     40s] 					return [$cmd $cell $clear_hl $zfactor $nets]
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_probe_snet" -
[05/04 17:26:12     40s] 		"mgc_rve_probe_sinst" {
[05/04 17:26:12     40s] 			if {([llength $args]==1)} {
[05/04 17:26:12     40s] 				return [$cmd [lindex $args 0]]
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_export_layout" {
[05/04 17:26:12     40s] 			set alen [llength $args]
[05/04 17:26:12     40s] 			if {$alen==3 || $alen==7} {
[05/04 17:26:12     40s] 				set cell   [lindex $args 0]
[05/04 17:26:12     40s] 				set format [lindex $args 1]
[05/04 17:26:12     40s] 				set file   [lindex $args 2]
[05/04 17:26:12     40s] 				if {$alen==3} {
[05/04 17:26:12     40s] 					return [$cmd $cell $format $file]
[05/04 17:26:12     40s] 				} else {
[05/04 17:26:12     40s] 					set llx [lindex $args 3]
[05/04 17:26:12     40s] 					set lly [lindex $args 4]
[05/04 17:26:12     40s] 					set dx  [lindex $args 5]
[05/04 17:26:12     40s] 					set dy  [lindex $args 6]
[05/04 17:26:12     40s] 					if {[CheckNumber $llx] && [CheckNumber $lly] && [CheckNumber $dx] && [CheckNumber $dy]} {
[05/04 17:26:12     40s] 						return [$cmd $cell $format $file $llx $lly $dx $dy]
[05/04 17:26:12     40s] 					}
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_export_netlist" {
[05/04 17:26:12     40s] 			if {[llength $args]==3} {
[05/04 17:26:12     40s] 				set cell [lindex $args 0]
[05/04 17:26:12     40s] 				set format [lindex $args 1]
[05/04 17:26:12     40s] 				set file [lindex $args 2]
[05/04 17:26:12     40s] 				return [$cmd $cell $format $file]
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		"mgc_rve_import" {
[05/04 17:26:12     40s] 			if {[llength $args]==2} {
[05/04 17:26:12     40s] 				set fname [lindex $args 0]
[05/04 17:26:12     40s] 				set lname [lindex $args 1]
[05/04 17:26:12     40s] 				return [$cmd $fname $lname]
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s]         "mgc_rve_send_protocol_version" {
[05/04 17:26:12     40s]             if {[llength $args] == 4} {
[05/04 17:26:12     40s]                 foreach {prot_ver host port display} $args {break}
[05/04 17:26:12     40s]                 return [$cmd $prot_ver $host $port $display]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         "mgc_rve_run_viewer_code" {
[05/04 17:26:12     40s]             if {[llength $args] > 2} {
[05/04 17:26:12     40s]                 set key [lindex $args 0]
[05/04 17:26:12     40s]                 set viewerType [lindex $args 1]
[05/04 17:26:12     40s]                 return [eval $cmd $key $viewerType [lrange $args 2 end]]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         "mgc_rve_get_version_for_feature" {
[05/04 17:26:12     40s]             if {[llength $args] == 1} {
[05/04 17:26:12     40s]                 set feature [lindex $args 0]
[05/04 17:26:12     40s]                 return [$cmd $feature]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts stdout "RVE: Rejecting improperly formatted command"
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_get_version_for_feature {feature} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$feature eq "runcode"} {
[05/04 17:26:12     40s]         SendCmdToClient layout_data_ready $vars(runcode_version)
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         SendCmdToClient layout_data_ready 0.0
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_run_viewer_code {key viewerType args} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set runMe 0
[05/04 17:26:12     40s]     if {[info exists ::env(MGC_CALIBRE_ALLOW_VIEWER_TRIGGERS)]} {
[05/04 17:26:12     40s]         set runMeStr $::env(MGC_CALIBRE_ALLOW_VIEWER_TRIGGERS)
[05/04 17:26:12     40s]         if {[string toupper $runMeStr] eq "ALWAYS"} {
[05/04 17:26:12     40s]             set runMe 1
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             ShowError "Viewer triggers are not allowed in this Encounter process"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     } elseif {[lsearch -exact $vars(CI_trigger_keys) $key] != -1} {
[05/04 17:26:12     40s]         set runMe 1
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         ShowError "Viewer triggers are allowed only in Calibre Interactive processes started from Encounter"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$viewerType eq "schematic"} {
[05/04 17:26:12     40s]         set retCmd schematic_done
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         set retCmd layout_done
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$runMe} {
[05/04 17:26:12     40s]         set trigCmd [lindex $args 0]
[05/04 17:26:12     40s]         if {[catch {set result [eval $trigCmd [lrange $args 1 end]]} msg]} {
[05/04 17:26:12     40s]             ShowError "Error while running trigger: $msg"
[05/04 17:26:12     40s]             append retCmd " 0"
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             append retCmd " $result"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         append retCmd " 0"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     eval SendCmdToClient $retCmd
[05/04 17:26:12     40s]     return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_send_protocol_version {protVersion host port display} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set vars(client_protocol_version) $protVersion
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getDisplayEnvVar {} {
[05/04 17:26:12     40s]     global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set host [info hostname]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # $env(DISPLAY) :0.0 0:0 verbena:2 :2 are all valid
[05/04 17:26:12     40s]     if { ![info exists env(DISPLAY)] || $env(DISPLAY)=="0:0" } {
[05/04 17:26:12     40s]         set display $host:0.0
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         set colon_index [string first ":" $env(DISPLAY)]
[05/04 17:26:12     40s]         if {$colon_index>0} {
[05/04 17:26:12     40s]             set display $env(DISPLAY)
[05/04 17:26:12     40s]         } elseif {$colon_index==0} {
[05/04 17:26:12     40s]             set display $host$env(DISPLAY)
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             # there should be : in the env, e.g. 0.0 is not a valid display, just in case.
[05/04 17:26:12     40s]             set display $host:$env(DISPLAY)
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     return $display
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_rfile {in_fname} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$vars(RFILE_BUSY)} {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(RFILE_BUSY) 1
[05/04 17:26:12     40s]     set vars(got_show_layers) 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fname [string trim $in_fname "\""]
[05/04 17:26:12     40s] 	if {![file readable $fname]} {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	incr vars(hl_layer_index)
[05/04 17:26:12     40s] 	if {$vars(hl_layer_index) > $vars(max_hl_layer)} {
[05/04 17:26:12     40s] 		set vars(max_hl_layer) $vars(hl_layer_index)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(hl_layer) "$vars(hl_layer_basen)_$vars(hl_layer_index)"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cval [catch {source -quiet $fname} rval]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(RFILE_BUSY) 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$cval} {
[05/04 17:26:12     40s] 		uimessage_Error . "Error while highlighting:\n$rval"
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set f [open $fname "r"]
[05/04 17:26:12     40s] 	set linecount [ProcessRveFile $f]
[05/04 17:26:12     40s] 	close $f
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$linecount==0} {return 1}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	ShowError "Format error in file $in_fname at line $linecount."
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_delete_markers {{in_cell ""} {in_all 0}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s]     variable hlTextObjs 
[05/04 17:26:12     40s]     variable hlEdgeObjs 
[05/04 17:26:12     40s]     variable hlPolyObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {![DesignLoaded 1]} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	for {set i 0} {$i <= $vars(max_hl_layer)} {incr i} {
[05/04 17:26:12     40s] 		set layer "$vars(hl_layer_basen)_$i"
[05/04 17:26:12     40s] 		deleteCustomLayer $layer
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     catch {array unset hlTextObjs}
[05/04 17:26:12     40s]     catch {array unset hlEdgeObjs}
[05/04 17:26:12     40s]     catch {array unset hlPolyObjs}
[05/04 17:26:12     40s]     array set hlTextObjs {}
[05/04 17:26:12     40s]     array set hlEdgeObjs {}
[05/04 17:26:12     40s]     array set hlPolyObjs {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$vars(RFILE_BUSY)} {
[05/04 17:26:12     40s] 		set vars(hl_layer_index) 0
[05/04 17:26:12     40s] 		set vars(hl_layer) "rve_0"
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		set vars(hl_layer_index) 0
[05/04 17:26:12     40s] 		redraw
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_zoom {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	if {[llength $args]!=5} {return 0}
[05/04 17:26:12     40s] 	set llx [lindex $args 0]
[05/04 17:26:12     40s] 	set lly [lindex $args 1]
[05/04 17:26:12     40s] 	set urx [lindex $args 2]
[05/04 17:26:12     40s] 	set ury [lindex $args 3]
[05/04 17:26:12     40s] 	set zfactor [lindex $args 4]
[05/04 17:26:12     40s] 	if {$zfactor==0} {
[05/04 17:26:12     40s] 		redraw
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	zoomBox $llx $lly $urx $ury
[05/04 17:26:12     40s] 	zoomOut
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_context {cell precision} {
[05/04 17:26:12     40s] 	return [DesignLoaded]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_highlight_index {index args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vars(hl_layer) "$vars(hl_layer_basen)_${index}"
[05/04 17:26:12     40s] 	if {$index > $vars(max_hl_layer)} {
[05/04 17:26:12     40s] 		set vars(max_hl_layer) $index
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	# DR717379: Difficult to see highlight shapes in EDI by default, custom color is not supported either.
[05/04 17:26:12     40s] 	if { [llength $args]==2 } {
[05/04 17:26:12     40s] 		setLayerPreference $vars(hl_layer) -color [lindex $args 1]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_incr_highlight_index {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	incr vars(hl_layer_index)
[05/04 17:26:12     40s] 	if {$vars(hl_layer_index) > $vars(max_hl_layer)} {
[05/04 17:26:12     40s] 		set vars(max_hl_layer) $vars(hl_layer_index)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set vars(hl_layer) "$vars(hl_layer_basen)_$vars(hl_layer_index)"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::get_highlight_index {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	return $vars(hl_layer_index)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_export_stream {cell filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/04 17:26:12     40s] 	return [mgc_enc::_mgc_rve_export_stream $cell $filename $llx $lly $dx $dy]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::_mgc_rve_export_stream {cell filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set exec_ok 1
[05/04 17:26:12     40s] 	if {$vars(showDlgRunTimeGDS) == 1} {
[05/04 17:26:12     40s] 		set exec_ok [SetExportOptions GDS 1]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	if {$exec_ok == 0} {
[05/04 17:26:12     40s] 		TranscriptMessage "GDS export cancelled by user"
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd "[getExportCmd $filename $vars(exportOptionsGDS)]"
[05/04 17:26:12     40s] 	if { $dx>0 && $dy>0 } {
[05/04 17:26:12     40s] 		set urx [expr $llx + $dx]
[05/04 17:26:12     40s] 		set ury [expr $lly + $dy]
[05/04 17:26:12     40s] 		append cmd " -area {$llx $lly $urx $ury}"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[catch {eval $cmd} msg]} {
[05/04 17:26:12     40s] 		TranscriptMessage $msg
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::_mgc_rve_export_def {cell filename} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set exec_ok 1
[05/04 17:26:12     40s] 	if {$vars(showDlgRunTimeDEF) == 1} {
[05/04 17:26:12     40s] 		set exec_ok [SetExportOptions DEF 1]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	if {$exec_ok == 0} {
[05/04 17:26:12     40s] 		TranscriptMessage "DEF export cancelled by user"
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set cmd "[getExportDefCmd $filename $vars(exportOptionsDEF)]"
[05/04 17:26:12     40s] 	if {[catch {eval $cmd} msg]} {
[05/04 17:26:12     40s] 		TranscriptMessage $msg
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_export_layout {cell format filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(exportFileName) [string trim $filename "\""]
[05/04 17:26:12     40s] 	set format [string trim $format \"]
[05/04 17:26:12     40s] 	if {$format!="GDSII" && $format!="DEF"} {
[05/04 17:26:12     40s] 		mgc_enc::ShowError "Calibre Interactive: Cannot export $format format layout from Encounter."
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# Innovus defOut doesn't support -area option, but streamOut does
[05/04 17:26:12     40s] 	if { $format!="GDSII" && $dx>0 && $dy>0 } {
[05/04 17:26:12     40s] 		TranscriptMessage "Area export not implemented. Exporting entire design..."
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$format=="GDSII"} {
[05/04 17:26:12     40s] 		SendCmdToClient layout_done [_mgc_rve_export_stream $cell $filename $llx $lly $dx $dy]
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		SendCmdToClient layout_done [_mgc_rve_export_def $cell $filename]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::_mgc_rve_export_verilog {cell filename} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set exec_ok 1
[05/04 17:26:12     40s] 	if {$vars(showDlgRunTimeVerilog) == 1} {
[05/04 17:26:12     40s] 		set exec_ok [SetExportOptions Verilog 1]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	if {$exec_ok == 0} {
[05/04 17:26:12     40s] 		TranscriptMessage "Verilog export cancelled by user"
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set cmd "[getExportVerilogCmd $filename $vars(exportOptionsVerilog)]"
[05/04 17:26:12     40s] 	if {[catch {eval $cmd} msg]} {
[05/04 17:26:12     40s] 		TranscriptMessage $msg
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::_mgc_rve_export_netlist {cell format filename} {
[05/04 17:26:12     40s] 	if {$format!="VERILOG"} {
[05/04 17:26:12     40s] 		mgc_enc::ShowError "Calibre Interactive: Cannot export $format format netlists from Encounter."
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return [_mgc_rve_export_verilog $cell $filename]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_export_netlist {cell format filename} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(exportFileName) [string trim $filename "\""]
[05/04 17:26:12     40s] 	SendCmdToClient schematic_done [_mgc_rve_export_netlist $cell $format $filename]
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_snet {cell clear_hl zfactor nets} {
[05/04 17:26:12     40s] 	TranscriptMessage "mgc_rve_snet not implemented."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_sinst {cell clear_hl zfactor nets} {
[05/04 17:26:12     40s] 	TranscriptMessage "mgc_rve_sinst not implemented."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_probe_snet {cell} {
[05/04 17:26:12     40s] 	TranscriptMessage "mgc_rve_probe_snet not implemented."
[05/04 17:26:12     40s] 	ShowNote "Functionality not implemented."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_probe_sinst {cell} {
[05/04 17:26:12     40s] 	TranscriptMessage "mgc_rve_probe_sinst not implemented."
[05/04 17:26:12     40s] 	ShowNote "Functionality not implemented."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_get_location {cell precision} {
[05/04 17:26:12     40s] 	set pt [guiGetCoord]
[05/04 17:26:12     40s] 	if { [llength $pt]==2 } {
[05/04 17:26:12     40s] 		SendCmdToClient layout_data_ready [lindex $pt 0] [lindex $pt 1]
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		SendCmdToClient layout_data_ready
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_get_rectangle {cell precision} {
[05/04 17:26:12     40s] 	set box [guiGetBox]
[05/04 17:26:12     40s] 	if { [llength $box]==4 } {
[05/04 17:26:12     40s] 		SendCmdToClient layout_data_ready [lindex $box 0] [lindex $box 1] [lindex $box 2] [lindex $box 3]
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		SendCmdToClient layout_data_ready
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_get_poly {cell precision} {
[05/04 17:26:12     40s] 	set poly [guiGetPoly]
[05/04 17:26:12     40s] 	if { [llength $poly]>1 } {
[05/04 17:26:12     40s] 		# eval to flatten the list
[05/04 17:26:12     40s] 		eval SendCmdToClient layout_data_ready $poly
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		SendCmdToClient layout_data_ready
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_import {fname lname} {
[05/04 17:26:12     40s] 	ShowNote "Functionality not implemented."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_layer {args} {}
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_instance {args} {}
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_device {args} {}
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_port {args} {}
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_pin {args} {}
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_property {args} {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckName {name} {
[05/04 17:26:12     40s] 	set end [string length $name]
[05/04 17:26:12     40s] 	incr end -1
[05/04 17:26:12     40s] 	if {([string index $name 0]!="\"") || ([string index $name $end]!="\"")} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckInteger {num} {
[05/04 17:26:12     40s] 	# No string is functions in Tcl 8.0
[05/04 17:26:12     40s] 	#if {![string is integer -strict $num]} {
[05/04 17:26:12     40s] 	#	return 0
[05/04 17:26:12     40s] 	#}
[05/04 17:26:12     40s] 	if {[scan $num "%d" inum]!=1} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckNumber {num} {
[05/04 17:26:12     40s] 	#   No string is functions in Tcl 8.0
[05/04 17:26:12     40s] 	#if {![string is double -strict $num]} {
[05/04 17:26:12     40s] 	#	return 0
[05/04 17:26:12     40s] 	#}
[05/04 17:26:12     40s] 	if {[scan $num "%g" dnum]!=1} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ProcessRveFile {f} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set linecount 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	while {[gets $f rline]!=-1} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		incr linecount
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set line [split $rline]
[05/04 17:26:12     40s] 		set cmd  [lindex $line 0]
[05/04 17:26:12     40s] 		set args [lrange $line 1 end]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		switch -- $cmd {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"mp" -
[05/04 17:26:12     40s] 			"me" -
[05/04 17:26:12     40s] 			"ml" - 
[05/04 17:26:12     40s] 			"mr" -
[05/04 17:26:12     40s] 			"mpc" -
[05/04 17:26:12     40s] 			"mec" -
[05/04 17:26:12     40s] 			"mgc_rve_zoom" -
[05/04 17:26:12     40s] 			"mgc_rve_poly" -
[05/04 17:26:12     40s] 			"mgc_rve_poly_clear" -
[05/04 17:26:12     40s] 			"mgc_rve_edge" -
[05/04 17:26:12     40s] 			"mgc_rve_edge_clear" -
[05/04 17:26:12     40s] 			"mgc_rve_line" -
[05/04 17:26:12     40s] 			"mgc_rve_rect" {
[05/04 17:26:12     40s] 				set ret [eval $cmd $args]
[05/04 17:26:12     40s] 				if { $ret==0 || $ret=="" } {return $linecount}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"mgc_rve_context" {
[05/04 17:26:12     40s] 				if {[llength $args]!=2} {return $linecount}
[05/04 17:26:12     40s] 				set cell [lindex $args 0]
[05/04 17:26:12     40s] 				set precision [lindex $args 1]
[05/04 17:26:12     40s] 				if {![CheckInteger $precision]} {return $linecount}
[05/04 17:26:12     40s] 				if {![CheckName $cell]} {
[05/04 17:26:12     40s] 					return $linecount
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 				if {![$cmd $cell $precision]} {return $linecount}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"mgc_rve_delete_markers" {
[05/04 17:26:12     40s] 				if {[llength $args]!=0} {return $linecount}
[05/04 17:26:12     40s] 				if {![$cmd]} {return $linecount}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"mgc_rve_text" -
[05/04 17:26:12     40s] 			"mgc_rve_text_clear" -
[05/04 17:26:12     40s] 			"mt" -
[05/04 17:26:12     40s] 			"mtc" {
[05/04 17:26:12     40s] 				if {[llength $args]!=4} {return $linecount}
[05/04 17:26:12     40s] 				foreach a [lrange $args 1 end] {
[05/04 17:26:12     40s] 					if {![CheckNumber $a]} {
[05/04 17:26:12     40s] 						return $linecount
[05/04 17:26:12     40s] 					}
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 				set ret [eval $cmd $args] 
[05/04 17:26:12     40s] 				if { $ret==0 || $ret=="" } {return $linecount}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"" -
[05/04 17:26:12     40s] 			"mgc_rve_layer" -
[05/04 17:26:12     40s] 			"mgc_rve_instance" -
[05/04 17:26:12     40s] 			"mgc_rve_device" -
[05/04 17:26:12     40s] 			"mgc_rve_port" -
[05/04 17:26:12     40s] 			"mgc_rve_pin" -
[05/04 17:26:12     40s] 			"mgc_rve_property" {
[05/04 17:26:12     40s] 				# skip these lines
[05/04 17:26:12     40s] 				continue
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			"mgc_rve_show_layers" {
[05/04 17:26:12     40s] 				if {![eval $cmd $args]} {return $linecount}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 			default {
[05/04 17:26:12     40s] 				return $linecount
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mp {args} {return [eval mgc_rve_poly $args]}
[05/04 17:26:12     40s] @proc mgc_enc::mpc {args} {return [eval mgc_rve_poly_clear $args]}
[05/04 17:26:12     40s] @proc mgc_enc::mr {args} {return [eval mgc_rve_rect $args]}
[05/04 17:26:12     40s] @proc mgc_enc::me {args} {return [eval mgc_rve_edge $args]}
[05/04 17:26:12     40s] @proc mgc_enc::mec {args} {return [eval mgc_rve_edge_clear $args]}
[05/04 17:26:12     40s] @proc mgc_enc::ml {args} {return [eval mgc_rve_line $args]}
[05/04 17:26:12     40s] @proc mgc_enc::mt {args} {return [eval mgc_rve_text $args]}
[05/04 17:26:12     40s] @proc mgc_enc::mtc {args} {return [eval mgc_rve_text_clear $args]}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_rect {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	variable hlPolyObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[llength $args]<4} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set llx [lindex $args 0]
[05/04 17:26:12     40s] 	set lly [lindex $args 1]
[05/04 17:26:12     40s] 	set urx [lindex $args 2]
[05/04 17:26:12     40s] 	set ury [lindex $args 3]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set oid [createGuiRect $vars(hl_layer) $llx $lly $urx $ury]
[05/04 17:26:12     40s] 	lappend hlPolyObjs($llx,$lly) $oid
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return [list $oid]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # We must accommodate trailing property name/val pairs; ignore them 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_poly {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	variable hlPolyObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vcount [lindex $args 0]
[05/04 17:26:12     40s] 	set coords [lrange $args 1 end]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set coords_len [expr {($vcount*2)}]
[05/04 17:26:12     40s] 	if {[llength $coords] < $coords_len} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$vcount==4} {
[05/04 17:26:12     40s] 		# decide if this is a rectangle
[05/04 17:26:12     40s] 		set llx [lindex $coords 0]
[05/04 17:26:12     40s] 		set lly [lindex $coords 1]
[05/04 17:26:12     40s] 		set p2x [lindex $coords 2]
[05/04 17:26:12     40s] 		set p2y [lindex $coords 3]
[05/04 17:26:12     40s] 		set urx [lindex $coords 4]
[05/04 17:26:12     40s] 		set ury [lindex $coords 5]
[05/04 17:26:12     40s] 		set p4x [lindex $coords 6]
[05/04 17:26:12     40s] 		set p4y [lindex $coords 7]
[05/04 17:26:12     40s] 		if {($lly==$p2y) && ($llx==$p4x) && ($urx==$p2x) && ($ury==$p4y)} {
[05/04 17:26:12     40s] 			set oid [createGuiRect $vars(hl_layer) $llx $lly $urx $ury]
[05/04 17:26:12     40s] 			lappend hlPolyObjs($llx,$lly) $oid
[05/04 17:26:12     40s] 			return [list $oid]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fx [lindex $coords 0] ; set fy [lindex $coords 1]
[05/04 17:26:12     40s] 	set x1 $fx ; set y1 $fy
[05/04 17:26:12     40s] 	incr coords_len -1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lOids []
[05/04 17:26:12     40s] 	foreach {x2 y2} [lrange $coords 2 $coords_len] {
[05/04 17:26:12     40s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/04 17:26:12     40s] 		lappend hlPolyObjs($fx,$fy) $oid
[05/04 17:26:12     40s] 		lappend lOids $oid
[05/04 17:26:12     40s] 		set x1 $x2 ; set y1 $y2
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	set oid [createGuiLine $vars(hl_layer) $x2 $y2 $fx $fy]
[05/04 17:26:12     40s] 	lappend hlPolyObjs($fx,$fy) $oid
[05/04 17:26:12     40s] 	lappend lOids $oid
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $lOids
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # We must accommodate trailing property name/val pairs; ignore them 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_edge {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	variable hlEdgeObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set ecount [lindex $args 0]
[05/04 17:26:12     40s] 	set coords [lrange $args 1 end]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set coords_len [expr {($ecount*4)}]
[05/04 17:26:12     40s] 	if {[llength $coords] < $coords_len} {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lOids []
[05/04 17:26:12     40s] 	incr coords_len -1
[05/04 17:26:12     40s] 	set x0 [lindex $coords 0]
[05/04 17:26:12     40s] 	set y0 [lindex $coords 1]
[05/04 17:26:12     40s] 	for {set i 0} {$i < $ecount} {incr i} {
[05/04 17:26:12     40s] 		set vindex [expr {$i*4}]
[05/04 17:26:12     40s] 		set x1 [lindex $coords $vindex] ; incr vindex
[05/04 17:26:12     40s] 		set y1 [lindex $coords $vindex] ; incr vindex
[05/04 17:26:12     40s] 		set x2 [lindex $coords $vindex] ; incr vindex
[05/04 17:26:12     40s] 		set y2 [lindex $coords $vindex]
[05/04 17:26:12     40s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/04 17:26:12     40s] 		lappend hlEdgeObjs($x0,$y0) $oid
[05/04 17:26:12     40s] 		lappend lOids $oid
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $lOids
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_line {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vcount [lindex $args 0]
[05/04 17:26:12     40s] 	set coords [lrange $args 1 end]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[llength $coords]!=[expr {$vcount*2}]} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lOids []
[05/04 17:26:12     40s] 	set x1 [lindex $coords 0] ; set y1 [lindex $coords 1]
[05/04 17:26:12     40s] 	foreach {x2 y2} [lrange $coords 2 end] {
[05/04 17:26:12     40s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/04 17:26:12     40s] 		lappend lOids $oid
[05/04 17:26:12     40s] 		set x1 $x2 ; set y1 $y2
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $lOids
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_text_clear {name x y size} {
[05/04 17:26:12     40s]     variable hlTextObjs 
[05/04 17:26:12     40s]     if {[info exists hlTextObjs($x,$y)]} {
[05/04 17:26:12     40s]         foreach obj $hlTextObjs($x,$y) {
[05/04 17:26:12     40s]             catch {deleteGuiObj $obj}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         unset hlTextObjs($x,$y)
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_edge_clear {num_edges args} {
[05/04 17:26:12     40s]     variable hlEdgeObjs 
[05/04 17:26:12     40s]     foreach {x y} $args {break}
[05/04 17:26:12     40s]     if {[info exists hlEdgeObjs($x,$y)]} {
[05/04 17:26:12     40s]         foreach obj $hlEdgeObjs($x,$y) {
[05/04 17:26:12     40s]             catch {deleteGuiObj $obj}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         unset hlEdgeObjs($x,$y)
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_poly_clear {num_pts args} {
[05/04 17:26:12     40s]     variable hlPolyObjs 
[05/04 17:26:12     40s]     foreach {x y} $args {break}
[05/04 17:26:12     40s]     if {[info exists hlPolyObjs($x,$y)]} {
[05/04 17:26:12     40s]         foreach obj $hlPolyObjs($x,$y) {
[05/04 17:26:12     40s]             catch {deleteGuiObj $obj}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         unset hlPolyObjs($x,$y)
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_text {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	variable hlTextObjs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[llength $args]!=4} {return 0}
[05/04 17:26:12     40s] 	set tstr [string trim [lindex $args 0] "\""]
[05/04 17:26:12     40s] 	set x [lindex $args 1]
[05/04 17:26:12     40s] 	set y [lindex $args 2]
[05/04 17:26:12     40s] 	set tsize [lindex $args 3]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set oid [createGuiText $vars(hl_layer) "$tstr" $x $y $tsize]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	lappend hlTextObjs($x,$y) $oid
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return [list $oid]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_start_results_set {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vars(got_show_layers) 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_end_results_set {} {
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_get_all_metal_layers {} {
[05/04 17:26:12     40s] 	set metalLayers [getAllLayers metal]
[05/04 17:26:12     40s] 	# DR1280698: RTD with "Visible layer only checks" recipe ...
[05/04 17:26:12     40s] 	# add allM0 - allM# and allM1Cont - allM#Cont support
[05/04 17:26:12     40s] 	set i 0
[05/04 17:26:12     40s] 	while { [catch {set layer [getLayerByName M$i]}]==0 && $layer } {
[05/04 17:26:12     40s] 		# lappend lValidMetalLayers M${i}
[05/04 17:26:12     40s] 		lappend metalLayers "allM${i}"
[05/04 17:26:12     40s] 		lappend metalLayers "allM[expr $i+1]Cont"
[05/04 17:26:12     40s] 		incr i
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return $metalLayers
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_show_layers {args} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set metalLayers [mgc_rve_get_all_metal_layers]
[05/04 17:26:12     40s] 	foreach layer $metalLayers {
[05/04 17:26:12     40s] 		foreach spec $args {
[05/04 17:26:12     40s] 			# get the layer name, skip layer purpose
[05/04 17:26:12     40s] 			set spec [lindex [split $spec ":"] 0]
[05/04 17:26:12     40s] 			set layerMatched [string match "$spec" $layer]
[05/04 17:26:12     40s] 			# DR 1393161 CTO layer visibility not being applied when using Innovus 19.11 or CUI mode in 18.10 or 19.11
[05/04 17:26:12     40s] 			# In Innovus 19.10/19.11 CUI/Legacy mode, M0/M1/.. is replaced with M0Wire/M1Wire/...
[05/04 17:26:12     40s] 			if { !$layerMatched && [regexp {(M[0-9]+)Wire} $layer ignore wireLayer] } {
[05/04 17:26:12     40s] 				# 'wireLayer' variable is the layer name like M1 _without_ 'Wire' suffix
[05/04 17:26:12     40s] 				# Innovus 19.11: getLayerPreference M8 -isVisible  => **ERROR: (IMPSYC-1885): Layer 'M8' does not exist.
[05/04 17:26:12     40s] 				set layerMatched [string match "$spec" $wireLayer]
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 			if {$layerMatched} {
[05/04 17:26:12     40s] 				if {$vars(got_show_layers) == 0} {
[05/04 17:26:12     40s] 					array unset vars show_layers_lsw_layers,*
[05/04 17:26:12     40s] 					set vars(show_layers_lsw_is_current) 1
[05/04 17:26:12     40s] 					foreach tmpLayer $metalLayers {
[05/04 17:26:12     40s] 						# First hide all layers; we only do that after we are sure we have
[05/04 17:26:12     40s] 						# at least one layer which should be shown.
[05/04 17:26:12     40s] 						setLayerPreference $tmpLayer -isVisible 0
[05/04 17:26:12     40s] 					}
[05/04 17:26:12     40s] 					set vars(got_show_layers) 1
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 				setLayerPreference $layer -isVisible 1
[05/04 17:26:12     40s] 				# record the show layers
[05/04 17:26:12     40s] 				set vars(show_layers_lsw_layers,$layer) 1
[05/04 17:26:12     40s] 				break
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_is_lsw_layers_saved {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set lNames [array names vars lsw_layers,*]
[05/04 17:26:12     40s] 	if { [llength $lNames]<=0 } {
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_record_lsw_layers {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set metalLayers [mgc_rve_get_all_metal_layers]
[05/04 17:26:12     40s] 	foreach layer $metalLayers {
[05/04 17:26:12     40s] 		set isVisible [getLayerPreference $layer -isVisible]
[05/04 17:26:12     40s] 		set vars(lsw_layers,$layer) $isVisible 
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_restore_lsw_layers {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lNames [array names vars lsw_layers,*]
[05/04 17:26:12     40s] 	set metalLayers [string map [list "lsw_layers," ""] $lNames]
[05/04 17:26:12     40s] 	foreach layer $metalLayers {
[05/04 17:26:12     40s] 		set isVisible $vars(lsw_layers,$layer)
[05/04 17:26:12     40s] 		# realtime/innovus-common-ui/capture_restore_layer_visibility
[05/04 17:26:12     40s] 		# NOK: get_layer_preference allM3Cont -is_visible => 2
[05/04 17:26:12     40s] 		# if { $isVisible } { set isVisible 1 }
[05/04 17:26:12     40s] 		# set_layer_preference M3Cont -is_visible 0
[05/04 17:26:12     40s] 		# => set_layer_preference allM3Cont -is_visible 2
[05/04 17:26:12     40s] 		# CUI mode only allow {0 1} as value for -is_visible, while legacy mode allow {0 1 2}.
[05/04 17:26:12     40s] 		# the value of 2 must have some special undocumented meaning.
[05/04 17:26:12     40s] 		if { $isVisible==2 && [is_common_ui_mode] } {
[05/04 17:26:12     40s] 			eval_legacy "setLayerPreference $layer -isVisible $isVisible"
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			setLayerPreference $layer -isVisible $isVisible
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_restore_show_layers_lsw_layers {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set lNames [array names vars show_layers_lsw_layers,*]
[05/04 17:26:12     40s] 	if { [llength $lNames]>0 } {
[05/04 17:26:12     40s] 		set metalLayers [mgc_rve_get_all_metal_layers]
[05/04 17:26:12     40s] 		foreach tmpLayer $metalLayers {
[05/04 17:26:12     40s] 			setLayerPreference $tmpLayer -isVisible 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set lswLayers [string map [list "show_layers_lsw_layers," ""] $lNames]
[05/04 17:26:12     40s] 		foreach layer $lswLayers {
[05/04 17:26:12     40s] 			setLayerPreference $layer -isVisible 1
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set vars(show_layers_lsw_is_current) 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::mgc_rve_toggle_visible_layer_set {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if { $vars(show_layers_lsw_is_current) } {
[05/04 17:26:12     40s] 		mgc_rve_restore_lsw_layers
[05/04 17:26:12     40s] 		set vars(show_layers_lsw_is_current) 0
[05/04 17:26:12     40s] 		redraw
[05/04 17:26:12     40s] 	} elseif { [array names vars show_layers_lsw_layers,*]!="" } {
[05/04 17:26:12     40s] 		mgc_rve_restore_show_layers_lsw_layers
[05/04 17:26:12     40s] 		set vars(show_layers_lsw_is_current) 1
[05/04 17:26:12     40s] 		redraw
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupLayoutExport {} {
[05/04 17:26:12     40s] 	mgc_enc::ShowNote \
[05/04 17:26:12     40s] "Calibre uses the Encounter streamOut
[05/04 17:26:12     40s] command to export layout."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupNetlistExport {} {
[05/04 17:26:12     40s] 	mgc_enc::ShowNote \
[05/04 17:26:12     40s] "Calibre uses the Encounter saveNetlist
[05/04 17:26:12     40s] command to export netlists."
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::DisplayFileContents {w fname} {
[05/04 17:26:12     40s] 	global _ui_fonts
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {![winfo exists $w.txtf]} {
[05/04 17:26:12     40s] 		set txt [uiutils_MakeScrolledText $w.txtf "both" -font $_ui_fonts(Mono) -wrap none -relief flat -height 40]
[05/04 17:26:12     40s] 		pack $w.txtf -side top -fill both -expand 1
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		set txt $w.txtf.txt
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	$txt config -state normal	
[05/04 17:26:12     40s] 	$txt delete 1.0 end
[05/04 17:26:12     40s] 	set af [open $fname r]
[05/04 17:26:12     40s] 	$txt insert end [read $af]
[05/04 17:26:12     40s] 	close $af
[05/04 17:26:12     40s] 	$txt config -state disabled
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupAboutDialog {} {
[05/04 17:26:12     40s] 	global env _ui_fonts
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set twin ".twin"
[05/04 17:26:12     40s] 	if {[winfo exists $twin]} {
[05/04 17:26:12     40s] 		wm deiconify $twin
[05/04 17:26:12     40s] 		raise $twin
[05/04 17:26:12     40s] 		return #t
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set afile [file join $env(MGC_HOME) shared pkgs icv tools queryenc calencREADME]
[05/04 17:26:12     40s] 	if {![file exists $afile] || ![file readable $afile]} {
[05/04 17:26:12     40s] 		uimessage_Note . "Could not read information file:\n\$MGC_HOME/shared/pkgs/icv/tools/queryenc/calencREADME"
[05/04 17:26:12     40s] 		return #t
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	toplevel $twin
[05/04 17:26:12     40s] 	wm withdraw $twin
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	wm protocol $twin WM_DELETE_WINDOW "wm withdraw $twin"
[05/04 17:26:12     40s] 	bind $twin <Escape> "wm withdraw $twin"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vfile [file join $env(MGC_HOME) pkgs icv dependencies version]
[05/04 17:26:12     40s] 	set vtext ""
[05/04 17:26:12     40s] 	if {[catch {set vf [open $vfile r]}]==0} {
[05/04 17:26:12     40s] 		gets $vf vtext
[05/04 17:26:12     40s] 		close $vf
[05/04 17:26:12     40s] 		set vtext "($vtext)"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	wm title $twin "About the Calibre Encounter/Innovus Interface $vtext"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	DisplayFileContents $twin $afile
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	#uiprocs_PositionWindow $twin . "center"
[05/04 17:26:12     40s] 	mgc_enc::PositionWindowOnRight $twin
[05/04 17:26:12     40s] 	
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckEnv {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 	if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/04 17:26:12     40s] 		ShowError "MGC_HOME environment variable is not set!"
[05/04 17:26:12     40s] 		return ""
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	initServerSocket $vars(socket_number) $vars(socket_host)
[05/04 17:26:12     40s] 	return [file join $env(MGC_HOME) "bin" "calibre"]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::StartGUI {cmd cell type} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     append cmd " -gui -${type}"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set doTriggerSetup 1
[05/04 17:26:12     40s]     if {$type eq "rve"} {
[05/04 17:26:12     40s]         set doTriggerSetup 0
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$doTriggerSetup} {
[05/04 17:26:12     40s]         set key [calculateTriggerKey]
[05/04 17:26:12     40s]         set ::env(MGC_CALIBRE_INTERACTIVE_TRIGGER_KEY) $key
[05/04 17:26:12     40s]         lappend vars(CI_trigger_keys) $key
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set retVal ""
[05/04 17:26:12     40s]     if {[catch {set fid [open "| $cmd" "r+"]} emsg]==0} {
[05/04 17:26:12     40s]         fconfigure $fid -buffering line -blocking 0
[05/04 17:26:12     40s]         fileevent $fid readable "mgc_enc::ReadGUI $fid $cell $type"
[05/04 17:26:12     40s]         set vars($type,$cell) $fid
[05/04 17:26:12     40s]         set retVal $fid
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {$doTriggerSetup} {
[05/04 17:26:12     40s]         unset ::env(MGC_CALIBRE_INTERACTIVE_TRIGGER_KEY)
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return $retVal
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ReadGUI {fid cell type {cmd ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	read $fid
[05/04 17:26:12     40s] 	if {[eof $fid]} {
[05/04 17:26:12     40s] 		fconfigure $fid -blocking 1
[05/04 17:26:12     40s] 		catch {close $fid}
[05/04 17:26:12     40s] 		if {$cmd ne ""} {
[05/04 17:26:12     40s] 		    # need to specify $cmd for custom
[05/04 17:26:12     40s] 		    set vars($type,$cmd,$cell) ""
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 		    set vars($type,$cell) ""
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # Check if the process associated with the with the cell and tool type (drc, lvs, etc) has already been started
[05/04 17:26:12     40s] # For a custom menu item, the third param "cmd" must be specified
[05/04 17:26:12     40s] @proc mgc_enc::CheckGUI {cell type {cmd ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	if {$cmd eq ""} {
[05/04 17:26:12     40s] 	    if {[info exists vars($type,$cell)]} {
[05/04 17:26:12     40s] 	        return $vars($type,$cell)
[05/04 17:26:12     40s] 	    }
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 	    if {[info exists vars($type,$cmd,$cell)]} {
[05/04 17:26:12     40s] 	        return $vars($type,$cmd,$cell)
[05/04 17:26:12     40s] 	    }
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return ""
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runDRC {lcell} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell drc]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rdrc_RunDRC $lcell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "drc"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rdrc_SetupDRC $lcell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runDFM {lcell} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell dfm]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rdfm_RunDFM $lcell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "dfm"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rdfm_SetupDFM $lcell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runLVS {lcell {scell ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$scell==""} {set scell $lcell}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell lvs]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rlvs_RunLVS $lcell $scell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "lvs"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rlvs_SetupLVS $lcell $scell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runPEX {lcell {scell ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$scell==""} {set scell $lcell}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell pex]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rpex_RunPEX $lcell $scell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "pex"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rpex_SetupPEX $lcell $scell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runXACT {lcell {scell ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$scell==""} {set scell $lcell}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell xact]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rxact_RunXACT $lcell $scell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "xact"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rxact_SetupXACT $lcell $scell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runPERC {lcell {scell ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {$scell==""} {set scell $lcell}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell pex]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rperc_RunPERC $lcell $scell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "perc"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rperc_SetupPERC $lcell $scell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runYE {lcell} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckGUI $lcell ye]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		puts $fid "rye_RunYE $lcell"
[05/04 17:26:12     40s] 		return 1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartGUI $cmd $lcell "ye"]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	puts $fid "rye_SetupYE $lcell"
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runCommand {cmd} {
[05/04 17:26:12     40s] 	if {[catch {eval exec $cmd} cmsg]} {
[05/04 17:26:12     40s] 		TranscriptMessage $cmsg
[05/04 17:26:12     40s] 		return [SetReturnVal 0]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	puts $cmsg
[05/04 17:26:12     40s] 	return [SetReturnVal 1]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ############################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::StartRVE {cmd {params ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	append cmd " -gui -rve $params"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {[catch {set fid [open "| $cmd" "r+"]} emsg]==0} {
[05/04 17:26:12     40s] 		fconfigure $fid -buffering line -blocking 0
[05/04 17:26:12     40s] 		fileevent $fid readable "mgc_enc::ReadRVE $fid"
[05/04 17:26:12     40s] 		lappend vars(rve_fids) $fid
[05/04 17:26:12     40s] 		return $fid
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		return ""
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::ReadRVE {fid} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	read $fid
[05/04 17:26:12     40s] 	if {[eof $fid]} {
[05/04 17:26:12     40s] 		close $fid
[05/04 17:26:12     40s] 		set fid_index [lsearch $vars(rve_fids) $fid]
[05/04 17:26:12     40s] 		if {$fid_index!=-1} {
[05/04 17:26:12     40s] 			set vars(rve_fids) [lreplace $vars(rve_fids) $fid_index $fid_index]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::CheckRVE {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	if {[info exists vars(rve_fids)] && [llength $vars(rve_fids)]!=0} {
[05/04 17:26:12     40s] 		return [lindex $vars(rve_fids) 0]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return ""
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runRVE {{params ""}} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [CheckRVE]
[05/04 17:26:12     40s] 	if {$fid!=""} {
[05/04 17:26:12     40s] 		if {![uimessage_YesNo . "RVE is already running!\nDo you want to start another session?"]} {
[05/04 17:26:12     40s] 			puts $fid rve_PopWindows
[05/04 17:26:12     40s] 			flush $fid
[05/04 17:26:12     40s] 			return 1
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set cmd [CheckEnv]
[05/04 17:26:12     40s] 	if {$cmd==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set fid [StartRVE $cmd $params]
[05/04 17:26:12     40s] 	if {$fid==""} {return 0}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::openRDBFileInRVE {rdbFileName} {
[05/04 17:26:12     40s]     if {[CheckRVE] eq ""} {
[05/04 17:26:12     40s]         runRVE $rdbFileName
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         SendCmdToClient rve_open_rdb_file $rdbFileName
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::openDBInRVE {dbName {topCell ""}} {
[05/04 17:26:12     40s]     if {[CheckRVE] eq ""} {
[05/04 17:26:12     40s]         runRVE "$dbName $topCell"
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s]         set cmd [list rve_open_db $dbName]
[05/04 17:26:12     40s]         if {$topCell ne ""} {
[05/04 17:26:12     40s]             lappend cmd $topCell
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         eval SendCmdToClient $cmd
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runCalibre {prog} {
[05/04 17:26:12     40s]     if {[DesignLoaded 1]} {
[05/04 17:26:12     40s]         if [string match "AUTOFIX" $prog] {
[05/04 17:26:12     40s]             set cmd calibre_autofix
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             if {$prog eq "RVE"} {
[05/04 17:26:12     40s]                 set param ""
[05/04 17:26:12     40s]             } else {
[05/04 17:26:12     40s]                 set param [getCellName [getTopCell]]
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set cmd "mgc_enc::run${prog} $param"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         eval $cmd
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupExport {type} {
[05/04 17:26:12     40s] 	SetExportOptions $type 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetExportOptionsCancel {w type} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(showDlgRunTimeTmp$type) $vars(showDlgRunTime$type)
[05/04 17:26:12     40s] 	set vars(exportDlgStatus) 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetExportOptionsOK {w type txt} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(exportDlgStatus) 1
[05/04 17:26:12     40s] 	set vars(showDlgRunTime$type) $vars(showDlgRunTimeTmp$type)
[05/04 17:26:12     40s] 	set vars(exportOptions$type) [string trim [$txt get 1.0 end]]
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SaveRVELayerPreference {w} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set types { {{Tcl Script} {.tcl}} {{All Files} *} }
[05/04 17:26:12     40s] 	set fName [tk_getSaveFile -filetypes $types]
[05/04 17:26:12     40s] 	if { $fName=="" } { return 0 }
[05/04 17:26:12     40s] 	if {[catch {set fp [open $fName w]}]} {
[05/04 17:26:12     40s] 		uimessage_Error $w "Could not open layer preference file $fName"
[05/04 17:26:12     40s] 		return 0
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	for {set i 0} {$i<16} {incr i} {
[05/04 17:26:12     40s] 		set width 1
[05/04 17:26:12     40s] 		if { [string is integer -strict $vars(rve_${i}_width)] } {
[05/04 17:26:12     40s] 			set width $vars(rve_${i}_width)
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set stipple [string tolower $vars(rve_${i}_pattern)]
[05/04 17:26:12     40s] 		if { $stipple=="other" } {
[05/04 17:26:12     40s] 			set stipple [getLayerPreference rve_$i -stipple]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set visible [getLayerPreference rve_$i -isVisible]
[05/04 17:26:12     40s] 		set sLine "setLayerPreference rve_$i -color $vars(rve_${i}_color) -isVisible $visible -isSelectable $vars(rve_${i}_selectable) -lineWidth $width"
[05/04 17:26:12     40s] 		if { $stipple=="" || $stipple=="none" } {
[05/04 17:26:12     40s] 			set stipple [getLayerPreference rve_$i -stippleData] 
[05/04 17:26:12     40s] 			if { $stipple!="" } { append sLine " -stippleData $stipple" }
[05/04 17:26:12     40s] 		} else {
[05/04 17:26:12     40s] 			append sLine " -stipple $stipple"
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		puts $fp $sLine
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	close $fp
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetupRVECancel {w} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vars(setupRVEStatus) 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetupRVEOK {w} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vars(setupRVEStatus) 1
[05/04 17:26:12     40s] 	for {set i 0} {$i<16} {incr i} {
[05/04 17:26:12     40s] 		set width 1
[05/04 17:26:12     40s] 		if { [string is integer -strict $vars(rve_${i}_width)] } {
[05/04 17:26:12     40s] 			set width $vars(rve_${i}_width)
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		set stipple [string tolower $vars(rve_${i}_pattern)]
[05/04 17:26:12     40s] 		if { $stipple!="other" } {
[05/04 17:26:12     40s] 			setLayerPreference rve_$i -stipple $stipple
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		setLayerPreference rve_$i -color $vars(rve_${i}_color) -isSelectable $vars(rve_${i}_selectable) -lineWidth $width
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetupSocketCancel {w} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set vars(setupSocketStatus) 0
[05/04 17:26:12     40s] 	set vars(tmp_socket_number) $vars(socket_number)
[05/04 17:26:12     40s] 	set vars(tmp_socket_host) $vars(socket_host)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetupSocketOK {w} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set portNum $vars(tmp_socket_number)
[05/04 17:26:12     40s] 	set host $vars(tmp_socket_host)
[05/04 17:26:12     40s] 	if { [string is integer -strict $portNum] && $portNum>=-1 && $portNum<=65535 } {
[05/04 17:26:12     40s] 		set vars(setupSocketStatus) 1
[05/04 17:26:12     40s] 		if { $portNum!=-1 } {
[05/04 17:26:12     40s] 			if { [mgc_enc::initServerSocket $portNum $host] } {
[05/04 17:26:12     40s] 				set vars(socket_number) $portNum
[05/04 17:26:12     40s] 				set vars(socket_host) $host
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		uimessage_Error . "Socket port number must be an integer between -1 and 65535."
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # DR 1362158 Setup commands (RVE, Export GDS, Export Verilog, etc) not working in Innovus Common UI mode.  Avoid 'update' or 'update idle'
[05/04 17:26:12     40s] @proc mgc_enc::WaitForUpdate {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	set ::mgc_enc::vars(waitUpdateVar) 0
[05/04 17:26:12     40s] 	after idle [list set ::mgc_enc::vars(waitUpdateVar) 1]
[05/04 17:26:12     40s] 	while { !$::mgc_enc::vars(waitUpdateVar) } {
[05/04 17:26:12     40s] 		tkwait variable ::mgc_enc::vars(waitUpdateVar)
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::AddFrameLabel {f text {center 0} {fg ""} {bg ""}} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    if ![winfo exists $f] {frame $f}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    set p [winfo parent $f]
[05/04 17:26:12     40s]    set p_bg [$p cget -bg] ;# get parent's background so we can match it
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Figure out the widget handle to create so it will be unique
[05/04 17:26:12     40s]    set i 1
[05/04 17:26:12     40s]    while 1 {
[05/04 17:26:12     40s]       if ![winfo exists $p.frameLABEL__$i] { break }
[05/04 17:26:12     40s]       incr i
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    # A pady of "1" is VERY important because it prevents labeled frames
[05/04 17:26:12     40s]    # in TK4.2 from having the top pixel row of the label cropped.
[05/04 17:26:12     40s]    # We use extra spaces around the text to provide padding between
[05/04 17:26:12     40s]    # the text and the 3D exterior of the frame.
[05/04 17:26:12     40s]    set lbl [label "$p.frameLABEL__$i" -pady 1 -text " $text "]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    if {$bg == ""} { set bg $p_bg }
[05/04 17:26:12     40s]    if {$fg == ""} {
[05/04 17:26:12     40s]       # Check if there's a default stored in the options database
[05/04 17:26:12     40s]       set fg [option get $lbl frameLabelFG Color]
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    if {$fg != ""} { set fg "-fg $fg" }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Set the label's background and foreground colors
[05/04 17:26:12     40s]    eval $lbl conf -bg "$bg" "$fg"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]    # Check if label has one or two lines
[05/04 17:26:12     40s]    if {[llength [split $$text "\n"]] == 1} {
[05/04 17:26:12     40s]       set Y "-14"
[05/04 17:26:12     40s]    } else {
[05/04 17:26:12     40s]       set Y "-20"
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    if $center {
[05/04 17:26:12     40s]       place $lbl -in $f -relx .5 -y $Y -anc n
[05/04 17:26:12     40s]    } else {
[05/04 17:26:12     40s]       place $lbl -in $f -x 5 -y $Y
[05/04 17:26:12     40s]    }
[05/04 17:26:12     40s]    return $lbl
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::SetExportOptions {type run_time} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	append w .calibreExportOptionsDlg $type
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set txt $w.top.opts.txt
[05/04 17:26:12     40s] 	set mode_f $w.top.mode
[05/04 17:26:12     40s] 	set btns_f $w.top.btns
[05/04 17:26:12     40s] 	if {[winfo exists $w] == 0} {
[05/04 17:26:12     40s] 		toplevel $w
[05/04 17:26:12     40s] 		wm title $w "Calibre $type Export Options"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		# Set the dialog up so that its width and height are resizable
[05/04 17:26:12     40s] 		wm resizable $w 1 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		wm withdraw $w
[05/04 17:26:12     40s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetExportOptionsCancel $w $type"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		frame $w.top
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack [frame $w.top.sp1] -pady 2m -padx 2m
[05/04 17:26:12     40s]                 
[05/04 17:26:12     40s] 		pack [frame $w.top.opts -relief groove -bd 2] -pady 2m -expand yes -fill both -padx 2m -side top
[05/04 17:26:12     40s] 		set options_f $w.top.opts
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set cmd_name ""
[05/04 17:26:12     40s] 		switch $type {
[05/04 17:26:12     40s] 			"GDS"       { set cmd_name "streamOut" }
[05/04 17:26:12     40s] 			"DEF"       { set cmd_name "defOut" }	    ;# write_def
[05/04 17:26:12     40s] 			"Verilog"   { set cmd_name "saveNetlist" }  ;# write_netlist
[05/04 17:26:12     40s] 			default     { }
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		AddFrameLabel $options_f "Options for the \"$cmd_name\" command:" 0 
[05/04 17:26:12     40s] 		pack [text $options_f.txt -wrap word -height 5 -width 60] -side top -expand yes -fill both -padx 1m -pady 1.2m
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		bind $w <Escape> "mgc_enc::SetExportOptionsCancel $w $type"
[05/04 17:26:12     40s] 		bind $w <Return> "mgc_enc::SetExportOptionsOK $w $type $txt"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		frame $mode_f
[05/04 17:26:12     40s] 		checkbutton $mode_f.show_at_runtime -var mgc_enc::vars(showDlgRunTimeTmp$type) -text "Show dialog before export"
[05/04 17:26:12     40s] 		label $mode_f.label -pady 1 -text "File:"
[05/04 17:26:12     40s] 		entry $mode_f.entry -textvariable mgc_enc::vars(exportFileName) -state disabled
[05/04 17:26:12     40s] 		pack $mode_f -pady 0.5m -padx 2m -anchor s -fill x 
[05/04 17:26:12     40s] 		
[05/04 17:26:12     40s] 		frame $btns_f -relief raised -bd 1 
[05/04 17:26:12     40s] 		pack $btns_f -side bottom -fill x -anchor s
[05/04 17:26:12     40s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetExportOptionsOK $w $type $txt"
[05/04 17:26:12     40s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetExportOptionsCancel $w $type"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	
[05/04 17:26:12     40s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 		
[05/04 17:26:12     40s] 		focus $btns_f.ok
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $w.top -side top -fill both -expand yes
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		#uiprocs_PositionWindow $w . "center"
[05/04 17:26:12     40s] 		mgc_enc::PositionWindowOnRight $w
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(showDlgRunTimeTmp$type) $vars(showDlgRunTime$type)
[05/04 17:26:12     40s] 	if {$run_time} {
[05/04 17:26:12     40s] 		pack forget $mode_f.show_at_runtime
[05/04 17:26:12     40s] 		pack $mode_f.label -pady 1  -anchor w -side left
[05/04 17:26:12     40s] 		pack $mode_f.entry -anchor e -side right -expand yes -fill x
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		pack forget $mode_f.label 
[05/04 17:26:12     40s] 		pack forget $mode_f.entry 
[05/04 17:26:12     40s] 		pack $mode_f.show_at_runtime -pady 0.5 -expand yes -fill x -padx 2m
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	$txt delete 1.0 end
[05/04 17:26:12     40s] 	$txt insert end $vars(exportOptions$type)
[05/04 17:26:12     40s] 	set insert_line [$txt get "insert linestart" "insert lineend"]
[05/04 17:26:12     40s] 	if {[string equal "" $insert_line]} {
[05/04 17:26:12     40s] 	# If insert cursor is at the beginning of an empty line, move it to
[05/04 17:26:12     40s] 	# the end of the previous one.
[05/04 17:26:12     40s] 		set idx [$txt index "end - 1 char"]
[05/04 17:26:12     40s] 		set row_count [lindex [split $idx .] 0]
[05/04 17:26:12     40s] 		if {$row_count > 1} {
[05/04 17:26:12     40s] 			set insert_row [expr {$row_count - 1}]
[05/04 17:26:12     40s] 			$txt mark set insert $insert_row.end
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	wm transient $w .
[05/04 17:26:12     40s] 	wm deiconify $w
[05/04 17:26:12     40s] 	mgc_enc::WaitForUpdate
[05/04 17:26:12     40s] 	raise $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# wait for return value to be set after grabbing focus
[05/04 17:26:12     40s] 	grab set $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	tkwait variable mgc_enc::vars(exportDlgStatus)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	grab release $w   ;# Make sure we let go of grab
[05/04 17:26:12     40s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $mgc_enc::vars(exportDlgStatus)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupRVE {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	append w .calibreSetupRVE
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set btns_f $w.top.btns
[05/04 17:26:12     40s] 	if {[winfo exists $w] == 0} {
[05/04 17:26:12     40s] 		toplevel $w
[05/04 17:26:12     40s] 		wm title $w "Calibre Setup RVE Highlight Layers"
[05/04 17:26:12     40s] 		# Set the dialog up so that its width and height are resizable
[05/04 17:26:12     40s] 		wm resizable $w 1 1
[05/04 17:26:12     40s] 		wm withdraw $w
[05/04 17:26:12     40s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetupRVECancel $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		frame $w.top
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		bind $w <Escape> "mgc_enc::SetupRVECancel $w"
[05/04 17:26:12     40s] 		bind $w <Return> "mgc_enc::SetupRVEOK $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set options_f [frame $w.top.opts -relief groove -bd 2]
[05/04 17:26:12     40s] 		set pref_f [frame $options_f.pref_f]
[05/04 17:26:12     40s] 		label $pref_f.title_0 -pady 1 -text "Layer" -anchor w
[05/04 17:26:12     40s] 		label $pref_f.title_1 -pady 1 -text "Color" -anchor center
[05/04 17:26:12     40s] 		label $pref_f.title_2 -pady 1 -text "Stipple" -width 7 -anchor center
[05/04 17:26:12     40s] 		label $pref_f.title_3 -pady 1 -text "Selectable" -anchor center
[05/04 17:26:12     40s] 		label $pref_f.title_4 -pady 1 -text "Width" -width 3 -anchor center
[05/04 17:26:12     40s] 		grid $pref_f.title_0 $pref_f.title_1 $pref_f.title_2 $pref_f.title_3 $pref_f.title_4 -sticky nsew
[05/04 17:26:12     40s] 		grid columnconfigure $pref_f 0 -weight 1
[05/04 17:26:12     40s] 		set bg [$w cget -background]
[05/04 17:26:12     40s] 		for {set i 0} {$i<16} {incr i} {
[05/04 17:26:12     40s] 			label $pref_f.label_$i -text "rve_$i" -anchor w
[05/04 17:26:12     40s] 			frame $pref_f.color_$i -width 24p -height 24p -borderwidth 0
[05/04 17:26:12     40s] 			set c [canvas $pref_f.color_$i.c -height 24 -width 24 -borderwidth 0]
[05/04 17:26:12     40s] 			pack $c -fill none -expand 0
[05/04 17:26:12     40s] 			menubutton $pref_f.pattern_$i -menu $pref_f.pattern_$i.menu -width 7 -relief raised -bd 2 -anchor center -indicatoron 1 -textvariable mgc_enc::vars(rve_${i}_pattern)
[05/04 17:26:12     40s] 			checkbutton $pref_f.selectable_$i -anchor center -variable mgc_enc::vars(rve_${i}_selectable)
[05/04 17:26:12     40s] 			spinbox $pref_f.width_$i -state readonly -readonlybackground $bg -width 3 -from 1 -to 20 -increment 1 -bd 1 -textvariable mgc_enc::vars(rve_${i}_width)
[05/04 17:26:12     40s] 			grid $pref_f.label_$i $pref_f.color_$i $pref_f.pattern_$i $pref_f.selectable_$i $pref_f.width_$i -sticky nsew
[05/04 17:26:12     40s] 			set m [menu $pref_f.pattern_$i.menu]
[05/04 17:26:12     40s] 			foreach item $vars(rve_supported_patterns) {
[05/04 17:26:12     40s] 				$m add radiobutton -label $item -var mgc_enc::vars(rve_${i}_pattern) -value $item
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 			bind $c <Button-1> "mgc_enc::rve_choose_color $i" 
[05/04 17:26:12     40s] 			trace variable mgc_enc::vars(rve_${i}_color)   w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/04 17:26:12     40s] 			trace variable mgc_enc::vars(rve_${i}_pattern) w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/04 17:26:12     40s] 			trace variable mgc_enc::vars(rve_${i}_width)   w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/04 17:26:12     40s] 			set vars(rve_${i}_color) $vars(rve_${i}_color)
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $pref_f -pady 1m -padx 2m -anchor s -fill x 
[05/04 17:26:12     40s] 		pack $options_f -pady 2m -expand yes -fill both -padx 2m -side top
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		frame $btns_f -relief raised -bd 1 
[05/04 17:26:12     40s] 		pack $btns_f -side bottom -fill x -anchor s
[05/04 17:26:12     40s] 		button $btns_f.save -width 7 -text "Save..." -command "mgc_enc::SaveRVELayerPreference $w"
[05/04 17:26:12     40s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetupRVEOK $w"
[05/04 17:26:12     40s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetupRVECancel $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $btns_f.save -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		focus $btns_f.ok
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $w.top -side top -fill both -expand yes
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		#uiprocs_PositionWindow $w . "center"
[05/04 17:26:12     40s] 		mgc_enc::PositionWindowOnRight $w
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	for {set i 0} {$i<16} {incr i} {
[05/04 17:26:12     40s] 		if { ![catch {getLayerPreference rve_$i -color} color] } {
[05/04 17:26:12     40s] 			set vars(rve_${i}_color) $color
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		if { ![catch {getLayerPreference rve_$i -stipple} stipple] } {
[05/04 17:26:12     40s] 			set bOther 1
[05/04 17:26:12     40s] 			foreach item $vars(rve_supported_patterns) {
[05/04 17:26:12     40s] 				if { [string equal -nocase $item $stipple] || $stipple=="" } { 
[05/04 17:26:12     40s] 					set vars(rve_${i}_pattern) $item
[05/04 17:26:12     40s] 					set bOther 0
[05/04 17:26:12     40s] 					break
[05/04 17:26:12     40s] 				}
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 			if { $bOther } { set vars(rve_${i}_pattern) Other }
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		if { ![catch {getLayerPreference rve_$i -isSelectable} isSelectable] } {
[05/04 17:26:12     40s] 			if { [string is boolean -strict $isSelectable] } {
[05/04 17:26:12     40s] 				set vars(rve_${i}_selectable) $isSelectable
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		if { ![catch {getLayerPreference rve_$i -lineWidth} lineWidth] } {
[05/04 17:26:12     40s] 			if { [string is integer -strict $lineWidth] } {
[05/04 17:26:12     40s] 				set vars(rve_${i}_width) $lineWidth
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	wm transient $w .
[05/04 17:26:12     40s] 	wm deiconify $w
[05/04 17:26:12     40s] 	mgc_enc::WaitForUpdate
[05/04 17:26:12     40s] 	raise $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# wait for return value to be set after grabbing focus
[05/04 17:26:12     40s] 	grab set $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	tkwait variable mgc_enc::vars(setupRVEStatus)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	grab release $w   ;# Make sure we let go of grab
[05/04 17:26:12     40s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $mgc_enc::vars(setupRVEStatus)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::setupSocket {} {
[05/04 17:26:12     40s] 	variable vars
[05/04 17:26:12     40s] 	append w .calibreSetupSocket
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set btns_f $w.top.btns
[05/04 17:26:12     40s] 	if {[winfo exists $w] == 0} {
[05/04 17:26:12     40s] 		toplevel $w
[05/04 17:26:12     40s] 		wm title $w "Calibre Setup Socket"
[05/04 17:26:12     40s] 		# Set the dialog up so that its width and height are resizable
[05/04 17:26:12     40s] 		wm resizable $w 1 1
[05/04 17:26:12     40s] 		wm withdraw $w
[05/04 17:26:12     40s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetupSocketCancel $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		frame $w.top
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		bind $w <Escape> "mgc_enc::SetupSocketCancel $w"
[05/04 17:26:12     40s] 		bind $w <Return> "mgc_enc::SetupSocketOK $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		set options_f [frame $w.top.opts -relief groove -bd 2]
[05/04 17:26:12     40s] 		set socket_f [frame $options_f.socket_f]
[05/04 17:26:12     40s] 		set host_f   [frame $options_f.host_f]
[05/04 17:26:12     40s] 		pack [label $socket_f.label -pady 1 -text "Socket Number (-1 for auto):" -width 27 -anchor w] -side left
[05/04 17:26:12     40s] 		pack [entry $socket_f.entry -textvariable mgc_enc::vars(tmp_socket_number) -validate key -validatecommand "mgc_integer_only %P"] -side left -fill x -expand 1
[05/04 17:26:12     40s] 		pack [label $host_f.label -pady 1 -text "Host Name (empty for localhost):" -width 27 -anchor w] -side left
[05/04 17:26:12     40s] 		pack [entry $host_f.entry -textvariable mgc_enc::vars(tmp_socket_host) -validate key -validatecommand "mgc_no_white_spaces %P"] -side left -fill x -expand 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $socket_f -pady 0.5m -padx 2m -anchor s -fill x 
[05/04 17:26:12     40s] 		pack $host_f   -pady 0.5m -padx 2m -anchor s -fill x 
[05/04 17:26:12     40s] 		pack $options_f -pady 2m -expand yes -fill both -padx 2m -side top
[05/04 17:26:12     40s]  
[05/04 17:26:12     40s] 		frame $btns_f -relief raised -bd 1 
[05/04 17:26:12     40s] 		pack $btns_f -side bottom -fill x -anchor s
[05/04 17:26:12     40s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetupSocketOK $w"
[05/04 17:26:12     40s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetupSocketCancel $w"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		focus $btns_f.ok
[05/04 17:26:12     40s] 		pack $w.top -side top -fill both -expand yes
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		#uiprocs_PositionWindow $w . "center"
[05/04 17:26:12     40s] 		mgc_enc::PositionWindowOnRight $w
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set vars(tmp_socket_number) $vars(socket_number)
[05/04 17:26:12     40s] 	set vars(tmp_socket_host) $vars(socket_host)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	wm transient $w .
[05/04 17:26:12     40s] 	wm deiconify $w
[05/04 17:26:12     40s] 	mgc_enc::WaitForUpdate
[05/04 17:26:12     40s] 	raise $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# wait for return value to be set after grabbing focus
[05/04 17:26:12     40s] 	grab set $w
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	tkwait variable mgc_enc::vars(setupSocketStatus)
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	grab release $w   ;# Make sure we let go of grab
[05/04 17:26:12     40s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	return $mgc_enc::vars(setupSocketStatus)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::clearHighlights {} {
[05/04 17:26:12     40s] 	mgc_rve_delete_markers "" 1
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getVersion {} {
[05/04 17:26:12     40s] 	if { [info commands eval_legacy] == "eval_legacy" } {
[05/04 17:26:12     40s] 		set version [::get_db program_version]
[05/04 17:26:12     40s] 	} else {
[05/04 17:26:12     40s] 		set version [::getVersion] ;# 15.13-s048_1
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	return $version
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::versionIsPre9 {} {
[05/04 17:26:12     40s]     set version [getVersion]
[05/04 17:26:12     40s]     regsub {\..*$} $version {} majVersion
[05/04 17:26:12     40s]     if {[string match "0*" $majVersion]} {
[05/04 17:26:12     40s]         set majVersion [string range $majVersion 1 end]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {$majVersion < 9} {
[05/04 17:26:12     40s]         return 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return 0
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::PositionWindowOnRight {w} {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {[mgc_enc::versionIsPre9]} {
[05/04 17:26:12     40s]         uiprocs_PositionWindow $w . "center"
[05/04 17:26:12     40s]     } else {
[05/04 17:26:12     40s] 	    global _ui_vars
[05/04 17:26:12     40s] 	    set geom [guiGet main -geometry]
[05/04 17:26:12     40s] 	    scan $geom "%dx%d+%d+%d" width height p_x p_y
[05/04 17:26:12     40s] 	    set x [expr $width+$p_x]
[05/04 17:26:12     40s] 	    set y $p_y
[05/04 17:26:12     40s] 	    wm withdraw $w
[05/04 17:26:12     40s] 	    mgc_enc::WaitForUpdate
[05/04 17:26:12     40s] 	    wm geometry $w +$x+$y
[05/04 17:26:12     40s] 	    if {$_ui_vars(IsPC)} {
[05/04 17:26:12     40s] 		    mgc_enc::WaitForUpdate      ;# required on pc to get positioning to occur
[05/04 17:26:12     40s] 	    }
[05/04 17:26:12     40s] 	    wm deiconify $w
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # Default layer preferences for RVE highlight
[05/04 17:26:12     40s] @proc mgc_enc::loadDefaultRVELayerPreference {} {
[05/04 17:26:12     40s] 	setLayerPreference rve_0  -color green      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_1  -color darkblue   -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_2  -color slateblue  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_3  -color turquoise  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_4  -color lightgray  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_5  -color wheat      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_6  -color goldenrod  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_7  -color yellow     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_8  -color sandybrown -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_9  -color coral      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_10 -color red        -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_11 -color tomato     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_12 -color firebrick  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_13 -color purple     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_14 -color violet     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] 	setLayerPreference rve_15 -color tan        -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # Here starts several procs to support user customization of the Calibre menu.
[05/04 17:26:12     40s] @proc mgc_enc::setMenuCmds {menu_cmds} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set vars(menuCmds) $menu_cmds
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getMenuCmds {} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     return $vars(menuCmds)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getAllCalibreMenuCmds {} {
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set ret_list [list]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     foreach m $vars(menuCmds) {
[05/04 17:26:12     40s]         if {[lindex $m 0] eq "command"} {
[05/04 17:26:12     40s]             set label [lindex $m 1]
[05/04 17:26:12     40s]             if {$label ne ""} {
[05/04 17:26:12     40s]                 append label "/"
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             append label [lindex $m 2]
[05/04 17:26:12     40s]             set cmd [lindex $m 6]
[05/04 17:26:12     40s]             lappend ret_list [list $label $cmd]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return $ret_list
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::applyCustomMenu {commonMenuFile encMenuFile} {
[05/04 17:26:12     40s]     global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set tclsh [file join $env(MGC_HOME) bin tclsh]
[05/04 17:26:12     40s]     set custom_parser [file join $env(MGC_HOME) shared pkgs icv tools custom custom_menu.tcl]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set outPath [file join [getTempDir] encInp.[pid].customMenu]
[05/04 17:26:12     40s]     set readOK 1
[05/04 17:26:12     40s]     if {[catch {exec $tclsh $custom_parser -common_file $commonMenuFile -viewer_file $encMenuFile -output_file $outPath} msg]} {
[05/04 17:26:12     40s]         regsub {child process exited abnormally} $msg {} msg
[05/04 17:26:12     40s]         puts "\n$msg"
[05/04 17:26:12     40s]         set readOK 0
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set first 1
[05/04 17:26:12     40s]     set menuCmds [list]
[05/04 17:26:12     40s]     set fp [open $outPath r]
[05/04 17:26:12     40s]     while {[gets $fp cmd]!=-1} {
[05/04 17:26:12     40s]         if {$first} {
[05/04 17:26:12     40s]         # Ignore header line.
[05/04 17:26:12     40s]             set first 0
[05/04 17:26:12     40s]             continue
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         set splist [split $cmd ","]
[05/04 17:26:12     40s]         lappend menuCmds $splist
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     close $fp
[05/04 17:26:12     40s]     file delete -force $outPath
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$readOK && [info exists env(MGC_CALIBRE_VIEWER_MENU_CMDS)]} {
[05/04 17:26:12     40s]         puts "Successfully read Calibre menu customization file \"$env(MGC_CALIBRE_VIEWER_MENU_CMDS)\""
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     return $menuCmds
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::runUserCmd {cmdIdx} {
[05/04 17:26:12     40s]     variable userCmds
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s]     global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {![info exists userCmds($cmdIdx)]} {
[05/04 17:26:12     40s]         return
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     foreach {label command commandType envVars code} $userCmds($cmdIdx) {break}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {[string match "::CalibreInterface::execCalibre*" $command] || [string match "::CalibreInterface::execNewCalibre*" $command] || $commandType eq "BI"} {
[05/04 17:26:12     40s]         # This is a builtin; call the function.
[05/04 17:26:12     40s]         return [eval $command]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set curr_cell_name ""
[05/04 17:26:12     40s]     if {$commandType ne "RVE" && $commandType ne "CUSTOM"} {
[05/04 17:26:12     40s]         if {[getTopCell]==0} {
[05/04 17:26:12     40s]             ShowError "No layout exists.\nPlease load a layout before attempting to run $commandType."
[05/04 17:26:12     40s]             return
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set curr_cell_name [getCellName [getTopCell]]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {$code ne ""} {
[05/04 17:26:12     40s]         if {[catch {eval $code} msg]} {
[05/04 17:26:12     40s]             ShowError "Problem executing code snippet specified with -code.
[05/04 17:26:12     40s]                 Error message:
[05/04 17:26:12     40s]                 $msg
[05/04 17:26:12     40s]                 "
[05/04 17:26:12     40s]             return
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if {[mgc_enc::CheckEnv] eq ""} {
[05/04 17:26:12     40s]         ShowError "Can't start RVE server"
[05/04 17:26:12     40s]         return
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # A custom command.
[05/04 17:26:12     40s]     set tool [string tolower $commandType]
[05/04 17:26:12     40s]     set do_trigger 0
[05/04 17:26:12     40s]     set doSetup 0
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # check if the process was already started (if MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL)
[05/04 17:26:12     40s]     set fid ""
[05/04 17:26:12     40s]     if { [info exists ::env(MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL)] &&
[05/04 17:26:12     40s]         $::env(MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL) ne "0" } {
[05/04 17:26:12     40s]         set fid [CheckGUI $curr_cell_name $tool $command]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     if {$fid eq ""} {
[05/04 17:26:12     40s]         # We need to start the process.
[05/04 17:26:12     40s]         # we will call rdrc_SetupDRC not rdrc_RunDRC (or lvs, etc..)
[05/04 17:26:12     40s]         set doSetup 1
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         # Write a script to setup the environment
[05/04 17:26:12     40s]         set scriptPath [file join [getTempDir] encounterScript.[pid].$commandType]
[05/04 17:26:12     40s]         if {[catch {set wf [open $scriptPath w]} msg]} {
[05/04 17:26:12     40s]             ShowError "Cannot create temporary file $scriptPath.
[05/04 17:26:12     40s] Error message:
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] $msg
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] "
[05/04 17:26:12     40s]             return
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         puts $wf "#!/bin/sh"
[05/04 17:26:12     40s]         foreach envpair $envVars {
[05/04 17:26:12     40s]             if {[string match "=*" $envpair]} {
[05/04 17:26:12     40s]             # We want to unset the envar.
[05/04 17:26:12     40s]                 regsub {=} $envpair {} envarname
[05/04 17:26:12     40s]                 puts $wf "unset $envarname"
[05/04 17:26:12     40s]             } else {
[05/04 17:26:12     40s]             # We want to set the envar.
[05/04 17:26:12     40s]                 regsub {=.*} $envpair {} exportvar
[05/04 17:26:12     40s]                 puts $wf $envpair
[05/04 17:26:12     40s]                 puts $wf "export $exportvar"
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         puts $wf ""
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         # Standard socket server stuff.
[05/04 17:26:12     40s]         puts $wf "MGC_CGI_MONITOR_STDIN=1"
[05/04 17:26:12     40s]         puts $wf "export MGC_CGI_MONITOR_STDIN"
[05/04 17:26:12     40s]         puts $wf "MGC_CALIBRE_LAYOUT_SERVER_NAME=Cadence:Encounter"
[05/04 17:26:12     40s]         puts $wf "export MGC_CALIBRE_LAYOUT_SERVER_NAME"
[05/04 17:26:12     40s]         set sockNum [GetDefaultSocket]
[05/04 17:26:12     40s]         foreach {host port} $sockNum {break}
[05/04 17:26:12     40s]         puts $wf "MGC_CALIBRE_LAYOUT_SERVER=$host:$port"
[05/04 17:26:12     40s]         puts $wf "export MGC_CALIBRE_LAYOUT_SERVER"
[05/04 17:26:12     40s]         puts $wf "MGC_RVE_HILIGHT_SHORT_TEXT_CMDS=1"
[05/04 17:26:12     40s]         puts $wf "export MGC_RVE_HILIGHT_SHORT_TEXT_CMDS"
[05/04 17:26:12     40s]         puts $wf ""
[05/04 17:26:12     40s]         puts $wf $command
[05/04 17:26:12     40s]         if {![info exists env(MGC_CALIBRE_ECHO_VIEWER_MENU_CMDS)]} {
[05/04 17:26:12     40s]             puts $wf "rm $scriptPath"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         close $wf
[05/04 17:26:12     40s]         file attributes $scriptPath -permissions 0777
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if {$commandType ne "RVE" && $commandType ne "CUSTOM"} {
[05/04 17:26:12     40s]             if {[namespace eval "::" {info procs "mgc_start_calibre_trigger"}] ne ""} {
[05/04 17:26:12     40s]                 set do_trigger 1
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         if {$do_trigger} {
[05/04 17:26:12     40s]             mgc_start_calibre_trigger $tool $curr_cell_name
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if {[catch {set fid [open "| $scriptPath 2>@ stdout" "r+"]} cmsg]==0} {
[05/04 17:26:12     40s]             fconfigure $fid -blocking 0 -buffering line
[05/04 17:26:12     40s]             if {$commandType eq "RVE"} {
[05/04 17:26:12     40s]                 fileevent $fid readable [list mgc_enc::ReadRVE $fid]
[05/04 17:26:12     40s]                 lappend vars(rve_fids) $fid
[05/04 17:26:12     40s]             } elseif {$commandType ne "CUSTOM"} {
[05/04 17:26:12     40s]                 fileevent $fid readable [list mgc_enc::ReadGUI $fid $curr_cell_name $tool $command]
[05/04 17:26:12     40s]                 # See CheckGUI. Need to remember the fid by tool, command, and cell for a custom command
[05/04 17:26:12     40s]                 set vars(${tool},${command},${curr_cell_name}) $fid
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if {[info exists env(MGC_CALIBRE_ECHO_VIEWER_MENU_CMDS)]} {
[05/04 17:26:12     40s]             puts "Starting verification menu user command $scriptPath"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     # Now the process was either already started, or just started.  For CI we need to send
[05/04 17:26:12     40s]     # either rdrc_SetupDRC or rdrc_RunDRC (or lvs, etc..). The rdrc_RunDRC cmd will also pop the CI window
[05/04 17:26:12     40s]     if {$fid ne ""} {
[05/04 17:26:12     40s]         if {$commandType ne "CUSTOM"} {
[05/04 17:26:12     40s]             #set alib [get_attribute $lib_obj full_name]
[05/04 17:26:12     40s]             #set aview [get_attribute $lib_obj view_name]
[05/04 17:26:12     40s]             if {$doSetup} {
[05/04 17:26:12     40s]                 set rcmd r${tool}_Setup$commandType
[05/04 17:26:12     40s]             } else {
[05/04 17:26:12     40s]                 set rcmd r${tool}_Run$commandType
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             puts $fid "$rcmd $curr_cell_name"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::getUserCmds {} {
[05/04 17:26:12     40s]     variable userCmds
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set ret_list [list]
[05/04 17:26:12     40s]     foreach key [lsort -dict [array names userCmds]] {
[05/04 17:26:12     40s]         regsub -all {&} $userCmds($key) {} value
[05/04 17:26:12     40s]         lappend ret_list "$key $value"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return $ret_list
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::createUserMenuCommand {cmd label commandType command envVars code} {
[05/04 17:26:12     40s]     variable userCmds
[05/04 17:26:12     40s]     variable vars
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set idx $vars(userCmdIdx)
[05/04 17:26:12     40s]     incr vars(userCmdIdx)
[05/04 17:26:12     40s]     set userCmds($idx) [list $label $command $commandType $envVars $code]
[05/04 17:26:12     40s]     lappend cmd -command [list mgc_enc::runUserCmd $idx]
[05/04 17:26:12     40s]     eval $cmd
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc getTempDir {} {
[05/04 17:26:12     40s]     set tempDir ""
[05/04 17:26:12     40s]     if { [info exists ::env(MGC_TMPDIR)] && [file isdirectory $::env(MGC_TMPDIR)] && [file writable $::env(MGC_TMPDIR)] } {
[05/04 17:26:12     40s]         set tempDir $::env(MGC_TMPDIR)
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if { $tempDir eq "" && [info exists ::env(MGC_HOME)] && [file exists $::env(MGC_HOME)] } {
[05/04 17:26:12     40s]         set path [file join $::env(MGC_HOME) tmp]
[05/04 17:26:12     40s]         if { [file isdirectory $path] && [file writable $path] } {
[05/04 17:26:12     40s]             set tempDir $path
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if { $tempDir eq "" && [file exists "/usr/tmp"] && [file writable "/usr/tmp"]} {
[05/04 17:26:12     40s]         set tempDir "/usr/tmp"
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if { $tempDir eq "" && [info exists ::env(HOME)] } {
[05/04 17:26:12     40s]         if { [file exists $::env(HOME)] && [file writable $::env(HOME)] } {
[05/04 17:26:12     40s]             set tempDir $::env(HOME)
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     if { $tempDir eq "" && [file writable "."] } {
[05/04 17:26:12     40s]         set tempDir "."
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s]     return $tempDir
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # End customization support code.
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] #===============================================================================
[05/04 17:26:12     40s] # Innovus Legacy and Common UI mode APIs
[05/04 17:26:12     40s] #===============================================================================
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @if { [mgc_enc_is_common_ui_mode] } {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# Innovus Common UI mode APIs: is_common_ui_mode
[05/04 17:26:12     40s] 	proc mgc_enc::is_common_ui_mode {} { return 1 }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	interp alias {} mgc_enc::getAllLayers {} ::get_all_layers
[05/04 17:26:12     40s] 	interp alias {} mgc_env::streamOut    {} ::write_stream
[05/04 17:26:12     40s] 	interp alias {} mgc_enc::redraw       {} ::gui_redraw
[05/04 17:26:12     40s] 	interp alias {} mgc_enc::fit          {} ::gui_fit
[05/04 17:26:12     40s] 	interp alias {} mgc_enc::zoomBox      {} ::zoom_box
[05/04 17:26:12     40s] 	interp alias {} mgc_enc::zoomOut      {} ::zoom_out
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# DR1368504: zoom_box command no longer available in Innovus 18.10
[05/04 17:26:12     40s] 	if { [info commands gui_zoom]=="gui_zoom" } {
[05/04 17:26:12     40s] 		proc mgc_enc::zoomBox {args} {
[05/04 17:26:12     40s] 			gui_zoom -rect $args
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		proc mgc_enc::zoomIn {} {
[05/04 17:26:12     40s] 			gui_zoom -in
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		proc mgc_enc::zoomOut {} {
[05/04 17:26:12     40s] 			gui_zoom -out
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiFind {args} {
[05/04 17:26:12     40s] 		return [eval gui_find_ui $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiAdd {args} {
[05/04 17:26:12     40s] 		return [eval gui_add_ui $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGet {args} {
[05/04 17:26:12     40s] 		return [eval gui_get_ui $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiSet {args} {
[05/04 17:26:12     40s] 		return [eval gui_set_ui $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiViewBox {} {
[05/04 17:26:12     40s] 		return [gui_view_box]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetBox {} {
[05/04 17:26:12     40s] 		return [gui_get_box]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetPoly {} {
[05/04 17:26:12     40s] 		return [gui_get_coords]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetCoord {} {
[05/04 17:26:12     40s] 		return [gui_get_coord]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getLayerByName {layerName} {
[05/04 17:26:12     40s] 		# realtime/innovus-common-ui/cto_file_layer_visibility
[05/04 17:26:12     40s] 		# with edi_tcl_flow_half_adder in CUI mode:
[05/04 17:26:12     40s] 		#    OK: eval_legacy "dbGetLayerByName M0" => 0x7faf0f2ce800
[05/04 17:26:12     40s] 		#   NOK: get_db layers -if { .name=="M0" } => ""
[05/04 17:26:12     40s] 		# see also ::calibre::realtime::getLayerByName
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		return [eval_legacy "dbGetLayerByName $layerName"]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 		if { 0 } {
[05/04 17:26:12     40s] 			set layers [get_all_layers metal]
[05/04 17:26:12     40s] 			set layer [get_db layers -if { .name==$layerName }]
[05/04 17:26:12     40s] 			if { $layer=="" } {
[05/04 17:26:12     40s] 				set layer 0
[05/04 17:26:12     40s] 			}
[05/04 17:26:12     40s] 			return $layer
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getTopCell {} {
[05/04 17:26:12     40s] 		set design [get_db current_design]
[05/04 17:26:12     40s] 		if { $design=="" } {
[05/04 17:26:12     40s] 			set design 0
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return $design
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getCellName {cell} {
[05/04 17:26:12     40s] 		return [get_db $cell .name]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	#-------------------------------------------------------------------------------
[05/04 17:26:12     40s] 	# getLayerPreference/setLayerPreference
[05/04 17:26:12     40s] 	#-------------------------------------------------------------------------------
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::mapLegacyArgs {map legacyArgs} {
[05/04 17:26:12     40s] 		set newArgs [list]
[05/04 17:26:12     40s] 		foreach arg $legacyArgs {
[05/04 17:26:12     40s] 			lappend newArgs [string map $map $arg]
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return $newArgs
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::mapLegacyLayerPreferenceArgs {legacyArgs} {
[05/04 17:26:12     40s] 		set map {-isVisible -is_visible -isSelectable -is_selectable -lineWidth -line_width -stippleData -stipple_data}
[05/04 17:26:12     40s] 		set newArgs [mapLegacyArgs $map $legacyArgs]
[05/04 17:26:12     40s] 		return $newArgs
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getLayerPreference {args} {
[05/04 17:26:12     40s] 		set cmd "get_layer_preference [mapLegacyLayerPreferenceArgs $args]"
[05/04 17:26:12     40s] 		return [eval $cmd]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::setLayerPreference {args} {
[05/04 17:26:12     40s] 		set cmd "set_layer_preference [mapLegacyLayerPreferenceArgs $args]"
[05/04 17:26:12     40s] 		return [eval $cmd]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiRect {layer x1 y1 x2 y2} {
[05/04 17:26:12     40s] 		return [create_gui_shape -layer $layer -rect [list $x1 $y1 $x2 $y2]]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiLine {layer args} {
[05/04 17:26:12     40s] 		return [create_gui_shape -layer $layer -line $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiPoly {layer args} {
[05/04 17:26:12     40s] 		return [create_gui_shape -layer $layer -polygon $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiText {layer txt x y size} {
[05/04 17:26:12     40s] 		return [create_gui_text -layer $layer -label $txt -pt [list $x $y] -height $size]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::deleteGuiObj {obj} {
[05/04 17:26:12     40s] 		set selected [get_db selected]
[05/04 17:26:12     40s] 		deselect_obj -all
[05/04 17:26:12     40s] 		select_obj $obj
[05/04 17:26:12     40s] 		gui_delete_object -selected
[05/04 17:26:12     40s] 		select_obj $selected
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::deleteCustomLayer {layer} {
[05/04 17:26:12     40s] 		eval_legacy "::deleteCustomLayer $layer"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportCmd {fileName args} {
[05/04 17:26:12     40s] 		set map { \
[05/04 17:26:12     40s] 			-attachInstanceName  -attach_inst_name     \
[05/04 17:26:12     40s] 			-attachNetName       -attach_net_name      \
[05/04 17:26:12     40s] 			-attachNetProp       -attach_net_attribute \
[05/04 17:26:12     40s] 			-dieAreaAsBoundary   -die_area_as_boundary \
[05/04 17:26:12     40s] 			-libName             -lib_name             \
[05/04 17:26:12     40s] 			-mapFile             -map_file             \
[05/04 17:26:12     40s] 			-noStructureName     -no_structure_name    \
[05/04 17:26:12     40s] 			-outputMacros        -output_macros        \
[05/04 17:26:12     40s] 			-reportFile          -report_file          \
[05/04 17:26:12     40s] 			-structureName       -structure_name       \
[05/04 17:26:12     40s] 			-uniquifyCellNames   -uniquify_cell_names  \
[05/04 17:26:12     40s] 			-units               -unit                 \
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return "write_stream $fileName [join [mapLegacyArgs $map $args]]"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportDefCmd {fileName args} {
[05/04 17:26:12     40s] 	# common ui: write_def
[05/04 17:26:12     40s] 	# legacy: defOut
[05/04 17:26:12     40s] 		set map { \
[05/04 17:26:12     40s] 			-addHalfWireExtensionOnPin  -add_half_wire_extension_on_pin     \
[05/04 17:26:12     40s] 			-allLayers            -all_layers          \
[05/04 17:26:12     40s] 			-bumpAsPin            -bump_as_pin         \
[05/04 17:26:12     40s] 			-cutRow               -cut_row             \
[05/04 17:26:12     40s] 			-earlyGlobalRoute     -early_global_route  \
[05/04 17:26:12     40s] 			-ioRow                -io_row              \
[05/04 17:26:12     40s] 			-noCoreCells          -no_core_cells       \
[05/04 17:26:12     40s] 			-noSpecialNet         -no_special_net      \
[05/04 17:26:12     40s] 			-noStdCells           -no_std_cells        \
[05/04 17:26:12     40s] 			-noTracks             -no_tracks           \
[05/04 17:26:12     40s] 			-outputMaskLayers     -output_mask_Layers  \
[05/04 17:26:12     40s] 			-scanChain            -scan_chain          \
[05/04 17:26:12     40s] 			-usedVia              -used_via            \
[05/04 17:26:12     40s] 			-withShield           -with_shield         \
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return "write_def $fileName [join [mapLegacyArgs $map $args]]"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportVerilogCmd {fileName args} {
[05/04 17:26:12     40s] 	# common ui: write_netlist
[05/04 17:26:12     40s] 	# legacy: saveNetlist
[05/04 17:26:12     40s] 		set map { \
[05/04 17:26:12     40s] 			-excludeCellInst      -exclude_insts_of_cells \
[05/04 17:26:12     40s] 			-excludeLeafCell      -exclude_leaf_cells     \
[05/04 17:26:12     40s] 			-excludeTopCellPGPort -exclude_top_pg_ports   \
[05/04 17:26:12     40s] 			-flattenBus           -flatten_bus            \
[05/04 17:26:12     40s] 			-includeBumpCell      -include_bump_cells     \
[05/04 17:26:12     40s] 			-includePhysicalCell  -include_phys_cells     \
[05/04 17:26:12     40s] 			-includePhysicalInst  -include_phys_insts     \
[05/04 17:26:12     40s] 			-includePowerGround   -include_pg_ports       \
[05/04 17:26:12     40s] 			-keepAllBackslash     -keep_all_backslash     \
[05/04 17:26:12     40s] 			-lineLength           -line_length            \
[05/04 17:26:12     40s] 			-omitFloatingPort     -omit_floating_ports    \
[05/04 17:26:12     40s] 			-onlyLeafCell         -only_leaf_cells        \
[05/04 17:26:12     40s] 			-onlyMacro            -only_blocks            \
[05/04 17:26:12     40s] 			-onlyStdCell          -only_std_cells         \
[05/04 17:26:12     40s] 			-replaceTieConnection -update_tie_connections \
[05/04 17:26:12     40s] 			-topCell              -top_module             \
[05/04 17:26:12     40s] 			-topModuleFirst       -top_module_first       \
[05/04 17:26:12     40s] 			-usePGPorts           -use_pg_ports           \
[05/04 17:26:12     40s] 		}
[05/04 17:26:12     40s] 		return "write_netlist $fileName [join [mapLegacyArgs $map $args]]"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] } else {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	# Innovus legacy mode APIs
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::is_common_ui_mode {} { return 0 }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiFind {args} {
[05/04 17:26:12     40s] 		return [eval uiFind $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiAdd {args} {
[05/04 17:26:12     40s] 		return [eval uiAdd $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGet {args} {
[05/04 17:26:12     40s] 		return [eval uiGet $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiSet {args} {
[05/04 17:26:12     40s] 		return [eval uiSet $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiViewBox {} {
[05/04 17:26:12     40s] 		return [ui_view_box]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetBox {} {
[05/04 17:26:12     40s] 		return [uiGetBox]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetPoly {} {
[05/04 17:26:12     40s] 		return [uiGetCoords]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::guiGetCoord {} {
[05/04 17:26:12     40s] 		return [uiGetCoord]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getLayerByName {layerName} {
[05/04 17:26:12     40s] 		return [dbGetLayerByName $layerName]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getTopCell {} {
[05/04 17:26:12     40s] 		return [dbgTopCell]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getCellName {cell} {
[05/04 17:26:12     40s] 		return [dbCellName $cell]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiRect {layer x1 y1 x2 y2} {
[05/04 17:26:12     40s] 		return [addCustomBox $layer $x1 $y1 $x2 $y2]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiLine {layer x1 y1 x2 y2} {
[05/04 17:26:12     40s] 		return [addCustomLine $layer $x1 $y1 $x2 $y2]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiPoly {layer args} {
[05/04 17:26:12     40s] 		return [eval addCustomLine $layer $args]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::createGuiText {layer txt x y size} {
[05/04 17:26:12     40s] 		return [addCustomText $layer $txt $x $y $size]
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::deleteGuiObj {obj} {
[05/04 17:26:12     40s] 		dbDeleteObj $obj
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::deleteCustomLayer {layer} {
[05/04 17:26:12     40s] 		::deleteCustomLayer $layer
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportCmd {fileName args} {
[05/04 17:26:12     40s] 		return "streamOut $fileName [join $args]"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportDefCmd {fileName args} {
[05/04 17:26:12     40s] 		return "defOut [join $args] $fileName"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	proc mgc_enc::getExportVerilogCmd {fileName args} {
[05/04 17:26:12     40s] 		return "saveNetlist $fileName [join $args]"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # Based on Encounter documentation: The initialization files are read in the following sequence:
[05/04 17:26:12     40s] # 1. .encrc in the home directory
[05/04 17:26:12     40s] # 2. .encrc in the working directory
[05/04 17:26:12     40s] # 3. enc.pref.tcl in the working directory
[05/04 17:26:12     40s] # 4. .enc in the home directory
[05/04 17:26:12     40s] # 5. enc.tcl in the installation/etc directory
[05/04 17:26:12     40s] # 6. enc.tcl in the home directory
[05/04 17:26:12     40s] # 7. enc.tcl in the working directory
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @catch { mgc_enc::initRveHighlightPatterns }
[05/04 17:26:12     40s] @catch { mgc_enc::loadDefaultRVELayerPreference }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ################################################################################
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @if {[info exists env(MGC_RVE_INIT_SOCKET_AT_STARTUP)]} {
[05/04 17:26:12     40s] 	mgc_enc::initServerSocket
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @proc mgc_enc::show_banner {} {
[05/04 17:26:12     40s] 	global env
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/04 17:26:12     40s] 		ShowError "MGC_HOME environment variable is not set!"
[05/04 17:26:12     40s] 		return
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 	set version ""
[05/04 17:26:12     40s] 	set vfile [file join $env(MGC_HOME) pkgs icv dependencies version]
[05/04 17:26:12     40s] 	if {[file exists $vfile] && [file readable $vfile]} {
[05/04 17:26:12     40s] 		set f [open $vfile r]
[05/04 17:26:12     40s] 		set version [gets $f]
[05/04 17:26:12     40s] 		close $f
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] 	puts "//"
[05/04 17:26:12     40s] 	puts "//  Calibre Encounter/Innovus Interface * ($version) *"
[05/04 17:26:12     40s] 	puts "//"
[05/04 17:26:12     40s] 	puts "//                           Copyright Siemens 1996-2020     "
[05/04 17:26:12     40s] 	puts "//                             All Rights Reserved."
[05/04 17:26:12     40s] 	puts "//         THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION"
[05/04 17:26:12     40s] 	puts "//            WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION"
[05/04 17:26:12     40s] 	puts "//              OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS."
[05/04 17:26:12     40s] 	puts "//"
[05/04 17:26:12     40s] 	# RealTime and CI interface are no longer in beta.
[05/04 17:26:12     40s] 	if { 0 } {
[05/04 17:26:12     40s] 		puts "//        This software is in pre-production form and is considered to be"
[05/04 17:26:12     40s] 		puts "//        beta code that is subject to the terms of the current Mentor"
[05/04 17:26:12     40s] 		puts "//        Graphics End-User License Agreement or your signed agreement"
[05/04 17:26:12     40s] 		puts "//        with Mentor Graphics that contains beta terms, whichever applies."
[05/04 17:26:12     40s] 		puts "//"
[05/04 17:26:12     40s] 	}
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @mgc_enc::show_banner
[05/04 17:26:12     40s] //
[05/04 17:26:12     40s] //  Calibre Encounter/Innovus Interface * (v2021.1_33.19) *
[05/04 17:26:12     40s] //
[05/04 17:26:12     40s] //                           Copyright Siemens 1996-2020     
[05/04 17:26:12     40s] //                             All Rights Reserved.
[05/04 17:26:12     40s] //         THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION
[05/04 17:26:12     40s] //            WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION
[05/04 17:26:12     40s] //              OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
[05/04 17:26:12     40s] //
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/encounter.tcl'.
[05/04 17:26:12     40s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/enc_rdb.tcl' ...
[05/04 17:26:12     40s] #************************************************************************CPY11*#
[05/04 17:26:12     40s] #*   Copyright Mentor Graphics Corporation 2014  All Rights Reserved.    CPY12*#
[05/04 17:26:12     40s] #*                                                                       CPY13*#
[05/04 17:26:12     40s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/04 17:26:12     40s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/04 17:26:12     40s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/04 17:26:12     40s] #*                                                                       CPY17*#
[05/04 17:26:12     40s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/04 17:26:12     40s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/04 17:26:12     40s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/04 17:26:12     40s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/04 17:26:12     40s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/04 17:26:12     40s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/04 17:26:12     40s] #*   particular purpose.                                                 CPY1E*#
[05/04 17:26:12     40s] #*                                                                       CPY1F*#
[05/04 17:26:12     40s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/04 17:26:12     40s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/04 17:26:12     40s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/04 17:26:12     40s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/04 17:26:12     40s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/04 17:26:12     40s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/04 17:26:12     40s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/04 17:26:12     40s] #*   to the claim                                                        CPY1N*#
[05/04 17:26:12     40s] #************************************************************************CPY1O*#
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # This contains Tcl procs specific to integration of Encounter with RVE and Calibre
[05/04 17:26:12     40s] # Interactive for creating DRC markers and route blockages.
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @source [file join $::env(MGC_HOME) shared pkgs icv tools querytcl import_rdb.tcl]
[05/04 17:26:12     40s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/querytcl/import_rdb.tcl' ...
[05/04 17:26:12     40s] #************************************************************************CPY11*#
[05/04 17:26:12     40s] #*   Copyright Mentor Graphics Corporation 2014  All Rights Reserved.    CPY12*#
[05/04 17:26:12     40s] #*                                                                       CPY13*#
[05/04 17:26:12     40s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/04 17:26:12     40s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/04 17:26:12     40s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/04 17:26:12     40s] #*                                                                       CPY17*#
[05/04 17:26:12     40s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/04 17:26:12     40s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/04 17:26:12     40s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/04 17:26:12     40s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/04 17:26:12     40s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/04 17:26:12     40s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/04 17:26:12     40s] #*   particular purpose.                                                 CPY1E*#
[05/04 17:26:12     40s] #*                                                                       CPY1F*#
[05/04 17:26:12     40s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/04 17:26:12     40s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/04 17:26:12     40s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/04 17:26:12     40s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/04 17:26:12     40s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/04 17:26:12     40s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/04 17:26:12     40s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/04 17:26:12     40s] #*   to the claim                                                        CPY1N*#
[05/04 17:26:12     40s] #************************************************************************CPY1O*#
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] # This contains Tcl procs specific to integration of ICCompiler and EDI with RVE and Calibre
[05/04 17:26:12     40s] # Interactive for creating DRC markers and route guides/blockages.
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/04 17:26:12     40s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @namespace eval Calibre::import_rdb {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     namespace export *
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     ################################################################################
[05/04 17:26:12     40s]     # Parse the list of arguments into an array
[05/04 17:26:12     40s]     ################################################################################
[05/04 17:26:12     40s]     proc ParseArguments { argList } {
[05/04 17:26:12     40s]       array set retArguments {}
[05/04 17:26:12     40s]       set standAloneArgIdx 0
[05/04 17:26:12     40s]       set argListLength [llength $argList]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       for {set argIndex 0} {$argIndex < $argListLength} {incr argIndex} {
[05/04 17:26:12     40s]         set thisArgument [lindex $argList $argIndex]
[05/04 17:26:12     40s]         if { ([string index $thisArgument 0] eq "-") && (![string is digit [string index $thisArgument 1]]) } {
[05/04 17:26:12     40s]           # This arg is a switch
[05/04 17:26:12     40s]           if { [expr {$argIndex+1}] < $argListLength } {
[05/04 17:26:12     40s]             # Check next argument
[05/04 17:26:12     40s]             set nextArgument [lindex $argList [expr {$argIndex+1}]]
[05/04 17:26:12     40s]             if { ([string index $nextArgument 0] ne "-") || ([string is digit [string index $nextArgument 1]]) } {
[05/04 17:26:12     40s]               set retArguments($thisArgument) $nextArgument
[05/04 17:26:12     40s]               incr argIndex
[05/04 17:26:12     40s]               continue
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]           }
[05/04 17:26:12     40s]           # This arg is a flag
[05/04 17:26:12     40s]           set retArguments($thisArgument) ""
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]           # This arg is a stand-alone argument
[05/04 17:26:12     40s]           set retArguments($standAloneArgIdx) $thisArgument
[05/04 17:26:12     40s]           incr standAloneArgIdx
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       return [array get retArguments]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/querytcl/import_rdb.tcl'.
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @namespace eval Calibre {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     namespace export convert_to_drc_errors convert_to_route_blockages import_drc_errors import_route_blockages
[05/04 17:26:12     40s]     namespace import ::Calibre::import_rdb::*
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc import_drc_errors { fileName } {
[05/04 17:26:12     40s]         return [::Calibre::marker_if::import_file $fileName]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc import_route_blockages { fileName } {
[05/04 17:26:12     40s]         return [::Calibre::route_if::import_file $fileName]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc convert_rdb { import_proc args } {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       set calibre "$::env(MGC_HOME)/bin/calibre"
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       set rve_com [list $calibre -rve]
[05/04 17:26:12     40s]       lappend rve_com [join $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       array unset arguments
[05/04 17:26:12     40s]       array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       set to_import_file ""
[05/04 17:26:12     40s]       if { ![info exists arguments(-output_file)] } {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [info exists ::env(MGC_TMPDIR)] } {
[05/04 17:26:12     40s]           if { [file exists $::env(MGC_TMPDIR)] } {
[05/04 17:26:12     40s]             set to_import_file $::env(MGC_TMPDIR)
[05/04 17:26:12     40s]           }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $to_import_file eq "" && [info exists ::env(MGC_HOME)] } {
[05/04 17:26:12     40s]           if { [file exists $::env(MGC_HOME)] } {
[05/04 17:26:12     40s]             set to_import_file $::env(MGC_HOME)
[05/04 17:26:12     40s]             set to_import_file "$to_import_file/tmp"
[05/04 17:26:12     40s]             if { ![file exists $to_import_file] } {
[05/04 17:26:12     40s]               set to_import_file ""
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]           }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $to_import_file eq "" && [file exists "/usr/tmp"] } {
[05/04 17:26:12     40s]           set to_import_file "/usr/tmp"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $to_import_file eq "" } {
[05/04 17:26:12     40s]           set to_import_file "."
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         # Temporary file for storing Stuttgard commands
[05/04 17:26:12     40s]         set to_import_file "$to_import_file/mgc_rve_rdb[pid]"
[05/04 17:26:12     40s]         lappend rve_com -output_file $to_import_file
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       # lappend rve_com -no_command_in_transcript
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       # Run RVE
[05/04 17:26:12     40s]       set rveStatus [catch {eval exec $rve_com} result]
[05/04 17:26:12     40s]       puts $result
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       if { $rveStatus ne 0 } {
[05/04 17:26:12     40s]         puts "\nConversion failed.\n"
[05/04 17:26:12     40s]         return 1
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       if { $to_import_file eq "" } {
[05/04 17:26:12     40s]         puts "RDB conversion successful."
[05/04 17:26:12     40s]         return 0
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       set retStatus [catch {eval $import_proc $to_import_file} result]
[05/04 17:26:12     40s]       if { $retStatus ne 0 } {
[05/04 17:26:12     40s]       	puts $result
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       if { ($to_import_file ne "") && [file exists $to_import_file] } {
[05/04 17:26:12     40s]         if { (![info exists ::env(MGC_RVE_HILIGHT_DEBUG)]) || \
[05/04 17:26:12     40s]              ($::env(MGC_RVE_HILIGHT_DEBUG) == 0) } {
[05/04 17:26:12     40s]           file delete $to_import_file
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]       return $retStatus
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc convert_to_drc_errors { args } {
[05/04 17:26:12     40s]       puts "\nCommand:  convert_to_drc_errors $args\n"
[05/04 17:26:12     40s]       set retStatus [catch {eval convert_rdb Calibre::import_drc_errors -wrapper ::Calibre::convert_to_drc_errors -convert_to edi_drc $args} result]
[05/04 17:26:12     40s]       if { $retStatus ne 0 } {
[05/04 17:26:12     40s]       	return 0
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       return 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc convert_to_route_blockages { args } {
[05/04 17:26:12     40s]       puts "\nCommand:  convert_to_route_blockages $args\n"
[05/04 17:26:12     40s]       set retStatus [catch {eval convert_rdb Calibre::import_route_blockages -wrapper ::Calibre::convert_to_route_blockages -convert_to edi_blk $args} result]
[05/04 17:26:12     40s]       if { $retStatus ne 0 } {
[05/04 17:26:12     40s]       	return 0
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       return 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @namespace eval Calibre::marker_if {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     namespace export mgc_rve_add_start mgc_rve_add_cell       \
[05/04 17:26:12     40s]               mgc_rve_add_rectangle mgc_rve_define_rectangle  \
[05/04 17:26:12     40s]               mgc_rve_add_end                                 \
[05/04 17:26:12     40s]               mra_check                                       \
[05/04 17:26:12     40s]               mra_start             mra_cell                  \
[05/04 17:26:12     40s]               mra_rect              mrd_rect                  \
[05/04 17:26:12     40s]               mra_end                                         \
[05/04 17:26:12     40s]               import_file
[05/04 17:26:12     40s]     namespace import ::Calibre::import_rdb::*
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     set         currentCellName         ""
[05/04 17:26:12     40s]     set         currentCheckName        ""
[05/04 17:26:12     40s]     array unset createdCheckTypes
[05/04 17:26:12     40s]     set         currentLayers           [list]
[05/04 17:26:12     40s]     set         currentCheckText        ""
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc register_cell { sticky cell args } {
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set curr_init_top_cell [dbCellName [dbgTopCell]]
[05/04 17:26:12     40s]         if { ($curr_init_top_cell ne "") && ($cell ne $curr_init_top_cell) } {
[05/04 17:26:12     40s]             set currentCellName         ""
[05/04 17:26:12     40s]             puts "Error: '$cell' should be opened and set as the top cell."
[05/04 17:26:12     40s]             return ""
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s]         if { [info exists arguments(-precision)] } {
[05/04 17:26:12     40s]           set precision $arguments(-precision)
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]           set precision  1000
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         ::mgc_enc::mgc_rve_context $cell $precision
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $sticky } {
[05/04 17:26:12     40s]             set currentCellName $cell
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $cell
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_check_internal { sticky name_pos args } {
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckTypes
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s]         variable currentCheckText
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [llength $args] < 1 } {
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $name_pos == 1 } {
[05/04 17:26:12     40s]             set cell [join [lindex $args 0]]
[05/04 17:26:12     40s]             set route_view [eval mra_cell ${cell} $args]
[05/04 17:26:12     40s]             if { $route_view eq "" } {
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         } else {   # name_pos <= 0
[05/04 17:26:12     40s]             if { $currentCellName eq "" } {
[05/04 17:26:12     40s]                 puts "Error: cell should be set first."
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set cell $currentCellName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $name_pos >= 0 } {
[05/04 17:26:12     40s]             set check [join [lindex $args $name_pos]]
[05/04 17:26:12     40s]         } else {   # name_pos < 0
[05/04 17:26:12     40s]             if { $currentCheckName eq "" } {
[05/04 17:26:12     40s]                 puts "Error: check should be set first."
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set check $currentCheckName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set check_type_name [join [list ${cell} ${check}] /]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set check_text   ""
[05/04 17:26:12     40s]         set check_layers [list]
[05/04 17:26:12     40s]         if { [info exists createdCheckTypes(${check_type_name})] } {
[05/04 17:26:12     40s]             set check_text_and_layers $createdCheckTypes(${check_type_name})
[05/04 17:26:12     40s]             set check_text   [lindex check_text_and_layers 0]
[05/04 17:26:12     40s]             set check_layers [lindex check_text_and_layers 1]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $sticky } {
[05/04 17:26:12     40s]             set currentCheckText $check_text
[05/04 17:26:12     40s]             set currentLayers $check_layers
[05/04 17:26:12     40s]             set currentCheckName ${check}
[05/04 17:26:12     40s]             if { [info exists arguments(-text_desc)] } {
[05/04 17:26:12     40s]                 set currentCheckText $arguments(-text_desc)
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             if { [info exists arguments(-layer)] } {
[05/04 17:26:12     40s]                 set currentLayers $arguments(-layer)
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set createdCheckTypes($check_type_name) [list $currentCheckText $currentLayers]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $check_layers
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_clear { {cell ""} } {
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckTypes
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s]         variable currentCheckText
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set         currentCellName     ""
[05/04 17:26:12     40s]         set         currentCheckName     ""
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset createdCheckTypes
[05/04 17:26:12     40s]         array set   createdCheckTypes       {}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set         currentLayers           [list]
[05/04 17:26:12     40s]         set         currentCheckText        ""
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $cell
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_drc_error { de_pos shape args } {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckTypes
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s]         variable currentCheckText
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [llength $args] < 1 } {
[05/04 17:26:12     40s]             puts "Error: invalid parameters for creating Encounter DRC Error: mgc_rve_add_rectangle $args."
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $currentCellName eq "" } {
[05/04 17:26:12     40s]             return 0
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $de_pos >= 1 } {
[05/04 17:26:12     40s]             set cell [join [lindex $args 0]]
[05/04 17:26:12     40s]             set drc_layout_cell [eval mra_cell ${cell} $args]
[05/04 17:26:12     40s]             if { $drc_layout_cell eq "" } {
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set cell $currentCellName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $de_pos >= 2 } {
[05/04 17:26:12     40s]             set check [join [lindex $args 1]]
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set check $currentCheckName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set layers {}
[05/04 17:26:12     40s]         if { [info exists arguments(-layer)] } {
[05/04 17:26:12     40s]             set layers $arguments(-layer)
[05/04 17:26:12     40s]         } elseif { [llength $currentLayers] != 0 } {
[05/04 17:26:12     40s]             set layers $currentLayers
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set drc_info ""
[05/04 17:26:12     40s]         if { [info exists arguments(-info)] } {
[05/04 17:26:12     40s]             set drc_info $arguments(-info)
[05/04 17:26:12     40s]         } elseif { $currentCheckText ne "" } {
[05/04 17:26:12     40s]             set drc_info [list $currentCheckText]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set edi_com [list createMarker -type Calibre -subtype ${check}]
[05/04 17:26:12     40s]         if { $drc_info ne "" } {
[05/04 17:26:12     40s]             lappend edi_com -desc $drc_info
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set rects [lindex $args [expr {$de_pos + 1}]]
[05/04 17:26:12     40s]         set count 0
[05/04 17:26:12     40s]         foreach rect $rects {
[05/04 17:26:12     40s]             set edi_com_exe $edi_com
[05/04 17:26:12     40s]             lappend edi_com_exe $shape [join $rect]
[05/04 17:26:12     40s]             if { [llength $layers] != 0 } {
[05/04 17:26:12     40s]                 foreach layer $layers {
[05/04 17:26:12     40s]                     set edi_com_exe_rect $edi_com_exe
[05/04 17:26:12     40s]                     lappend edi_com_exe_rect -layer $layer
[05/04 17:26:12     40s]                     incr count
[05/04 17:26:12     40s]                     eval $edi_com_exe_rect
[05/04 17:26:12     40s]                 }
[05/04 17:26:12     40s]             } else {
[05/04 17:26:12     40s]                 incr count
[05/04 17:26:12     40s]                 eval $edi_com_exe
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $count
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_start { {cell ""} } {
[05/04 17:26:12     40s]         return [mgc_rve_add_clear]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_start {} mra_start
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_cell { cell args } {
[05/04 17:26:12     40s]         set drc_layout_cell [eval register_cell true ${cell} $args]
[05/04 17:26:12     40s]         return $drc_layout_cell
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_cell {} mra_cell
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_check { args } {
[05/04 17:26:12     40s]         set layers [eval mgc_rve_add_check_internal true 0 $args]
[05/04 17:26:12     40s]         return $layers
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_check {} mra_check
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mrd_check { args } {
[05/04 17:26:12     40s]         set layers [eval mgc_rve_add_check_internal true 1 $args]
[05/04 17:26:12     40s]         return $layers
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_define_check {} mrd_check
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_rect { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_drc_error -1 -bbox $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_rectangle {} mra_rect
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mrd_rect { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_drc_error 2 -bbox $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_define_rectangle {} mrd_rect
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_end { {cell ""} } {
[05/04 17:26:12     40s]         return [mgc_rve_add_clear]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_end {} mra_end
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc import_file { fileName } {
[05/04 17:26:12     40s]       mra_start
[05/04 17:26:12     40s]       if {[catch {source $fileName}]} {
[05/04 17:26:12     40s]       	return 0
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       mra_end
[05/04 17:26:12     40s]       return 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] @namespace eval Calibre::route_if {
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     namespace export mgc_rve_add_start      mgc_rve_add_cell         \
[05/04 17:26:12     40s]                      mgc_rve_add_check      mgc_rve_define_check     \
[05/04 17:26:12     40s]                      mgc_rve_add_rectangle  mgc_rve_define_rectangle \
[05/04 17:26:12     40s]                      mgc_rve_add_polygon    mgc_rve_define_polygon   \
[05/04 17:26:12     40s]                      mgc_rve_add_end                                 \
[05/04 17:26:12     40s]                      mra_start              mra_cell                 \
[05/04 17:26:12     40s]                      mra_check              mrd_check                \
[05/04 17:26:12     40s]                      mra_rect               mrd_rect                 \
[05/04 17:26:12     40s]                      mra_poly               mrd_pol                  \
[05/04 17:26:12     40s]                      mra_end                                         \
[05/04 17:26:12     40s]                      import_file
[05/04 17:26:12     40s]     namespace import ::Calibre::import_rdb::*
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     array set   createdCheckLayers      {}
[05/04 17:26:12     40s]     set         currentCellName         ""
[05/04 17:26:12     40s]     set         currentCheckName        ""
[05/04 17:26:12     40s]     array unset createdCheckCount
[05/04 17:26:12     40s]     set         currentLayers           [list]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_open_cell { sticky cell args } {
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { ${cell} eq "" } {
[05/04 17:26:12     40s]             return ""
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set curr_init_top_cell [dbCellName [dbgTopCell]]
[05/04 17:26:12     40s]         if { ($curr_init_top_cell ne "") && (${cell} ne $curr_init_top_cell) } {
[05/04 17:26:12     40s]             set currentCellName         ""
[05/04 17:26:12     40s]             puts "Error: '$cell' should be opened and set as the top cell."
[05/04 17:26:12     40s]             return ""
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s]         if { [info exists arguments(-precision)] } {
[05/04 17:26:12     40s]           set precision $arguments(-precision)
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]           set precision  1000
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s]         ::mgc_enc::mgc_rve_context ${cell} $precision
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $sticky } {
[05/04 17:26:12     40s]             set currentCellName ${cell}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return ${cell}
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_clear {} {
[05/04 17:26:12     40s]         variable createdCheckLayers
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckCount
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset createdCheckLayers
[05/04 17:26:12     40s]         array set   createdCheckLayers      {}
[05/04 17:26:12     40s]         set         currentCellName         ""
[05/04 17:26:12     40s]         set         currentCheckName        ""
[05/04 17:26:12     40s]         array unset createdCheckCount
[05/04 17:26:12     40s]         array set   createdCheckCount       {}
[05/04 17:26:12     40s]         set         currentLayers           [list]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_check_internal { sticky name_pos args } {
[05/04 17:26:12     40s]         variable createdCheckLayers
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckCount
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [llength $args] < 1 } {
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [info exists arguments(-text_desc)] } {
[05/04 17:26:12     40s]           set text_desc $arguments(-text_desc)
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]           set text_desc  ""
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $name_pos == 1 } {
[05/04 17:26:12     40s] 	        set cell [join [lindex $args 0]]
[05/04 17:26:12     40s] 	        set drc_cell [eval mgc_rve_open_cell $sticky ${cell} $args]
[05/04 17:26:12     40s] 	        if { $drc_cell eq "" } {
[05/04 17:26:12     40s] 	            return {}
[05/04 17:26:12     40s] 	        }
[05/04 17:26:12     40s]     	} else {   # name_pos <= 0
[05/04 17:26:12     40s]             if { $currentCellName == "" } {
[05/04 17:26:12     40s] 	            puts "Error: cell has not been defined."
[05/04 17:26:12     40s] 	            return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set cell $currentCellName
[05/04 17:26:12     40s]     	}
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $name_pos >= 0 } {
[05/04 17:26:12     40s]             set check [join [lindex $args $name_pos]]
[05/04 17:26:12     40s]         } else {   # name_pos < 0
[05/04 17:26:12     40s]             if { $currentCheckName eq "" } {
[05/04 17:26:12     40s]                 puts "Error: check should be set first."
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set check $currentCheckName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set check_type_name [join [list ${cell} ${check}] /]
[05/04 17:26:12     40s]         if { [info exists createdCheckLayers(${check_type_name})] } {
[05/04 17:26:12     40s]             set check_layers $createdCheckTypes(${check_type_name})
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set createdCheckCount(${check_type_name}) 0
[05/04 17:26:12     40s]             set check_layers [list]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $sticky } {
[05/04 17:26:12     40s]             set currentLayers $check_layers
[05/04 17:26:12     40s]             set currentCheckName ${check}
[05/04 17:26:12     40s]             if { [info exists arguments(-layer)] } {
[05/04 17:26:12     40s]                 set currentLayers $arguments(-layer)
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s]             set createdCheckLayers(${check_type_name}) $currentLayers
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return [list ${cell} ${check}]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mgc_rve_add_route_blockages { shape coords_pos breakup args } {
[05/04 17:26:12     40s]         variable currentCellName
[05/04 17:26:12     40s]         variable currentCheckName
[05/04 17:26:12     40s]         variable createdCheckCount
[05/04 17:26:12     40s]         variable currentLayers
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [llength $args] < 1 } {
[05/04 17:26:12     40s]             puts "Error: invalid parameters for creating Encounter route blockage: mgc_rve_add_rectangle/polygon $args."
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]        	set check_name_pos [expr {$coords_pos - 2}]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $check_name_pos >= 0 } {
[05/04 17:26:12     40s]             set cell_and_check [eval mgc_rve_add_check_internal false $check_name_pos $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]             if { [llength $cell_and_check] <= 1 } {
[05/04 17:26:12     40s]                 return {}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]             set cell [lindex $cell_and_check 0]
[05/04 17:26:12     40s]             set checkName       [lindex $cell_and_check 1]
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set cell            $currentCellName
[05/04 17:26:12     40s]             set checkName       $currentCheckName
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $cell eq "" } {
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $checkName eq "" } {
[05/04 17:26:12     40s]             puts "Error: check should've been set first."
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         array unset arguments
[05/04 17:26:12     40s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { [info exists arguments(-layer)] } {
[05/04 17:26:12     40s]             set layers $arguments(-layer)
[05/04 17:26:12     40s]         } elseif { [llength $currentLayers] != 0 } {
[05/04 17:26:12     40s]             set layers $currentLayers
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             puts "Error: need -layer parameter to create route blockage '[lindex $args $coords_pos]'."
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         if { $breakup } {
[05/04 17:26:12     40s]             set coords [lindex $args $coords_pos]
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set coords [list [lindex $args $coords_pos]]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set rb_name_pos [expr {$coords_pos - 1}]
[05/04 17:26:12     40s]         if { $rb_name_pos >= 0 } {
[05/04 17:26:12     40s]             set rb_name [lindex $args $rb_name_pos]
[05/04 17:26:12     40s]         } else {
[05/04 17:26:12     40s]             set rb_name "mgc_rve_check"
[05/04 17:26:12     40s]             append rb_name _${cell}
[05/04 17:26:12     40s]             append rb_name _${checkName}
[05/04 17:26:12     40s]             foreach layer $layers {
[05/04 17:26:12     40s]                 append rb_name _${layer}
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]             set check_type_name [join [list ${cell} ${checkName}] /]
[05/04 17:26:12     40s]             append rb_name _$createdCheckCount(${check_type_name})
[05/04 17:26:12     40s]             incr createdCheckCount(${check_type_name})
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set edi_com [list createRouteBlk -layer $layers]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set extra_name ""
[05/04 17:26:12     40s]         if { [llength $coords] > 1 } {
[05/04 17:26:12     40s]             set extra_name "_"
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set count 0
[05/04 17:26:12     40s]         set retVal {}
[05/04 17:26:12     40s]         foreach coord $coords {
[05/04 17:26:12     40s]             set edi_com_exe $edi_com
[05/04 17:26:12     40s]             lappend edi_com_exe $shape [join [join $coord]]
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]             set rb_name_exe $rb_name
[05/04 17:26:12     40s]             if { $extra_name ne "" } {
[05/04 17:26:12     40s]                 append rb_name_exe $extra_name $count
[05/04 17:26:12     40s]                 incr count
[05/04 17:26:12     40s]             }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]             lappend edi_com_exe -name $rb_name_exe
[05/04 17:26:12     40s]             lappend retVal [eval $edi_com_exe]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $retVal
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_start { {cell ""} args } {
[05/04 17:26:12     40s]         mgc_rve_add_clear
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         set drc_cell ""
[05/04 17:26:12     40s]         if { $cell ne "" } {
[05/04 17:26:12     40s]         	set drc_cell [eval mgc_rve_open_cell true ${cell} $args]
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return $drc_cell
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_start {} mra_start
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_cell { cell args } {
[05/04 17:26:12     40s]        	set drc_cell [eval mgc_rve_open_cell true ${cell} $args]
[05/04 17:26:12     40s]         return $drc_cell
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_cell {} mra_cell
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_check { args } {
[05/04 17:26:12     40s]         set cell_and_check [eval mgc_rve_add_check_internal true 0 $args]
[05/04 17:26:12     40s]         if { [llength $cell_and_check] <= 1 } {
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return [lindex $cell_and_check 1]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_check {} mra_check
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mrd_check { args } {
[05/04 17:26:12     40s]         set cell_and_check [eval mgc_rve_add_check_internal true 1 $args]
[05/04 17:26:12     40s]         if { [llength $cell_and_check] <= 1 } {
[05/04 17:26:12     40s]             return {}
[05/04 17:26:12     40s]         }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]         return [lindex $cell_and_check 1]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_define_check {} mrd_check
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_rect { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_route_blockages -box 0 true $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_rectangle {} mra_rect
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mrd_rect { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_route_blockages -box 3 true $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_define_rectangle {} mrd_rect
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_poly { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_route_blockages -polygon 0 false $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_polygon {} mra_poly
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mrd_poly { args } {
[05/04 17:26:12     40s]         return [eval mgc_rve_add_route_blockages -polygon 3 false $args]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_define_polygon {} mrd_poly
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc mra_end { {cell ""} } {
[05/04 17:26:12     40s]         return [mgc_rve_add_clear]
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     interp alias {} mgc_rve_add_end {} mra_end
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s]     proc import_file { fileName } {
[05/04 17:26:12     40s]       mra_start
[05/04 17:26:12     40s]       if {[catch {source $fileName}]} {
[05/04 17:26:12     40s]       	return 0
[05/04 17:26:12     40s]       }
[05/04 17:26:12     40s]       mra_end
[05/04 17:26:12     40s]       return 1
[05/04 17:26:12     40s]     }
[05/04 17:26:12     40s] }
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/enc_rdb.tcl'.
[05/04 17:26:12     40s] 
[05/04 17:26:12     40s] ERROR: Current execution environment is VCO=aok. Software tree is for environment VCO=aoi.
[05/04 17:26:12     40s] //  ERROR while loading Calibre interface: couldn't open "/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/tmp/encInp.255034.customMenu": no such file or directory
[05/04 17:26:12     40s] @file 61:
[05/04 17:26:12     40s] @file 62: }
[05/04 17:26:12     40s] #@ End verbose source /proj/cad/mentor_2021/aoi_cal_2021.1_33.19/lib/cal_enc.tcl
[05/04 17:26:12     40s] 0
[05/04 17:26:12     40s] @innovus 4> [05/05 14:50:36   4121s] 
[05/05 14:50:36   4121s] *** Summary of all messages that are not suppressed in this session:
[05/05 14:50:36   4121s] Severity  ID               Count  Summary                                  
[05/05 14:50:36   4121s] WARNING   IMPDBTCL-321         1  The attribute '%s' still works but will ...
[05/05 14:50:36   4121s] ERROR     IMPTR-2101           1  Layer %s: Pitch=%dx%d is still less than...
[05/05 14:50:36   4121s] WARNING   IMPTR-2104           1  Layer %s: Pitch=%d is less than min widt...
[05/05 14:50:36   4121s] WARNING   IMPTR-2108           1  For layer M%d, the gaps of %d out of %d ...
[05/05 14:50:36   4121s] WARNING   IMPCTE-107           1  The following globals have been obsolete...
[05/05 14:50:36   4121s] WARNING   IMPTCM-77            1  Option "%s" for command %s is obsolete a...
[05/05 14:50:36   4121s] ERROR     TECHLIB-1171        12  The attribute '%s' of group '%s' on line...
[05/05 14:50:36   4121s] WARNING   TECHLIB-1277        16  The %s '%s' has been defined for %s %s '...
[05/05 14:50:36   4121s] WARNING   TECHLIB-9108        20   '%s' not specified in the library, usin...
