[05/05 14:53:05      0s] 
[05/05 14:53:05      0s] Cadence Innovus(TM) Implementation System.
[05/05 14:53:05      0s] Copyright 2019 Cadence Design Systems, Inc. All rights reserved worldwide.
[05/05 14:53:05      0s] 
[05/05 14:53:05      0s] Version:	v19.11-s128_1, built Tue Aug 20 20:54:34 PDT 2019
[05/05 14:53:05      0s] Options:	-stylus 
[05/05 14:53:05      0s] Date:		Mon May  5 14:53:05 2025
[05/05 14:53:05      0s] Host:		engnx06a.utdallas.edu (x86_64 w/Linux 4.18.0-553.46.1.el8_10.x86_64) (8cores*32cpus*AMD EPYC 7F32 8-Core Processor 512KB)
[05/05 14:53:05      0s] OS:		Red Hat Enterprise Linux release 8.10 (Ootpa)
[05/05 14:53:05      0s] 
[05/05 14:53:05      0s] License:
[05/05 14:53:05      0s] 		invs	Innovus Implementation System	19.1	checkout succeeded
[05/05 14:53:05      0s] 		8 CPU jobs allowed with the current license(s). Use set_multi_cpu_usage to set your required CPU count.
[05/05 14:53:11      4s] 
[05/05 14:53:11      4s] 
[05/05 14:53:19      8s] @(#)CDS: Innovus v19.11-s128_1 (64bit) 08/20/2019 20:54 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/05 14:53:19      8s] @(#)CDS: NanoRoute 19.11-s128_1 NR190815-2055/19_11-UB (database version 18.20, 469.7.1) {superthreading v1.51}
[05/05 14:53:19      8s] @(#)CDS: AAE 19.11-s034 (64bit) 08/20/2019 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/05 14:53:19      8s] @(#)CDS: CTE 19.11-s040_1 () Aug  1 2019 08:53:57 ( )
[05/05 14:53:19      8s] @(#)CDS: SYNTECH 19.11-e010_1 () Jul 15 2019 20:31:02 ( )
[05/05 14:53:19      8s] @(#)CDS: CPE v19.11-s006
[05/05 14:53:19      8s] @(#)CDS: IQuantus/TQuantus 19.1.2-s245 (64bit) Thu Aug 1 10:22:01 PDT 2019 (Linux 2.6.32-431.11.2.el6.x86_64)
[05/05 14:53:19      8s] @(#)CDS: OA 22.60-p020 Mon May 13 19:21:36 2019
[05/05 14:53:19      8s] @(#)CDS: SGN 18.10-d003 (18-Jul-2018) (64 bit executable, Qt5.9.1)
[05/05 14:53:19      8s] @(#)CDS: RCDB 11.14.18
[05/05 14:53:19      8s] @(#)CDS: STYLUS 19.10-s008_1 (06/27/2019 02:55 PDT)
[05/05 14:53:19      8s] Create and set the environment variable TMPDIR to /usr/tmp/innovus_temp_1320363_engnx06a.utdallas.edu_oma190007_1W9hj8.

[05/05 14:53:19      8s] Create and set the environment variable TMPDIR to /usr/tmp/innovus_temp_1320363_engnx06a.utdallas.edu_oma190007_1W9hj8.
[05/05 14:53:19      8s] 
[05/05 14:53:19      8s] Change the soft stacksize limit to 0.2%RAM (514 mbytes). Set global soft_stack_size_limit to change the value.
[05/05 14:53:20      9s] 
[05/05 14:53:20      9s] **INFO:  MMMC transition support version v31-84 
[05/05 14:53:20      9s] 
[05/05 14:53:21     10s] @innovus 1> set calibre_home [exec realpath [exec dirname [exec which calibre]]/..]
source $calibre_home/lib/cal_enc.tcl
/proj/cad/mentor_2021/aoi_cal_2021.1_33.19
[05/05 14:53:56     12s] @innovus 2> source $calibre_home/lib/cal_enc.tcl
[05/05 14:53:56     12s] #@ Begin verbose source /proj/cad/mentor_2021/aoi_cal_2021.1_33.19/lib/cal_enc.tcl (pre)
[05/05 14:53:56     12s] @file 1: #/************************************************************************CPY11*/
[05/05 14:53:56     12s] @file 2: #/*   Copyright Mentor Graphics Corporation 2018  All Rights Reserved.    CPY12*/
[05/05 14:53:56     12s] @file 3: #/*                                                                       CPY13*/
[05/05 14:53:56     12s] @file 4: #/*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*/
[05/05 14:53:56     12s] @file 5: #/*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*/
[05/05 14:53:56     12s] @file 6: #/*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*/
[05/05 14:53:56     12s] @file 7: #/************************************************************************CPY17*/
[05/05 14:53:56     12s] @file 8:
[05/05 14:53:56     12s] @file 9: if { [info commands mgc_load_calibre]=="" } {
[05/05 14:53:56     12s] @file 10:
[05/05 14:53:56     12s] @file 11: proc mgc_enc_is_common_ui_mode {} {
[05/05 14:53:56     12s]   set isCuiMode 0
[05/05 14:53:56     12s]   if { [info exists ::env(MGC_CALIBRE_INNOVUS_CUI_MODE)] && $::env(MGC_CALIBRE_INNOVUS_CUI_MODE)=="1298096" } {
[05/05 14:53:56     12s]     if { [info commands eval_legacy] == "eval_legacy" } {
[05/05 14:53:56     12s]       set isCuiMode 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]   }
[05/05 14:53:56     12s]   return $isCuiMode
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] @file 20:
[05/05 14:53:56     12s] @file 21: proc mgc_load_calibre {} {
[05/05 14:53:56     12s]   global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]   if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/05 14:53:56     12s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/05 14:53:56     12s]   }
[05/05 14:53:56     12s]   if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/05 14:53:56     12s]     puts "//   *** Environment variable CALIBRE_HOME or MGC_HOME must be set. ***"
[05/05 14:53:56     12s]     puts "//   *** Calibre interface NOT loaded. ***"
[05/05 14:53:56     12s]     return 0
[05/05 14:53:56     12s]   }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]   set etclf [file join $env(MGC_HOME) lib cal_innovus.tcl]
[05/05 14:53:56     12s]   if { ![file readable $etclf] } {
[05/05 14:53:56     12s]     puts "//   *** Could not read Calibre interface files. ***"
[05/05 14:53:56     12s]     puts "//   *** Calibre interface NOT loaded. ***"
[05/05 14:53:56     12s]     return 0
[05/05 14:53:56     12s]   }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]   if { [info commands eval_legacy]=="eval_legacy" && ![mgc_enc_is_common_ui_mode] } {
[05/05 14:53:56     12s]     eval_legacy "proc mgc_enc_is_common_ui_mode {} { return 0 }"
[05/05 14:53:56     12s]     if { [catch {eval_legacy "source -quiet $etclf"} msg] } {
[05/05 14:53:56     12s]       puts "//  ERROR while loading Calibre interface: $msg"
[05/05 14:53:56     12s]       return 0
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]   } else {
[05/05 14:53:56     12s]     set opt ""
[05/05 14:53:56     12s]     if { [mgc_enc_is_common_ui_mode] } {
[05/05 14:53:56     12s]       set opt "-quiet"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if { [catch "source $opt $etclf" msg] } {
[05/05 14:53:56     12s]       puts "//  ERROR while loading Calibre interface: $msg"
[05/05 14:53:56     12s]       return 0
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]   }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]   return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] @file 59:
[05/05 14:53:56     12s] @file 60: mgc_load_calibre
[05/05 14:53:56     12s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/edi_autofix_cmd.tcl' ...
[05/05 14:53:56     12s] #************************************************************************CPY11*#
[05/05 14:53:56     12s] #*   Copyright Mentor Graphics Corporation 2012  All Rights Reserved.    CPY12*#
[05/05 14:53:56     12s] #*                                                                       CPY13*#
[05/05 14:53:56     12s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/05 14:53:56     12s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/05 14:53:56     12s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/05 14:53:56     12s] #************************************************************************CPY17*#
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc calibre_autofix {args} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # Check if design is loaded
[05/05 14:53:56     12s]     if {[dbgTopCell]==0} {
[05/05 14:53:56     12s]         error "No design loaded!"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {[string compare $args ""]} {
[05/05 14:53:56     12s]         # If setup file is provided from icc_shell
[05/05 14:53:56     12s]         set setup_file $args
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         # If setup file is not provided open Select Setup File form
[05/05 14:53:56     12s]         set types {
[05/05 14:53:56     12s]             {"Tcl Files"     {.tcl} }
[05/05 14:53:56     12s]             {"All files"     *      }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         set setup_file [tk_getOpenFile -title "Select Setup File" -filetypes $types -parent .]
[05/05 14:53:56     12s]         # Selecting file is canceled
[05/05 14:53:56     12s]         if {![string compare $setup_file ""]} {
[05/05 14:53:56     12s]             return
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set fid [open "| $::env(MGC_HOME)/bin/calibre -autofix $setup_file"]
[05/05 14:53:56     12s]     while {[gets $fid line]  >= 0} {
[05/05 14:53:56     12s]         puts $line
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {[catch {close $fid} msg] != 0} {
[05/05 14:53:56     12s]         if {[string match "*WARNING*" $msg]} {
[05/05 14:53:56     12s]             puts $msg
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             error $msg
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         global errorCode
[05/05 14:53:56     12s]         if {"CHILDSTATUS" == [lindex $errorCode 0]} {
[05/05 14:53:56     12s]             set exit_status [lindex $errorCode 2]
[05/05 14:53:56     12s]             puts "exit status is $exit_status"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set fid [open $setup_file r]
[05/05 14:53:56     12s]     while {[gets $fid value]  >= 0} {
[05/05 14:53:56     12s]         if [string match "*set_output_dir*" $value] {
[05/05 14:53:56     12s]             set words [regexp -all -inline {\S+} $value]
[05/05 14:53:56     12s]             set first [lindex $words 0]
[05/05 14:53:56     12s]             if {![string match "#*" $first]} {
[05/05 14:53:56     12s]                 set dir [lindex $words 1]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         } elseif [string match "*set_output_def_file*" $value] {
[05/05 14:53:56     12s]             set words [regexp -all -inline {\S+} $value]
[05/05 14:53:56     12s]             set first [lindex $words 0]
[05/05 14:53:56     12s]             if {![string match "#*" $first]} {
[05/05 14:53:56     12s]                 set def [lindex $words 1]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         } elseif [string match "*set_output_eco_file*" $value] {
[05/05 14:53:56     12s]             set words [regexp -all -inline {\S+} $value]
[05/05 14:53:56     12s]             set first [lindex $words 0]
[05/05 14:53:56     12s]             if {![string match "#*" $first]} {
[05/05 14:53:56     12s]                 set eco [lindex $words 1]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         } 
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {![info exists dir]} {
[05/05 14:53:56     12s]         # set_output_dir command is not in the setup file or commented
[05/05 14:53:56     12s]         set dir Autofix
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {![info exists def]} {
[05/05 14:53:56     12s]         # set_output_def_file command is not in the setup file or commented
[05/05 14:53:56     12s]         set def calibre_autofix.def
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {[info exists eco] && $eco eq "edi"} {
[05/05 14:53:56     12s]         source $dir/calibre_autofix.tcl
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         defIn -specialnets -nets $dir/$def
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc useECOFile {$dir} {
[05/05 14:53:56     12s]     set rVal 0
[05/05 14:53:56     12s]     if {[file readable $dir/calibre_autofix.tcl]} {
[05/05 14:53:56     12s]         set rVal 1
[05/05 14:53:56     12s]     } 
[05/05 14:53:56     12s]     return $rVal
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/edi_autofix_cmd.tcl'.
[05/05 14:53:56     12s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/encounter.tcl' ...
[05/05 14:53:56     12s] #************************************************************************CPY11*#
[05/05 14:53:56     12s] #*   Copyright Mentor Graphics Corporation 2004  All Rights Reserved.    CPY12*#
[05/05 14:53:56     12s] #*                                                                       CPY13*#
[05/05 14:53:56     12s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/05 14:53:56     12s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/05 14:53:56     12s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/05 14:53:56     12s] #*                                                                       CPY17*#
[05/05 14:53:56     12s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/05 14:53:56     12s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/05 14:53:56     12s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/05 14:53:56     12s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/05 14:53:56     12s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/05 14:53:56     12s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/05 14:53:56     12s] #*   particular purpose.                                                 CPY1E*#
[05/05 14:53:56     12s] #*                                                                       CPY1F*#
[05/05 14:53:56     12s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/05 14:53:56     12s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/05 14:53:56     12s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/05 14:53:56     12s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/05 14:53:56     12s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/05 14:53:56     12s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/05 14:53:56     12s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/05 14:53:56     12s] #*   to the claim                                                        CPY1N*#
[05/05 14:53:56     12s] #************************************************************************CPY1O*#
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ##################################################################################
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # encounter.tcl: Calibre-RVE server in the Encounter environment
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] ##################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ##################################################################################
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # This file contains TCL code that opens a server socket and listens for
[05/05 14:53:56     12s] # Calibre-RVE commands on that socket.
[05/05 14:53:56     12s] # 
[05/05 14:53:56     12s] # This file should be sourced in the Encounter environment as follows:
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # source encounter.tcl
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] ##################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @package require Tcl 8.0
[05/05 14:53:56     12s] @package require Tk  8.0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc cmn_source_widgets {} {
[05/05 14:53:56     12s] 	global _ui_vars _ui_fonts
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set geom [wm geom .]
[05/05 14:53:56     12s] 	set _ui_vars(MainGeometry) $geom
[05/05 14:53:56     12s] 	scan $geom "%dx%d+%d+%d" w h x y
[05/05 14:53:56     12s] 	set _ui_vars(wmframeW) [expr [winfo rootx .] - $x]
[05/05 14:53:56     12s] 	set _ui_vars(wmframeH) [expr [winfo rooty .] - $y]
[05/05 14:53:56     12s] 	
[05/05 14:53:56     12s] 	set _ui_fonts(Mono) -Adobe-Courier-Medium-R-Normal--*-150-*-*-*-*-*-*
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	global tcl_platform
[05/05 14:53:56     12s] 	if {$tcl_platform(platform) == "windows"} {
[05/05 14:53:56     12s] 		set _ui_vars(IsPC) 1
[05/05 14:53:56     12s] 		set _ui_vars(PathSeparator) ";"
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		set _ui_vars(IsPC) 0
[05/05 14:53:56     12s] 		set _ui_vars(PathSeparator) ":"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @cmn_source_widgets
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/05 14:53:56     12s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc uimessage_Note {pw msg} {
[05/05 14:53:56     12s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type ok -icon info
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] @proc uimessage_Error {pw msg} {
[05/05 14:53:56     12s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type ok -icon error
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc uimessage_YesNo {pw msg} {
[05/05 14:53:56     12s] 	tk_messageBox -title Calibre -parent $pw -message $msg -type yesno -icon question
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_integer_only {P} {
[05/05 14:53:56     12s] 	if { $P=="-" } {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	} elseif { [regexp {[ \t\n]} $P] } {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return [string is integer $P]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_no_white_spaces {P} {
[05/05 14:53:56     12s] 	if { [regexp {[ \t\n]} $P] } {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ###############################################################################
[05/05 14:53:56     12s] # uiutils_MakeScrolledText --
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # Provides an easy way of creating text widget with scrollbars
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # Arguments:
[05/05 14:53:56     12s] #   <f>          = Frame that will contain everything(gets created below)
[05/05 14:53:56     12s] #   <scrollbars> = What type of scrollbars will be used:
[05/05 14:53:56     12s] #                    {vt, hz, both, none}
[05/05 14:53:56     12s] #   [args]       = The remaining args that get passed to text widget creation
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # Returned Value:
[05/05 14:53:56     12s] #   Handle to internal text widget
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] @proc uiutils_MakeScrolledText {f scrollbars args} {
[05/05 14:53:56     12s] 	global _ui_vars
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s] 	if ![winfo exists $f] {frame $f}
[05/05 14:53:56     12s] 	set main $f
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$scrollbars == "both"} {
[05/05 14:53:56     12s] 		eval text $main.txt $args \
[05/05 14:53:56     12s] 			-yscroll {[list dynsbar2::scrollSet [list grid $main.vt -row 0 -column 1 -sticky ns]]} \
[05/05 14:53:56     12s] 			-xscroll {[list dynsbar2::scrollSet [list grid $main.hz -row 1 -column 0 -sticky we]]}
[05/05 14:53:56     12s] 		scrollbar $main.vt -orient verti -command "$main.txt yview"
[05/05 14:53:56     12s] 		scrollbar $main.hz -orient horiz -command "$main.txt xview"
[05/05 14:53:56     12s] 	} elseif {$scrollbars == "vt"} {
[05/05 14:53:56     12s] 		eval text $main.txt $args \
[05/05 14:53:56     12s] 			-yscroll {[list dynsbar2::scrollSet [list grid $main.vt -row 0 -column 1 -sticky ns]]}
[05/05 14:53:56     12s] 		scrollbar $main.vt -command "$main.txt yview"
[05/05 14:53:56     12s] 	} elseif {$scrollbars == "hz"} {
[05/05 14:53:56     12s] 		eval text $main.txt $args \
[05/05 14:53:56     12s] 			-xscroll {[list dynsbar2::scrollSet [list grid $main.hz -row 1 -column 0 -sticky we]]}
[05/05 14:53:56     12s] 		scrollbar $main.hz -orient horiz -command "$main.txt xview"
[05/05 14:53:56     12s] 	} elseif {$scrollbars == "none"} {
[05/05 14:53:56     12s] 		eval text $main.txt $args
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return {}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s] 	grid $main.txt -row 0 -column 0 -sticky news
[05/05 14:53:56     12s] 	grid rowconfig $main 0 -weight 1
[05/05 14:53:56     12s] 	grid columnconfig $main 0 -weight 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $main.txt
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] #################################################################
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # uiprocs_PositionWindow -- Positions a window relative to the
[05/05 14:53:56     12s] #                     specified parent.
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] # Arguments:
[05/05 14:53:56     12s] #    <w>      = Window to be positioned
[05/05 14:53:56     12s] #    <parent> = Parent window it should be relative to
[05/05 14:53:56     12s] #    [mode]   = Defines relative position to parent
[05/05 14:53:56     12s] #    [showit] = Show window after setting geometry?
[05/05 14:53:56     12s] #
[05/05 14:53:56     12s] @proc uiprocs_PositionWindow {w parent {mode "center"} {showit {1}}} {
[05/05 14:53:56     12s]    global _ui_vars
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s]    # First we will withdraw the window so user
[05/05 14:53:56     12s]    # doesn't see repaints caused by geometry change
[05/05 14:53:56     12s]    wm withdraw $w
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s]    # Due to a problem in Tk4.x that exists on the PC, we must
[05/05 14:53:56     12s]    # force toplevel windows to be resizable for purposes of
[05/05 14:53:56     12s]    # letting Tk calculate geometry data. The effect of this
[05/05 14:53:56     12s]    # problem was that some dialogs would be sized incorrectly.
[05/05 14:53:56     12s]    set curr ""
[05/05 14:53:56     12s]    if {[winfo class $w] == "Toplevel"} {
[05/05 14:53:56     12s]       set curr [wm resizable $w] ;# save existing state
[05/05 14:53:56     12s]       wm resizable $w 1 1        ;# temporarily force resizable
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # It is critical that we "update" before
[05/05 14:53:56     12s]    # querying for geometry information
[05/05 14:53:56     12s]    update
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Now it's safe to restore the resizable state of "w"
[05/05 14:53:56     12s]    if {$curr != ""} { eval wm resizable $w $curr }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Get screen info
[05/05 14:53:56     12s]    set edge_right [winfo screenwidth .]
[05/05 14:53:56     12s]    set edge_bottom [winfo screenheight .]
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s]    # Get parent info.  We first check if it's a toplevel
[05/05 14:53:56     12s]    # window by seeing if we can get wm geometry info.  We
[05/05 14:53:56     12s]    # really only want the x/y values from the "wm geometry"
[05/05 14:53:56     12s]    # call since they take into account the window's frame.
[05/05 14:53:56     12s]    if {[catch {wm geometry $parent} geom] != 0} {
[05/05 14:53:56     12s]       # If it's not a toplevel window then get the
[05/05 14:53:56     12s]       # "root-relative" x/y values
[05/05 14:53:56     12s]       set p_x      [winfo rootx $parent]
[05/05 14:53:56     12s]       set p_y      [winfo rooty $parent]
[05/05 14:53:56     12s]    } else {
[05/05 14:53:56     12s]       scan $geom "%dx%d+%d+%d" width height p_x p_y
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    set p_width  [winfo width $parent]
[05/05 14:53:56     12s]    set p_height [winfo height $parent]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Get info for target window(if curr size info
[05/05 14:53:56     12s]    # is not yet known then we have to use "requested" info)
[05/05 14:53:56     12s]    set w_width  [winfo width $w]
[05/05 14:53:56     12s]    set w_height [winfo height $w]
[05/05 14:53:56     12s]    if {$w_width == 1} {
[05/05 14:53:56     12s]       set w_width  [winfo reqwidth $w]
[05/05 14:53:56     12s]       set w_height [winfo reqheight $w]
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    set x {}
[05/05 14:53:56     12s]    set y {}
[05/05 14:53:56     12s]    switch $mode {
[05/05 14:53:56     12s]       "center" {
[05/05 14:53:56     12s]          set x [expr {$p_x + ($p_width/2) - ($w_width/2)}]
[05/05 14:53:56     12s]          set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/05 14:53:56     12s]          # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]          if {$x < 0} { set x 0 } \
[05/05 14:53:56     12s]          elseif {[expr {$x + $w_width + (2* $_ui_vars(wmframeW))}] > $edge_right} {
[05/05 14:53:56     12s]             set x [expr {$x - ($x + $w_width + (2* $_ui_vars(wmframeW)) - $edge_right)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {$y < 0} { set y 0 }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       "bottom" {
[05/05 14:53:56     12s]          set x $p_x
[05/05 14:53:56     12s]          set y [expr {$p_y + $p_height}]
[05/05 14:53:56     12s]          # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]          if {$x < 0} {set x 0} \
[05/05 14:53:56     12s]          elseif {[expr {$x + $w_width + (2* $_ui_vars(wmframeW))}] > $edge_right} {
[05/05 14:53:56     12s]             set x [expr {$x - ($x + $w_width + (2* $_ui_vars(wmframeW)) - $edge_right)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {$y < 0} { set y 0 } \
[05/05 14:53:56     12s]          elseif {[expr {$y + $w_height}] > $edge_bottom} {
[05/05 14:53:56     12s]             incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          # Check if we need to account for window manager decoration frame width
[05/05 14:53:56     12s]          if {($parent == ".") || \
[05/05 14:53:56     12s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/05 14:53:56     12s]             set y [expr {$y + $_ui_vars(wmframeH) + 5}] 
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       "screencenter" {
[05/05 14:53:56     12s]          set x [expr {($edge_right/2) - ($w_width/2)}]
[05/05 14:53:56     12s]          set y [expr {($edge_bottom/2) - ($w_height/2)}]
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       "right" -
[05/05 14:53:56     12s]       "righttop" -
[05/05 14:53:56     12s]       "rightmiddle" -
[05/05 14:53:56     12s]       "rightbottom" {
[05/05 14:53:56     12s]          set x [expr {$p_x + $p_width}]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]          # Check if we need to account for window manager decoration frame width
[05/05 14:53:56     12s]          if {($parent == ".") || \
[05/05 14:53:56     12s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/05 14:53:56     12s]             set x [expr {$x + (2* $_ui_vars(wmframeW)) + 2}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {[expr {$x + $w_width}] > $edge_right} {
[05/05 14:53:56     12s]             # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]             set x [expr {$x - ($x + $w_width - $edge_right)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {($mode == "right") || ($mode == "righttop")} {
[05/05 14:53:56     12s]             set y [expr {$p_y}]
[05/05 14:53:56     12s]          } elseif {$mode == "rightmiddle"} {
[05/05 14:53:56     12s]             set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/05 14:53:56     12s]          } elseif {$mode == "rightbottom"} {
[05/05 14:53:56     12s]             set y [expr {$p_y + $p_height - $w_height}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       "left" {
[05/05 14:53:56     12s]          set x [expr {$p_x - $w_width}]
[05/05 14:53:56     12s]          set y $p_y
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]          # Check if we need to account for window manager decoration frame width
[05/05 14:53:56     12s]          if {($parent == ".") || \
[05/05 14:53:56     12s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/05 14:53:56     12s]             set x [expr {$x - (2* $_ui_vars(wmframeW)) - 2}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]          if {$x < 0} { set x 0 }
[05/05 14:53:56     12s]          if {$y < 0} { set y 0 } \
[05/05 14:53:56     12s]          elseif {[expr {$y + $w_height}] > $edge_bottom} {
[05/05 14:53:56     12s]             incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       "straddleright" -
[05/05 14:53:56     12s]       "straddlerightbottom" {
[05/05 14:53:56     12s]          set x [expr {$p_x + $p_width - ($w_width / 2)}]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]          # Check if we need to account for window manager decoration frame width
[05/05 14:53:56     12s]          if {($parent == ".") || \
[05/05 14:53:56     12s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/05 14:53:56     12s]             set x [expr {$x + $_ui_vars(wmframeW) + 1}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {[expr {$x + $w_width}] > $edge_right} {
[05/05 14:53:56     12s]             # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]             set x [expr {$x - ($x + $w_width - $edge_right)}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          if {$mode == "straddleright"} {
[05/05 14:53:56     12s]             set y [expr {$p_y + ($p_height/2) - ($w_height/2)}]
[05/05 14:53:56     12s]          } else {
[05/05 14:53:56     12s]             set y [expr {$p_y + $p_height - ($w_height/2)}]
[05/05 14:53:56     12s]             
[05/05 14:53:56     12s]             # Adjust so window doesn't go off the screen
[05/05 14:53:56     12s]             if {[expr {$y + $w_height}] > $edge_bottom} {
[05/05 14:53:56     12s]                incr y [expr {$edge_bottom - ($y + $w_height)}]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]          # Check if we need to account for window manager decoration frame width
[05/05 14:53:56     12s]          if {($parent == ".") || \
[05/05 14:53:56     12s]              [regexp {Toplevel|FileViewer|ReportViewer} [winfo class $parent]]} {
[05/05 14:53:56     12s]             set y [expr {$y - $_ui_vars(wmframeH) - 2}]
[05/05 14:53:56     12s]          }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    
[05/05 14:53:56     12s]    wm geometry $w +$x+$y
[05/05 14:53:56     12s]    if {$_ui_vars(IsPC)} {
[05/05 14:53:56     12s]       update idletasks     ;# required on pc to get positioning to occur
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Now we can show the window(if requested)
[05/05 14:53:56     12s]    if {$showit == 1} {
[05/05 14:53:56     12s]       wm deiconify $w
[05/05 14:53:56     12s]       #raise $w
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # Dynamic scrolling, take two . . . 
[05/05 14:53:56     12s] @namespace eval dynsbar2 {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	namespace export scrollSet hierScrollSet
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc scrollSet {pcmd first last} {
[05/05 14:53:56     12s] 		ScrollSet $pcmd $first $last
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# hier adheres to old scrolling set subcommand format
[05/05 14:53:56     12s] 	proc hierScrollSet {pcmd tU wU fU lU} {
[05/05 14:53:56     12s] 		incr tU -1 ; # Bug in hw_hier.c? Gives us one more than the number of rows.
[05/05 14:53:56     12s] 		if {$tU==0} {
[05/05 14:53:56     12s] 			set first 0.0
[05/05 14:53:56     12s] 			set last 1.0
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			set first [expr {double($fU) / $tU}]
[05/05 14:53:56     12s] 			set last  [expr {double($lU) / $tU}]
[05/05 14:53:56     12s] 			if {$first<0.0} {set first 0.0}
[05/05 14:53:56     12s] 			if {$last>1.0} {set last 1.0}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		ScrollSet $pcmd $first $last
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc ScrollSet {pcmd first last} {
[05/05 14:53:56     12s] 		set sbar [lindex $pcmd 1]
[05/05 14:53:56     12s] 		$sbar set $first $last
[05/05 14:53:56     12s] 		if {($first!=$last) && (($first>0) || (($last>0) && ($last<1)))} {
[05/05 14:53:56     12s] 			eval $pcmd
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @namespace eval mgc_enc {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	variable cmap
[05/05 14:53:56     12s]     variable hlTextObjs
[05/05 14:53:56     12s]     variable hlEdgeObjs
[05/05 14:53:56     12s]     variable hlPolyObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(ENV_VARNAME) "MGC_CALIBRE_LAYOUT_SERVER"
[05/05 14:53:56     12s] 	set env(MGC_CALIBRE_LAYOUT_SERVER_NAME) "Cadence:Encounter"
[05/05 14:53:56     12s] 	set env(MGC_CGI_MONITOR_STDIN) 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # Turn on support for shorthand text highlight command
[05/05 14:53:56     12s]     set env(MGC_RVE_HILIGHT_SHORT_TEXT_CMDS) 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(DEFAULT_PORT) 9189
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(RFILE_BUSY) 0
[05/05 14:53:56     12s] 	set vars(hl_objects) {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(hl_layer) "rve_0"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(hl_layer_basen) rve
[05/05 14:53:56     12s] 	set vars(hl_layer_index) 0
[05/05 14:53:56     12s] 	set vars(max_hl_layer) 0
[05/05 14:53:56     12s] 	set vars(got_show_layers) 0
[05/05 14:53:56     12s] 	set vars(show_layers_lsw_is_current) 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(server_sid) ""
[05/05 14:53:56     12s] 	set vars(last_client_sid) ""
[05/05 14:53:56     12s] 	set vars(client_sockets)    {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(SRANGE_START) 5000
[05/05 14:53:56     12s] 	set vars(SRANGE_END)   9999
[05/05 14:53:56     12s] 	set vars(socket_number) -1
[05/05 14:53:56     12s] 	set vars(socket_host)   ""
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set vars(runcode_version) 4.4
[05/05 14:53:56     12s]     set vars(protocol_version) 4.6
[05/05 14:53:56     12s]     set vars(optionalCommands) [list    \
[05/05 14:53:56     12s]         "mgc_rve_get_poly"              \
[05/05 14:53:56     12s]     ]
[05/05 14:53:56     12s]     set vars(CI_trigger_keys) [list]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     variable userCmds
[05/05 14:53:56     12s]     array set userCmds {}
[05/05 14:53:56     12s]     set vars(userCmdIdx) 0
[05/05 14:53:56     12s]     set vars(menuCmds) [list]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     array set hlTextObjs {}
[05/05 14:53:56     12s]     array set hlEdgeObjs {}
[05/05 14:53:56     12s]     array set hlPolyObjs {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# Name Other is intended for -stippleData option in setLayerPreference, we don't support it here since it don't have stipple name 
[05/05 14:53:56     12s] 	set vars(rve_supported_patterns) [list None Solid Horizontal Vertical Grid Slash Backslash Cross Brick Other]
[05/05 14:53:56     12s] 	set vars(OptionsFile) ".rveencdb"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	foreach type {"GDS" "Verilog" "DEF"} {
[05/05 14:53:56     12s] 		if {![info exists vars(exportOptions$type)]} {
[05/05 14:53:56     12s] 			set vars(exportOptions$type) ""
[05/05 14:53:56     12s]             if {$type eq "Verilog"} {
[05/05 14:53:56     12s]                 if {[info exists env(MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE)]} {
[05/05 14:53:56     12s]                     set vlog_cnfig_file $env(MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE)
[05/05 14:53:56     12s]                     if {[file exists $vlog_cnfig_file]} {
[05/05 14:53:56     12s]                         if {![catch {set rf [open $vlog_cnfig_file r]}]} {
[05/05 14:53:56     12s]                             set vars(exportOptionsVerilog) [read $rf]
[05/05 14:53:56     12s]                             close $rf
[05/05 14:53:56     12s]                         } else {
[05/05 14:53:56     12s]                             puts "Can't open MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE \"$vlog_cnfig_file\" for reading"
[05/05 14:53:56     12s]                         }
[05/05 14:53:56     12s]                     } else {
[05/05 14:53:56     12s]                         puts "Can't find MGC_CALIBRE_VERILOG_EXPORT_PARAM_FILE \"$vlog_cnfig_file\""
[05/05 14:53:56     12s]                     }
[05/05 14:53:56     12s]                 }
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		if {![info exists vars(showDlgRunTime$type)]} {
[05/05 14:53:56     12s] 			set vars(showDlgRunTime$type) 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::initRveHighlightPatterns {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	for {set i 0} {$i<16} {incr i} {
[05/05 14:53:56     12s] 		set vars(rve_${i}_color)    red
[05/05 14:53:56     12s] 		set vars(rve_${i}_pattern) None
[05/05 14:53:56     12s] 		set vars(rve_${i}_selectable) 1
[05/05 14:53:56     12s] 		set vars(rve_${i}_width)      1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if { [lsearch [package names] BLT]<0 } {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# 16X16 named bitmap patterns supported in Encounter
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_None {
[05/05 14:53:56     12s] 		#define none16x16_width 16
[05/05 14:53:56     12s] 		#define none16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char none16x16_bits[] = {
[05/05 14:53:56     12s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/05 14:53:56     12s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/05 14:53:56     12s] 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Solid {
[05/05 14:53:56     12s] 		#define solid16x16_width 16
[05/05 14:53:56     12s] 		#define solid16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char solid16x16_bits[] = {
[05/05 14:53:56     12s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
[05/05 14:53:56     12s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
[05/05 14:53:56     12s] 			0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Horizontal {
[05/05 14:53:56     12s] 		#define horizontal16x16_width 16
[05/05 14:53:56     12s] 		#define horizontal16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char horizontal16x16_bits[] = {
[05/05 14:53:56     12s] 			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
[05/05 14:53:56     12s] 			0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
[05/05 14:53:56     12s] 			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Vertical {
[05/05 14:53:56     12s] 		#define vertical16x16_width 16
[05/05 14:53:56     12s] 		#define vertical16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char vertical16x16_bits[] = {
[05/05 14:53:56     12s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
[05/05 14:53:56     12s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
[05/05 14:53:56     12s] 			0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Grid {
[05/05 14:53:56     12s] 		#define grid16x16_width 16
[05/05 14:53:56     12s] 		#define grid16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char grid16x16_bits[] = {
[05/05 14:53:56     12s] 			0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00,
[05/05 14:53:56     12s] 			0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
[05/05 14:53:56     12s] 			0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Slash {
[05/05 14:53:56     12s] 		#define slash16x16_width 16
[05/05 14:53:56     12s] 		#define slash16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char slash16x16_bits[] = {
[05/05 14:53:56     12s] 			0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11, 0x88, 0x88, 0x44, 0x44,
[05/05 14:53:56     12s] 			0x22, 0x22, 0x11, 0x11, 0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11,
[05/05 14:53:56     12s] 			0x88, 0x88, 0x44, 0x44, 0x22, 0x22, 0x11, 0x11};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Backslash {
[05/05 14:53:56     12s] 		#define backslash16x16_width 16
[05/05 14:53:56     12s] 		#define backslash16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char backslash16x16_bits[] = {
[05/05 14:53:56     12s] 			0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22,
[05/05 14:53:56     12s] 			0x44, 0x44, 0x88, 0x88, 0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88,
[05/05 14:53:56     12s] 			0x11, 0x11, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Cross {
[05/05 14:53:56     12s] 		#define cross16x16_width 16
[05/05 14:53:56     12s] 		#define cross16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char cross16x16_bits[] = {
[05/05 14:53:56     12s] 			0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99, 0x99, 0x99, 0x66, 0x66,
[05/05 14:53:56     12s] 			0x66, 0x66, 0x99, 0x99, 0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99,
[05/05 14:53:56     12s] 			0x99, 0x99, 0x66, 0x66, 0x66, 0x66, 0x99, 0x99};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	blt::bitmap define ::mgc_enc::Pattern_Brick {
[05/05 14:53:56     12s] 		#define brick16x16_width 16
[05/05 14:53:56     12s] 		#define brick16x16_height 16
[05/05 14:53:56     12s] 		static unsigned char brick16x16_bits[] = {
[05/05 14:53:56     12s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
[05/05 14:53:56     12s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff, 0x88, 0x88, 0x88, 0x88,
[05/05 14:53:56     12s] 			0xff, 0xff, 0x22, 0x22, 0x22, 0x22, 0xff, 0xff};
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	set vars(rve_pattern_loaded) 1
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] } ;
[05/05 14:53:56     12s] # mgc_enc::loadRveFillPatterns
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::rve_highlight_pattern_changed {i c menuBtn name1 name2 op} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set sPattern $vars(rve_${i}_pattern)
[05/05 14:53:56     12s] 	$c delete all ;# clean up the canvas
[05/05 14:53:56     12s] 	set cw [$c cget -width]
[05/05 14:53:56     12s] 	set ch [$c cget -height]
[05/05 14:53:56     12s] 	set width 1
[05/05 14:53:56     12s] 	if { [info exists vars(rve_${i}_width)] && [string is integer -strict $vars(rve_${i}_width)] } {
[05/05 14:53:56     12s] 		set width $vars(rve_${i}_width)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set color red
[05/05 14:53:56     12s] 	if { [info exists vars(rve_${i}_color)] } {
[05/05 14:53:56     12s] 		set color $vars(rve_${i}_color)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set item [$c create rectangle 1 1 $cw $ch -width $width -outline $color -fill $color]
[05/05 14:53:56     12s] 	if { [info exists vars(rve_pattern_loaded)] && $sPattern!="Other" } {
[05/05 14:53:56     12s] 		$c itemconfigure $item -stipple ::mgc_enc::Pattern_$sPattern
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::rve_choose_color {i} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set color [tk_chooseColor -initialcolor red -title "Choose highlight color for rve_$i"]
[05/05 14:53:56     12s] 	if { $color!="" } {
[05/05 14:53:56     12s] 		set vars(rve_${i}_color) $color
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setExportOptions {type options show_dlg_at_runtime} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(exportOptions$type) $options
[05/05 14:53:56     12s] 	set vars(showDlgRunTime$type) $show_dlg_at_runtime
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getExportOptions {type} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lOptions [list $vars(exportOptions$type) $vars(showDlgRunTime$type)]
[05/05 14:53:56     12s] 	return $lOptions
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ShowError {err} {
[05/05 14:53:56     12s] 	puts stderr $err
[05/05 14:53:56     12s] 	uimessage_Error . "Calibre Error: $err"
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ShowNote {msg} {
[05/05 14:53:56     12s] 	uimessage_Note . $msg
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::TranscriptMessage {msg} {
[05/05 14:53:56     12s] 	puts stdout $msg
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SendCmdToClient {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set last_client $vars(last_client_sid)
[05/05 14:53:56     12s] 	if {$last_client!=""} {
[05/05 14:53:56     12s] 		catch {puts $last_client "$args\n"} msg
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetReturnVal {bool} {
[05/05 14:53:56     12s] 	return $bool
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::DesignLoaded {{show_msg 0}} {
[05/05 14:53:56     12s] 	if {[getTopCell]==0} {
[05/05 14:53:56     12s] 		if {$show_msg} {
[05/05 14:53:56     12s] 			mgc_enc::ShowNote "No design loaded!"
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			error "No design loaded!"
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckCellMapping {rvecell editcell msg} {
[05/05 14:53:56     12s] 	variable cmap
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set map_cell $rvecell
[05/05 14:53:56     12s] 	if {[info exists cmap($rvecell)]} {
[05/05 14:53:56     12s] 		set map_cell $cmap($rvecell)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[string compare $map_cell $editcell]} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if {![uimessage_YesNo . $msg]} {
[05/05 14:53:56     12s] 			return 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set cmap($rvecell) $editcell
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckHighlightContext {fname editcell {is_import 0}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set f [open $fname r]
[05/05 14:53:56     12s] 	set line1 [split [gets $f]]
[05/05 14:53:56     12s] 	set line2 [gets $f]
[05/05 14:53:56     12s] 	close $f
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[string compare [lindex $line1 0] "mgc_rve_context"]==0} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set fcell [string trim [lindex $line1 1] "\""]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if {$is_import} {
[05/05 14:53:56     12s] 			set msg "Import data from RVE cell \"${fcell}\"\ninto Encounter cell \"${editcell}\"?"
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			set msg "Show highlights from RVE cell \"${fcell}\"\nin Encounter cell \"${editcell}\"?"
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if {![CheckCellMapping $fcell $editcell $msg]} {
[05/05 14:53:56     12s] 			return [SetReturnVal 0]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {!$is_import} {
[05/05 14:53:56     12s] 		set reset 0
[05/05 14:53:56     12s] 		if {$line2=="mgc_rve_delete_markers"} {
[05/05 14:53:56     12s] 			set reset 1
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		setHighlightColor $reset
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return [SetReturnVal 1]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckExportContext {rvecell editcell} {
[05/05 14:53:56     12s] 	if {![CheckCellMapping $rvecell $editcell "Export Encounter cell \"${editcell}\"\nas Calibre cell \"${rvecell}\"?"]} {
[05/05 14:53:56     12s] 		return [SetReturnVal 0]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return [SetReturnVal 1]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CloseClientSockets {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	foreach client_sid $vars(client_sockets) {
[05/05 14:53:56     12s] 		if {$client_sid!=""} {
[05/05 14:53:56     12s] 			close $client_sid
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(client_sockets) {}
[05/05 14:53:56     12s] 	set vars(last_client_sid) ""
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CloseClientSocket {cid} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	close $cid
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set newlist {}
[05/05 14:53:56     12s] 	foreach client_sid $vars(client_sockets) {
[05/05 14:53:56     12s] 		if {$client_sid!=$cid} {
[05/05 14:53:56     12s] 			lappend newlist $client_sid
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(client_sockets) $newlist
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$cid==$vars(last_client_sid)} {
[05/05 14:53:56     12s] 		set vars(last_client_sid) ""
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CloseServerSocket {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	if {$vars(server_sid)!=""} {
[05/05 14:53:56     12s] 		close $vars(server_sid)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(server_sid) ""
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CloseServer {} {
[05/05 14:53:56     12s] 	CloseClientSockets
[05/05 14:53:56     12s] 	CloseServerSocket
[05/05 14:53:56     12s] 	exit 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::AutoSeekSocket {{host ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	
[05/05 14:53:56     12s] 	set s_start $vars(SRANGE_START)
[05/05 14:53:56     12s] 	set s_end   $vars(SRANGE_END)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set host [string trim $host]
[05/05 14:53:56     12s] 	set retval 1
[05/05 14:53:56     12s] 	for {set i $s_start} {$i <= $s_end} {incr i} {
[05/05 14:53:56     12s] 	    if { $host eq "" } {
[05/05 14:53:56     12s] 		if { [IsPortAvailable $i] } {
[05/05 14:53:56     12s] 			set retval [catch {socket -server mgc_enc::AcceptConnection $i} vars(server_sid)]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	    } else {
[05/05 14:53:56     12s] 		set retval [catch {socket -myaddr $host -server mgc_enc::AcceptConnection $i} vars(server_sid)]
[05/05 14:53:56     12s] 	    }
[05/05 14:53:56     12s] 	    if { $retval==0 } { return $i }
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(server_sid) ""
[05/05 14:53:56     12s] 	if { $host eq "" } { set host "localhost" }
[05/05 14:53:56     12s] 	set msg "Could not initialize layout server socket\non $host at any port between $s_start and $s_end.\n\nPlease specify a different socket number or host name\nby using the command:\n\nmgc_enc::initServerSocket <port_number> \[host_name\]\n"
[05/05 14:53:56     12s] 	if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/05 14:53:56     12s] 		append msg "\nRealTime will be disabled!"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	ShowError $msg
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] #-------------------------------------------------------------------------------
[05/05 14:53:56     12s] # DR1273859/1374383/1376672: Need to ensure no other socket connection is listening on network addresses for this port
[05/05 14:53:56     12s] #-------------------------------------------------------------------------------
[05/05 14:53:56     12s] @proc mgc_enc::IsPortAvailable {portNum} {
[05/05 14:53:56     12s] 	set netaddr "127.0.0.1"   ;# not localhost as this may resolve to ipv6 ::1 and successfully connect when 127.0.0.1:port is in use
[05/05 14:53:56     12s] 	set retval [catch {socket -myaddr $netaddr -server mgc_enc::AcceptConnection $portNum} sid]
[05/05 14:53:56     12s] 	if { $retval==0 } {
[05/05 14:53:56     12s] 		close $sid
[05/05 14:53:56     12s] 		set retval [catch {socket -myaddr [info hostname] -server mgc_enc::AcceptConnection $portNum} sid]
[05/05 14:53:56     12s] 		if { $retval==0 } {
[05/05 14:53:56     12s] 			close $sid
[05/05 14:53:56     12s] 			return 1
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::OnServerChangeEvent {PreOrPost host portNum} {
[05/05 14:53:56     12s] 	if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/05 14:53:56     12s] 		if { [info procs ::calibre::realtime::${PreOrPost}EncServerChangeEvent]!="" } {
[05/05 14:53:56     12s] 			::calibre::realtime::${PreOrPost}EncServerChangeEvent $host $portNum
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CreateServerSocket {portNum {host ""} {autoSeek 1}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if { $portNum=="" || [regexp "\[^0-9\]+" $portNum] } {
[05/05 14:53:56     12s] 		ShowError "Invalid port-number specified ($portNum)."
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# Notify RealTime server to prevent it from exiting.
[05/05 14:53:56     12s] 	OnServerChangeEvent "Pre" $vars(socket_host) $vars(socket_number)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	CloseClientSockets
[05/05 14:53:56     12s] 	CloseServerSocket
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set announce_number 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set host [string trim $host]
[05/05 14:53:56     12s] 	set retval 1
[05/05 14:53:56     12s] 	if { $host eq "" } {
[05/05 14:53:56     12s] 		if { [IsPortAvailable $portNum] } {
[05/05 14:53:56     12s] 			set retval [catch {socket -server mgc_enc::AcceptConnection $portNum} vars(server_sid)]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		set retval [catch {socket -myaddr $host -server mgc_enc::AcceptConnection $portNum} vars(server_sid)]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	if {$retval} {
[05/05 14:53:56     12s] 		set vars(server_sid) ""
[05/05 14:53:56     12s] 		if {!$autoSeek} {
[05/05 14:53:56     12s] 			set msg "Could not initialize layout server socket\nat $host:$portNum.\n\nPlease specify a different socket number or host name\nby using the command:\n\nmgc_enc::initServerSocket <port_number> \[host_name\]\n"
[05/05 14:53:56     12s] 			if { [info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)] } {
[05/05 14:53:56     12s] 				append msg "\nRealTime will be disabled!"
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 			ShowError $msg
[05/05 14:53:56     12s] 			OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/05 14:53:56     12s] 			return 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set msg "Could not initialize Calibre layout-server socket at $host:$portNum. Trying to find free socket ..."
[05/05 14:53:56     12s] 		TranscriptMessage $msg
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set portNum [AutoSeekSocket $host]
[05/05 14:53:56     12s] 		if {$portNum==0} {
[05/05 14:53:56     12s] 			OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/05 14:53:56     12s] 			return 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set announce_number 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if { $host eq "" } {
[05/05 14:53:56     12s] 	    set msg "Calibre layout-server initialized successfully at socket localhost:$portNum"
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 	    set msg "Calibre layout-server initialized successfully at socket $host:$portNum"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	TranscriptMessage $msg
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set env($vars(ENV_VARNAME)) "$host:$portNum"
[05/05 14:53:56     12s] 	if { ![info exists env(MGC_CALIBRE_SCHEMATIC_SERVER)] } {
[05/05 14:53:56     12s] 	    set env(MGC_CALIBRE_SCHEMATIC_SERVER) "$host:$portNum"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(socket_host) $host
[05/05 14:53:56     12s] 	set vars(socket_number) $portNum
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# ER1202567: Innovus RealTime Step 1: Create Infrastructures
[05/05 14:53:56     12s] 	OnServerChangeEvent "Post" $vars(socket_host) $vars(socket_number)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::GetDefaultSocket {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set host ""
[05/05 14:53:56     12s] 	if {[info exists env($vars(ENV_VARNAME))]} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set layout_env $env($vars(ENV_VARNAME))
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if {$layout_env==""} {
[05/05 14:53:56     12s] 			# don't initialize the server socket!
[05/05 14:53:56     12s] 			set msg "Environment variable MGC_CALIBRE_LAYOUT_SERVER is set to blank."
[05/05 14:53:56     12s] 			TranscriptMessage $msg
[05/05 14:53:56     12s] 			return 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set colon_index [string first ":" $layout_env]
[05/05 14:53:56     12s]         if {$colon_index==-1} {
[05/05 14:53:56     12s]             set layout_port $layout_env
[05/05 14:53:56     12s]         } elseif {$colon_index==0} {
[05/05 14:53:56     12s]             set layout_port [string range $layout_env 1 end]
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set host [string range $layout_env 0 [expr {$colon_index-1}]]
[05/05 14:53:56     12s]             set layout_port [string range $layout_env [expr {$colon_index+1}] end]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if { $layout_port=="" || [regexp "\[^0-9\]+" $layout_port] } {
[05/05 14:53:56     12s] 			set msg "Invalid port-number specified ($layout_port).\nPlease set environment-variable\n$vars(ENV_VARNAME)\nto <hostname>:<socket number>."
[05/05 14:53:56     12s] 			ShowError $msg
[05/05 14:53:56     12s] 			return -1
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		
[05/05 14:53:56     12s] 		return [list $host $layout_port]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return [list $host $vars(DEFAULT_PORT)]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::initServerSocket {{portNum ""} {host ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set autoSeek 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if { $vars(socket_number)==$portNum && $vars(socket_host)==$host && $vars(server_sid)!="" } {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$portNum=="" || $portNum<=0} {
[05/05 14:53:56     12s] 		set lHostPort [GetDefaultSocket]
[05/05 14:53:56     12s] 		set host    [lindex $lHostPort 0]
[05/05 14:53:56     12s] 		set portNum [lindex $lHostPort 1]
[05/05 14:53:56     12s] 		if {$portNum<=0} {
[05/05 14:53:56     12s] 			# either don't init socket or error in port specification
[05/05 14:53:56     12s] 			return 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set autoSeek 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return [CreateServerSocket $portNum $host $autoSeek]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::AcceptConnection {cid addr port} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	fileevent $cid readable "mgc_enc::ProcessClientInput $cid"
[05/05 14:53:56     12s] 	fconfigure $cid -buffering line -blocking 0
[05/05 14:53:56     12s] 	set vars(last_client_sid) $cid
[05/05 14:53:56     12s] 	lappend vars(client_sockets) $cid
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # Initial acceptance notification
[05/05 14:53:56     12s]     set lElem [fconfigure $cid -sockname]
[05/05 14:53:56     12s]     set hostName [lindex $lElem 1]
[05/05 14:53:56     12s]     set portNum  [lindex $lElem 2]
[05/05 14:53:56     12s]     if { $hostName=="localhost" || $hostName=="localhost.localdomain" } {
[05/05 14:53:56     12s]         set hostName [info hostname] ;# do NOT use localhost as hostName, it doesn't work across different machines
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set viewerName Cadence:Encounter
[05/05 14:53:56     12s]     set display [getDisplayEnvVar]
[05/05 14:53:56     12s]     set featureList "language Tcl runcode $vars(runcode_version)"
[05/05 14:53:56     12s]     foreach cmd $vars(optionalCommands) {
[05/05 14:53:56     12s]         append featureList " $cmd 1"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     eval SendCmdToClient viewer_connected $hostName $portNum $display $viewerName $vars(protocol_version) $featureList
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::calculateTriggerKey {} {
[05/05 14:53:56     12s]     set key [clock seconds]
[05/05 14:53:56     12s]     set mod [expr {$key%10000}]
[05/05 14:53:56     12s]     set key [string range [expr {$key-([pid]*$mod)}] 4 end]
[05/05 14:53:56     12s]     return $key
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # handles client communication: processes input received from RVE
[05/05 14:53:56     12s] @proc mgc_enc::ProcessClientInput {cid} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[gets $cid request] < 0} {
[05/05 14:53:56     12s] 		if { [eof $cid] } {
[05/05 14:53:56     12s] 			CloseClientSocket $cid
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		# process the incoming request
[05/05 14:53:56     12s] 		set old_socket $vars(last_client_sid)
[05/05 14:53:56     12s] 		# ProcessCmd can cause us to try to send something across
[05/05 14:53:56     12s] 		# the socket.  Make sure we talk to the right socket.
[05/05 14:53:56     12s] 		set vars(last_client_sid) $cid
[05/05 14:53:56     12s] 		# 1st send the incoming request to RealTime server
[05/05 14:53:56     12s] 		if {[info exists ::env(MGC_REALTIME_INNOVUS_ENABLED)]} {
[05/05 14:53:56     12s] 			if { [ProcessRealTimeInput $cid $request] } {
[05/05 14:53:56     12s] 				return
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		if {[ProcessCmd $request]} {
[05/05 14:53:56     12s] 			#set vars(last_client_sid) $cid
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			set vars(last_client_sid) $old_socket
[05/05 14:53:56     12s] 			ShowError "Invalid command: \"$request\""
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ProcessRealTimeInput {cid request} {
[05/05 14:53:56     12s] 	# DR1280729: Virtuoso using 100% CPU caused by Mentor's Calibre not able to handle infosec security scan
[05/05 14:53:56     12s] 	# direct usage of [lindex $requst 0] with invalid input can cause Tcl error,
[05/05 14:53:56     12s] 	# set request "R.7 {@ At least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 Die}" ;# remove closing brace 
[05/05 14:53:56     12s] 	#   lindex $request 0 => unmatched open brace in list
[05/05 14:53:56     12s] 	# split can avoid such issue.
[05/05 14:53:56     12s] 	#   split $request => R.7 \{@ At least 8 OVL_PO_ODs and 8 OVL_CO_POs for 1X1 Die
[05/05 14:53:56     12s] 	set lCmds [split $request]
[05/05 14:53:56     12s] 	set cmd [lindex $lCmds 0]
[05/05 14:53:56     12s] 	# ? matches zero or one instance of previous pattern
[05/05 14:53:56     12s] 	# regexp {^(::)?calibre::realtime::*}   calibre::realtime::cmd => 1
[05/05 14:53:56     12s] 	# regexp {^(::)?calibre::realtime::*} ::calibre::realtime::cmd => 1
[05/05 14:53:56     12s] 	# regexp {^(::)?calibre::realtime::*}  :calibre::realtime::cmd => 0
[05/05 14:53:56     12s] 	if { [regexp {^(::)?calibre::realtime::*} $cmd] } {
[05/05 14:53:56     12s] 		# re-directed to RealTime Tcl code
[05/05 14:53:56     12s] 		# Typically, the cmd is ::calibre::realtime::CmdDispatcher
[05/05 14:53:56     12s] 		eval $cmd $cid [lrange $request 1 end]
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ProcessCmd {in_cmd} {
[05/05 14:53:56     12s] #	puts stdout "RVE: $in_cmd"
[05/05 14:53:56     12s] 	set cmd [split $in_cmd]
[05/05 14:53:56     12s] 	set c1 [lindex $cmd 0]
[05/05 14:53:56     12s] 	set rve_signature "mgc_rve_*"
[05/05 14:53:56     12s] 	if {[string match $rve_signature $c1]} {
[05/05 14:53:56     12s] 		return [ProcessRveCmd $in_cmd]
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		puts stdout "RVE: Rejecting unknown command"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ProcessRveCmd {cmdl} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [lindex $cmdl 0]
[05/05 14:53:56     12s] 	set args [lrange $cmdl 1 end]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	switch -- $cmd {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_rfile"	{
[05/05 14:53:56     12s] 			if {[llength $args]==1} {
[05/05 14:53:56     12s] 				set fname [lindex $args 0]
[05/05 14:53:56     12s] 			    return [$cmd $fname]
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_delete_markers" {
[05/05 14:53:56     12s] 			switch [llength $args] {
[05/05 14:53:56     12s] 				0 {
[05/05 14:53:56     12s] 					return [$cmd]
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 				1 {
[05/05 14:53:56     12s] 				    return [eval $cmd [lindex $args 0]]
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 				2 {
[05/05 14:53:56     12s] 					if {[CheckInteger [lindex $args 1]]} {
[05/05 14:53:56     12s] 						return [eval $cmd [lindex $args 0] [lindex $args 1]]
[05/05 14:53:56     12s] 					}
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_get_location" -
[05/05 14:53:56     12s] 		"mgc_rve_get_rectangle" -
[05/05 14:53:56     12s] 		"mgc_rve_get_poly" -
[05/05 14:53:56     12s] 		"mgc_rve_context" {
[05/05 14:53:56     12s] 			if {[llength $args]==2} {
[05/05 14:53:56     12s] 				set cell [lindex $args 0]
[05/05 14:53:56     12s] 				set precision [lindex $args 1]
[05/05 14:53:56     12s] 				if {[CheckInteger $precision]} {
[05/05 14:53:56     12s] 					return [$cmd $cell $precision]
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_zoom" {
[05/05 14:53:56     12s] 			if {[llength $args]==5} {
[05/05 14:53:56     12s] 				set llx [lindex $args 0]
[05/05 14:53:56     12s] 				set lly [lindex $args 1]
[05/05 14:53:56     12s] 				set urx [lindex $args 2]
[05/05 14:53:56     12s] 				set ury [lindex $args 3]
[05/05 14:53:56     12s] 				set zf  [lindex $args 4]
[05/05 14:53:56     12s] 				if {[CheckNumber $llx] && [CheckNumber $lly] && [CheckNumber $urx] && [CheckNumber $ury] && [CheckNumber $zf]} {
[05/05 14:53:56     12s] 					return [$cmd $llx $lly $urx $ury $zf]
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_snet" -
[05/05 14:53:56     12s] 		"mgc_rve_sinst" {
[05/05 14:53:56     12s] 			if {[llength $args]>=4} {
[05/05 14:53:56     12s] 				set cell [lindex $args 0]
[05/05 14:53:56     12s] 				set clear_hl [lindex $args 1]
[05/05 14:53:56     12s] 				set zfactor [lindex $args 2]
[05/05 14:53:56     12s] 				set nets [lrange $args 3 end]
[05/05 14:53:56     12s] 				if {[CheckNumber $zfactor] && [CheckInteger $clear_hl]} {
[05/05 14:53:56     12s] 					return [$cmd $cell $clear_hl $zfactor $nets]
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_probe_snet" -
[05/05 14:53:56     12s] 		"mgc_rve_probe_sinst" {
[05/05 14:53:56     12s] 			if {([llength $args]==1)} {
[05/05 14:53:56     12s] 				return [$cmd [lindex $args 0]]
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_export_layout" {
[05/05 14:53:56     12s] 			set alen [llength $args]
[05/05 14:53:56     12s] 			if {$alen==3 || $alen==7} {
[05/05 14:53:56     12s] 				set cell   [lindex $args 0]
[05/05 14:53:56     12s] 				set format [lindex $args 1]
[05/05 14:53:56     12s] 				set file   [lindex $args 2]
[05/05 14:53:56     12s] 				if {$alen==3} {
[05/05 14:53:56     12s] 					return [$cmd $cell $format $file]
[05/05 14:53:56     12s] 				} else {
[05/05 14:53:56     12s] 					set llx [lindex $args 3]
[05/05 14:53:56     12s] 					set lly [lindex $args 4]
[05/05 14:53:56     12s] 					set dx  [lindex $args 5]
[05/05 14:53:56     12s] 					set dy  [lindex $args 6]
[05/05 14:53:56     12s] 					if {[CheckNumber $llx] && [CheckNumber $lly] && [CheckNumber $dx] && [CheckNumber $dy]} {
[05/05 14:53:56     12s] 						return [$cmd $cell $format $file $llx $lly $dx $dy]
[05/05 14:53:56     12s] 					}
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_export_netlist" {
[05/05 14:53:56     12s] 			if {[llength $args]==3} {
[05/05 14:53:56     12s] 				set cell [lindex $args 0]
[05/05 14:53:56     12s] 				set format [lindex $args 1]
[05/05 14:53:56     12s] 				set file [lindex $args 2]
[05/05 14:53:56     12s] 				return [$cmd $cell $format $file]
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		"mgc_rve_import" {
[05/05 14:53:56     12s] 			if {[llength $args]==2} {
[05/05 14:53:56     12s] 				set fname [lindex $args 0]
[05/05 14:53:56     12s] 				set lname [lindex $args 1]
[05/05 14:53:56     12s] 				return [$cmd $fname $lname]
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s]         "mgc_rve_send_protocol_version" {
[05/05 14:53:56     12s]             if {[llength $args] == 4} {
[05/05 14:53:56     12s]                 foreach {prot_ver host port display} $args {break}
[05/05 14:53:56     12s]                 return [$cmd $prot_ver $host $port $display]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         "mgc_rve_run_viewer_code" {
[05/05 14:53:56     12s]             if {[llength $args] > 2} {
[05/05 14:53:56     12s]                 set key [lindex $args 0]
[05/05 14:53:56     12s]                 set viewerType [lindex $args 1]
[05/05 14:53:56     12s]                 return [eval $cmd $key $viewerType [lrange $args 2 end]]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         "mgc_rve_get_version_for_feature" {
[05/05 14:53:56     12s]             if {[llength $args] == 1} {
[05/05 14:53:56     12s]                 set feature [lindex $args 0]
[05/05 14:53:56     12s]                 return [$cmd $feature]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts stdout "RVE: Rejecting improperly formatted command"
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_get_version_for_feature {feature} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$feature eq "runcode"} {
[05/05 14:53:56     12s]         SendCmdToClient layout_data_ready $vars(runcode_version)
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         SendCmdToClient layout_data_ready 0.0
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_run_viewer_code {key viewerType args} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set runMe 0
[05/05 14:53:56     12s]     if {[info exists ::env(MGC_CALIBRE_ALLOW_VIEWER_TRIGGERS)]} {
[05/05 14:53:56     12s]         set runMeStr $::env(MGC_CALIBRE_ALLOW_VIEWER_TRIGGERS)
[05/05 14:53:56     12s]         if {[string toupper $runMeStr] eq "ALWAYS"} {
[05/05 14:53:56     12s]             set runMe 1
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             ShowError "Viewer triggers are not allowed in this Encounter process"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     } elseif {[lsearch -exact $vars(CI_trigger_keys) $key] != -1} {
[05/05 14:53:56     12s]         set runMe 1
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         ShowError "Viewer triggers are allowed only in Calibre Interactive processes started from Encounter"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$viewerType eq "schematic"} {
[05/05 14:53:56     12s]         set retCmd schematic_done
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         set retCmd layout_done
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$runMe} {
[05/05 14:53:56     12s]         set trigCmd [lindex $args 0]
[05/05 14:53:56     12s]         if {[catch {set result [eval $trigCmd [lrange $args 1 end]]} msg]} {
[05/05 14:53:56     12s]             ShowError "Error while running trigger: $msg"
[05/05 14:53:56     12s]             append retCmd " 0"
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             append retCmd " $result"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         append retCmd " 0"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     eval SendCmdToClient $retCmd
[05/05 14:53:56     12s]     return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_send_protocol_version {protVersion host port display} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set vars(client_protocol_version) $protVersion
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getDisplayEnvVar {} {
[05/05 14:53:56     12s]     global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set host [info hostname]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # $env(DISPLAY) :0.0 0:0 verbena:2 :2 are all valid
[05/05 14:53:56     12s]     if { ![info exists env(DISPLAY)] || $env(DISPLAY)=="0:0" } {
[05/05 14:53:56     12s]         set display $host:0.0
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         set colon_index [string first ":" $env(DISPLAY)]
[05/05 14:53:56     12s]         if {$colon_index>0} {
[05/05 14:53:56     12s]             set display $env(DISPLAY)
[05/05 14:53:56     12s]         } elseif {$colon_index==0} {
[05/05 14:53:56     12s]             set display $host$env(DISPLAY)
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             # there should be : in the env, e.g. 0.0 is not a valid display, just in case.
[05/05 14:53:56     12s]             set display $host:$env(DISPLAY)
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     return $display
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_rfile {in_fname} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$vars(RFILE_BUSY)} {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(RFILE_BUSY) 1
[05/05 14:53:56     12s]     set vars(got_show_layers) 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fname [string trim $in_fname "\""]
[05/05 14:53:56     12s] 	if {![file readable $fname]} {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	incr vars(hl_layer_index)
[05/05 14:53:56     12s] 	if {$vars(hl_layer_index) > $vars(max_hl_layer)} {
[05/05 14:53:56     12s] 		set vars(max_hl_layer) $vars(hl_layer_index)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(hl_layer) "$vars(hl_layer_basen)_$vars(hl_layer_index)"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cval [catch {source -quiet $fname} rval]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(RFILE_BUSY) 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$cval} {
[05/05 14:53:56     12s] 		uimessage_Error . "Error while highlighting:\n$rval"
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set f [open $fname "r"]
[05/05 14:53:56     12s] 	set linecount [ProcessRveFile $f]
[05/05 14:53:56     12s] 	close $f
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$linecount==0} {return 1}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	ShowError "Format error in file $in_fname at line $linecount."
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_delete_markers {{in_cell ""} {in_all 0}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s]     variable hlTextObjs 
[05/05 14:53:56     12s]     variable hlEdgeObjs 
[05/05 14:53:56     12s]     variable hlPolyObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {![DesignLoaded 1]} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	for {set i 0} {$i <= $vars(max_hl_layer)} {incr i} {
[05/05 14:53:56     12s] 		set layer "$vars(hl_layer_basen)_$i"
[05/05 14:53:56     12s] 		deleteCustomLayer $layer
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     catch {array unset hlTextObjs}
[05/05 14:53:56     12s]     catch {array unset hlEdgeObjs}
[05/05 14:53:56     12s]     catch {array unset hlPolyObjs}
[05/05 14:53:56     12s]     array set hlTextObjs {}
[05/05 14:53:56     12s]     array set hlEdgeObjs {}
[05/05 14:53:56     12s]     array set hlPolyObjs {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$vars(RFILE_BUSY)} {
[05/05 14:53:56     12s] 		set vars(hl_layer_index) 0
[05/05 14:53:56     12s] 		set vars(hl_layer) "rve_0"
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		set vars(hl_layer_index) 0
[05/05 14:53:56     12s] 		redraw
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_zoom {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	if {[llength $args]!=5} {return 0}
[05/05 14:53:56     12s] 	set llx [lindex $args 0]
[05/05 14:53:56     12s] 	set lly [lindex $args 1]
[05/05 14:53:56     12s] 	set urx [lindex $args 2]
[05/05 14:53:56     12s] 	set ury [lindex $args 3]
[05/05 14:53:56     12s] 	set zfactor [lindex $args 4]
[05/05 14:53:56     12s] 	if {$zfactor==0} {
[05/05 14:53:56     12s] 		redraw
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	zoomBox $llx $lly $urx $ury
[05/05 14:53:56     12s] 	zoomOut
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_context {cell precision} {
[05/05 14:53:56     12s] 	return [DesignLoaded]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_highlight_index {index args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vars(hl_layer) "$vars(hl_layer_basen)_${index}"
[05/05 14:53:56     12s] 	if {$index > $vars(max_hl_layer)} {
[05/05 14:53:56     12s] 		set vars(max_hl_layer) $index
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	# DR717379: Difficult to see highlight shapes in EDI by default, custom color is not supported either.
[05/05 14:53:56     12s] 	if { [llength $args]==2 } {
[05/05 14:53:56     12s] 		setLayerPreference $vars(hl_layer) -color [lindex $args 1]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_incr_highlight_index {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	incr vars(hl_layer_index)
[05/05 14:53:56     12s] 	if {$vars(hl_layer_index) > $vars(max_hl_layer)} {
[05/05 14:53:56     12s] 		set vars(max_hl_layer) $vars(hl_layer_index)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set vars(hl_layer) "$vars(hl_layer_basen)_$vars(hl_layer_index)"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::get_highlight_index {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	return $vars(hl_layer_index)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_export_stream {cell filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/05 14:53:56     12s] 	return [mgc_enc::_mgc_rve_export_stream $cell $filename $llx $lly $dx $dy]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::_mgc_rve_export_stream {cell filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set exec_ok 1
[05/05 14:53:56     12s] 	if {$vars(showDlgRunTimeGDS) == 1} {
[05/05 14:53:56     12s] 		set exec_ok [SetExportOptions GDS 1]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	if {$exec_ok == 0} {
[05/05 14:53:56     12s] 		TranscriptMessage "GDS export cancelled by user"
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd "[getExportCmd $filename $vars(exportOptionsGDS)]"
[05/05 14:53:56     12s] 	if { $dx>0 && $dy>0 } {
[05/05 14:53:56     12s] 		set urx [expr $llx + $dx]
[05/05 14:53:56     12s] 		set ury [expr $lly + $dy]
[05/05 14:53:56     12s] 		append cmd " -area {$llx $lly $urx $ury}"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[catch {eval $cmd} msg]} {
[05/05 14:53:56     12s] 		TranscriptMessage $msg
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::_mgc_rve_export_def {cell filename} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set exec_ok 1
[05/05 14:53:56     12s] 	if {$vars(showDlgRunTimeDEF) == 1} {
[05/05 14:53:56     12s] 		set exec_ok [SetExportOptions DEF 1]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	if {$exec_ok == 0} {
[05/05 14:53:56     12s] 		TranscriptMessage "DEF export cancelled by user"
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set cmd "[getExportDefCmd $filename $vars(exportOptionsDEF)]"
[05/05 14:53:56     12s] 	if {[catch {eval $cmd} msg]} {
[05/05 14:53:56     12s] 		TranscriptMessage $msg
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_export_layout {cell format filename {llx 0} {lly 0} {dx 0} {dy 0}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(exportFileName) [string trim $filename "\""]
[05/05 14:53:56     12s] 	set format [string trim $format \"]
[05/05 14:53:56     12s] 	if {$format!="GDSII" && $format!="DEF"} {
[05/05 14:53:56     12s] 		mgc_enc::ShowError "Calibre Interactive: Cannot export $format format layout from Encounter."
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# Innovus defOut doesn't support -area option, but streamOut does
[05/05 14:53:56     12s] 	if { $format!="GDSII" && $dx>0 && $dy>0 } {
[05/05 14:53:56     12s] 		TranscriptMessage "Area export not implemented. Exporting entire design..."
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$format=="GDSII"} {
[05/05 14:53:56     12s] 		SendCmdToClient layout_done [_mgc_rve_export_stream $cell $filename $llx $lly $dx $dy]
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		SendCmdToClient layout_done [_mgc_rve_export_def $cell $filename]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::_mgc_rve_export_verilog {cell filename} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set exec_ok 1
[05/05 14:53:56     12s] 	if {$vars(showDlgRunTimeVerilog) == 1} {
[05/05 14:53:56     12s] 		set exec_ok [SetExportOptions Verilog 1]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	if {$exec_ok == 0} {
[05/05 14:53:56     12s] 		TranscriptMessage "Verilog export cancelled by user"
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set cmd "[getExportVerilogCmd $filename $vars(exportOptionsVerilog)]"
[05/05 14:53:56     12s] 	if {[catch {eval $cmd} msg]} {
[05/05 14:53:56     12s] 		TranscriptMessage $msg
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::_mgc_rve_export_netlist {cell format filename} {
[05/05 14:53:56     12s] 	if {$format!="VERILOG"} {
[05/05 14:53:56     12s] 		mgc_enc::ShowError "Calibre Interactive: Cannot export $format format netlists from Encounter."
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return [_mgc_rve_export_verilog $cell $filename]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_export_netlist {cell format filename} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(exportFileName) [string trim $filename "\""]
[05/05 14:53:56     12s] 	SendCmdToClient schematic_done [_mgc_rve_export_netlist $cell $format $filename]
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_snet {cell clear_hl zfactor nets} {
[05/05 14:53:56     12s] 	TranscriptMessage "mgc_rve_snet not implemented."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_sinst {cell clear_hl zfactor nets} {
[05/05 14:53:56     12s] 	TranscriptMessage "mgc_rve_sinst not implemented."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_probe_snet {cell} {
[05/05 14:53:56     12s] 	TranscriptMessage "mgc_rve_probe_snet not implemented."
[05/05 14:53:56     12s] 	ShowNote "Functionality not implemented."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_probe_sinst {cell} {
[05/05 14:53:56     12s] 	TranscriptMessage "mgc_rve_probe_sinst not implemented."
[05/05 14:53:56     12s] 	ShowNote "Functionality not implemented."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_get_location {cell precision} {
[05/05 14:53:56     12s] 	set pt [guiGetCoord]
[05/05 14:53:56     12s] 	if { [llength $pt]==2 } {
[05/05 14:53:56     12s] 		SendCmdToClient layout_data_ready [lindex $pt 0] [lindex $pt 1]
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		SendCmdToClient layout_data_ready
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_get_rectangle {cell precision} {
[05/05 14:53:56     12s] 	set box [guiGetBox]
[05/05 14:53:56     12s] 	if { [llength $box]==4 } {
[05/05 14:53:56     12s] 		SendCmdToClient layout_data_ready [lindex $box 0] [lindex $box 1] [lindex $box 2] [lindex $box 3]
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		SendCmdToClient layout_data_ready
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_get_poly {cell precision} {
[05/05 14:53:56     12s] 	set poly [guiGetPoly]
[05/05 14:53:56     12s] 	if { [llength $poly]>1 } {
[05/05 14:53:56     12s] 		# eval to flatten the list
[05/05 14:53:56     12s] 		eval SendCmdToClient layout_data_ready $poly
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		SendCmdToClient layout_data_ready
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_import {fname lname} {
[05/05 14:53:56     12s] 	ShowNote "Functionality not implemented."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_layer {args} {}
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_instance {args} {}
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_device {args} {}
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_port {args} {}
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_pin {args} {}
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_property {args} {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckName {name} {
[05/05 14:53:56     12s] 	set end [string length $name]
[05/05 14:53:56     12s] 	incr end -1
[05/05 14:53:56     12s] 	if {([string index $name 0]!="\"") || ([string index $name $end]!="\"")} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckInteger {num} {
[05/05 14:53:56     12s] 	# No string is functions in Tcl 8.0
[05/05 14:53:56     12s] 	#if {![string is integer -strict $num]} {
[05/05 14:53:56     12s] 	#	return 0
[05/05 14:53:56     12s] 	#}
[05/05 14:53:56     12s] 	if {[scan $num "%d" inum]!=1} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckNumber {num} {
[05/05 14:53:56     12s] 	#   No string is functions in Tcl 8.0
[05/05 14:53:56     12s] 	#if {![string is double -strict $num]} {
[05/05 14:53:56     12s] 	#	return 0
[05/05 14:53:56     12s] 	#}
[05/05 14:53:56     12s] 	if {[scan $num "%g" dnum]!=1} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ProcessRveFile {f} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set linecount 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	while {[gets $f rline]!=-1} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		incr linecount
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set line [split $rline]
[05/05 14:53:56     12s] 		set cmd  [lindex $line 0]
[05/05 14:53:56     12s] 		set args [lrange $line 1 end]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		switch -- $cmd {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"mp" -
[05/05 14:53:56     12s] 			"me" -
[05/05 14:53:56     12s] 			"ml" - 
[05/05 14:53:56     12s] 			"mr" -
[05/05 14:53:56     12s] 			"mpc" -
[05/05 14:53:56     12s] 			"mec" -
[05/05 14:53:56     12s] 			"mgc_rve_zoom" -
[05/05 14:53:56     12s] 			"mgc_rve_poly" -
[05/05 14:53:56     12s] 			"mgc_rve_poly_clear" -
[05/05 14:53:56     12s] 			"mgc_rve_edge" -
[05/05 14:53:56     12s] 			"mgc_rve_edge_clear" -
[05/05 14:53:56     12s] 			"mgc_rve_line" -
[05/05 14:53:56     12s] 			"mgc_rve_rect" {
[05/05 14:53:56     12s] 				set ret [eval $cmd $args]
[05/05 14:53:56     12s] 				if { $ret==0 || $ret=="" } {return $linecount}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"mgc_rve_context" {
[05/05 14:53:56     12s] 				if {[llength $args]!=2} {return $linecount}
[05/05 14:53:56     12s] 				set cell [lindex $args 0]
[05/05 14:53:56     12s] 				set precision [lindex $args 1]
[05/05 14:53:56     12s] 				if {![CheckInteger $precision]} {return $linecount}
[05/05 14:53:56     12s] 				if {![CheckName $cell]} {
[05/05 14:53:56     12s] 					return $linecount
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 				if {![$cmd $cell $precision]} {return $linecount}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"mgc_rve_delete_markers" {
[05/05 14:53:56     12s] 				if {[llength $args]!=0} {return $linecount}
[05/05 14:53:56     12s] 				if {![$cmd]} {return $linecount}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"mgc_rve_text" -
[05/05 14:53:56     12s] 			"mgc_rve_text_clear" -
[05/05 14:53:56     12s] 			"mt" -
[05/05 14:53:56     12s] 			"mtc" {
[05/05 14:53:56     12s] 				if {[llength $args]!=4} {return $linecount}
[05/05 14:53:56     12s] 				foreach a [lrange $args 1 end] {
[05/05 14:53:56     12s] 					if {![CheckNumber $a]} {
[05/05 14:53:56     12s] 						return $linecount
[05/05 14:53:56     12s] 					}
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 				set ret [eval $cmd $args] 
[05/05 14:53:56     12s] 				if { $ret==0 || $ret=="" } {return $linecount}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"" -
[05/05 14:53:56     12s] 			"mgc_rve_layer" -
[05/05 14:53:56     12s] 			"mgc_rve_instance" -
[05/05 14:53:56     12s] 			"mgc_rve_device" -
[05/05 14:53:56     12s] 			"mgc_rve_port" -
[05/05 14:53:56     12s] 			"mgc_rve_pin" -
[05/05 14:53:56     12s] 			"mgc_rve_property" {
[05/05 14:53:56     12s] 				# skip these lines
[05/05 14:53:56     12s] 				continue
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			"mgc_rve_show_layers" {
[05/05 14:53:56     12s] 				if {![eval $cmd $args]} {return $linecount}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 			default {
[05/05 14:53:56     12s] 				return $linecount
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mp {args} {return [eval mgc_rve_poly $args]}
[05/05 14:53:56     12s] @proc mgc_enc::mpc {args} {return [eval mgc_rve_poly_clear $args]}
[05/05 14:53:56     12s] @proc mgc_enc::mr {args} {return [eval mgc_rve_rect $args]}
[05/05 14:53:56     12s] @proc mgc_enc::me {args} {return [eval mgc_rve_edge $args]}
[05/05 14:53:56     12s] @proc mgc_enc::mec {args} {return [eval mgc_rve_edge_clear $args]}
[05/05 14:53:56     12s] @proc mgc_enc::ml {args} {return [eval mgc_rve_line $args]}
[05/05 14:53:56     12s] @proc mgc_enc::mt {args} {return [eval mgc_rve_text $args]}
[05/05 14:53:56     12s] @proc mgc_enc::mtc {args} {return [eval mgc_rve_text_clear $args]}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_rect {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	variable hlPolyObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[llength $args]<4} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set llx [lindex $args 0]
[05/05 14:53:56     12s] 	set lly [lindex $args 1]
[05/05 14:53:56     12s] 	set urx [lindex $args 2]
[05/05 14:53:56     12s] 	set ury [lindex $args 3]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set oid [createGuiRect $vars(hl_layer) $llx $lly $urx $ury]
[05/05 14:53:56     12s] 	lappend hlPolyObjs($llx,$lly) $oid
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return [list $oid]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # We must accommodate trailing property name/val pairs; ignore them 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_poly {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	variable hlPolyObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vcount [lindex $args 0]
[05/05 14:53:56     12s] 	set coords [lrange $args 1 end]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set coords_len [expr {($vcount*2)}]
[05/05 14:53:56     12s] 	if {[llength $coords] < $coords_len} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$vcount==4} {
[05/05 14:53:56     12s] 		# decide if this is a rectangle
[05/05 14:53:56     12s] 		set llx [lindex $coords 0]
[05/05 14:53:56     12s] 		set lly [lindex $coords 1]
[05/05 14:53:56     12s] 		set p2x [lindex $coords 2]
[05/05 14:53:56     12s] 		set p2y [lindex $coords 3]
[05/05 14:53:56     12s] 		set urx [lindex $coords 4]
[05/05 14:53:56     12s] 		set ury [lindex $coords 5]
[05/05 14:53:56     12s] 		set p4x [lindex $coords 6]
[05/05 14:53:56     12s] 		set p4y [lindex $coords 7]
[05/05 14:53:56     12s] 		if {($lly==$p2y) && ($llx==$p4x) && ($urx==$p2x) && ($ury==$p4y)} {
[05/05 14:53:56     12s] 			set oid [createGuiRect $vars(hl_layer) $llx $lly $urx $ury]
[05/05 14:53:56     12s] 			lappend hlPolyObjs($llx,$lly) $oid
[05/05 14:53:56     12s] 			return [list $oid]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fx [lindex $coords 0] ; set fy [lindex $coords 1]
[05/05 14:53:56     12s] 	set x1 $fx ; set y1 $fy
[05/05 14:53:56     12s] 	incr coords_len -1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lOids []
[05/05 14:53:56     12s] 	foreach {x2 y2} [lrange $coords 2 $coords_len] {
[05/05 14:53:56     12s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/05 14:53:56     12s] 		lappend hlPolyObjs($fx,$fy) $oid
[05/05 14:53:56     12s] 		lappend lOids $oid
[05/05 14:53:56     12s] 		set x1 $x2 ; set y1 $y2
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	set oid [createGuiLine $vars(hl_layer) $x2 $y2 $fx $fy]
[05/05 14:53:56     12s] 	lappend hlPolyObjs($fx,$fy) $oid
[05/05 14:53:56     12s] 	lappend lOids $oid
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $lOids
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # We must accommodate trailing property name/val pairs; ignore them 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_edge {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	variable hlEdgeObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set ecount [lindex $args 0]
[05/05 14:53:56     12s] 	set coords [lrange $args 1 end]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set coords_len [expr {($ecount*4)}]
[05/05 14:53:56     12s] 	if {[llength $coords] < $coords_len} {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lOids []
[05/05 14:53:56     12s] 	incr coords_len -1
[05/05 14:53:56     12s] 	set x0 [lindex $coords 0]
[05/05 14:53:56     12s] 	set y0 [lindex $coords 1]
[05/05 14:53:56     12s] 	for {set i 0} {$i < $ecount} {incr i} {
[05/05 14:53:56     12s] 		set vindex [expr {$i*4}]
[05/05 14:53:56     12s] 		set x1 [lindex $coords $vindex] ; incr vindex
[05/05 14:53:56     12s] 		set y1 [lindex $coords $vindex] ; incr vindex
[05/05 14:53:56     12s] 		set x2 [lindex $coords $vindex] ; incr vindex
[05/05 14:53:56     12s] 		set y2 [lindex $coords $vindex]
[05/05 14:53:56     12s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/05 14:53:56     12s] 		lappend hlEdgeObjs($x0,$y0) $oid
[05/05 14:53:56     12s] 		lappend lOids $oid
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $lOids
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_line {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vcount [lindex $args 0]
[05/05 14:53:56     12s] 	set coords [lrange $args 1 end]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[llength $coords]!=[expr {$vcount*2}]} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lOids []
[05/05 14:53:56     12s] 	set x1 [lindex $coords 0] ; set y1 [lindex $coords 1]
[05/05 14:53:56     12s] 	foreach {x2 y2} [lrange $coords 2 end] {
[05/05 14:53:56     12s] 		set oid [createGuiLine $vars(hl_layer) $x1 $y1 $x2 $y2]
[05/05 14:53:56     12s] 		lappend lOids $oid
[05/05 14:53:56     12s] 		set x1 $x2 ; set y1 $y2
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $lOids
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_text_clear {name x y size} {
[05/05 14:53:56     12s]     variable hlTextObjs 
[05/05 14:53:56     12s]     if {[info exists hlTextObjs($x,$y)]} {
[05/05 14:53:56     12s]         foreach obj $hlTextObjs($x,$y) {
[05/05 14:53:56     12s]             catch {deleteGuiObj $obj}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         unset hlTextObjs($x,$y)
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_edge_clear {num_edges args} {
[05/05 14:53:56     12s]     variable hlEdgeObjs 
[05/05 14:53:56     12s]     foreach {x y} $args {break}
[05/05 14:53:56     12s]     if {[info exists hlEdgeObjs($x,$y)]} {
[05/05 14:53:56     12s]         foreach obj $hlEdgeObjs($x,$y) {
[05/05 14:53:56     12s]             catch {deleteGuiObj $obj}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         unset hlEdgeObjs($x,$y)
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_poly_clear {num_pts args} {
[05/05 14:53:56     12s]     variable hlPolyObjs 
[05/05 14:53:56     12s]     foreach {x y} $args {break}
[05/05 14:53:56     12s]     if {[info exists hlPolyObjs($x,$y)]} {
[05/05 14:53:56     12s]         foreach obj $hlPolyObjs($x,$y) {
[05/05 14:53:56     12s]             catch {deleteGuiObj $obj}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         unset hlPolyObjs($x,$y)
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_text {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	variable hlTextObjs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[llength $args]!=4} {return 0}
[05/05 14:53:56     12s] 	set tstr [string trim [lindex $args 0] "\""]
[05/05 14:53:56     12s] 	set x [lindex $args 1]
[05/05 14:53:56     12s] 	set y [lindex $args 2]
[05/05 14:53:56     12s] 	set tsize [lindex $args 3]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set oid [createGuiText $vars(hl_layer) "$tstr" $x $y $tsize]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	lappend hlTextObjs($x,$y) $oid
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return [list $oid]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_start_results_set {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vars(got_show_layers) 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_end_results_set {} {
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_get_all_metal_layers {} {
[05/05 14:53:56     12s] 	set metalLayers [getAllLayers metal]
[05/05 14:53:56     12s] 	# DR1280698: RTD with "Visible layer only checks" recipe ...
[05/05 14:53:56     12s] 	# add allM0 - allM# and allM1Cont - allM#Cont support
[05/05 14:53:56     12s] 	set i 0
[05/05 14:53:56     12s] 	while { [catch {set layer [getLayerByName M$i]}]==0 && $layer } {
[05/05 14:53:56     12s] 		# lappend lValidMetalLayers M${i}
[05/05 14:53:56     12s] 		lappend metalLayers "allM${i}"
[05/05 14:53:56     12s] 		lappend metalLayers "allM[expr $i+1]Cont"
[05/05 14:53:56     12s] 		incr i
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return $metalLayers
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_show_layers {args} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set metalLayers [mgc_rve_get_all_metal_layers]
[05/05 14:53:56     12s] 	foreach layer $metalLayers {
[05/05 14:53:56     12s] 		foreach spec $args {
[05/05 14:53:56     12s] 			# get the layer name, skip layer purpose
[05/05 14:53:56     12s] 			set spec [lindex [split $spec ":"] 0]
[05/05 14:53:56     12s] 			set layerMatched [string match "$spec" $layer]
[05/05 14:53:56     12s] 			# DR 1393161 CTO layer visibility not being applied when using Innovus 19.11 or CUI mode in 18.10 or 19.11
[05/05 14:53:56     12s] 			# In Innovus 19.10/19.11 CUI/Legacy mode, M0/M1/.. is replaced with M0Wire/M1Wire/...
[05/05 14:53:56     12s] 			if { !$layerMatched && [regexp {(M[0-9]+)Wire} $layer ignore wireLayer] } {
[05/05 14:53:56     12s] 				# 'wireLayer' variable is the layer name like M1 _without_ 'Wire' suffix
[05/05 14:53:56     12s] 				# Innovus 19.11: getLayerPreference M8 -isVisible  => **ERROR: (IMPSYC-1885): Layer 'M8' does not exist.
[05/05 14:53:56     12s] 				set layerMatched [string match "$spec" $wireLayer]
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 			if {$layerMatched} {
[05/05 14:53:56     12s] 				if {$vars(got_show_layers) == 0} {
[05/05 14:53:56     12s] 					array unset vars show_layers_lsw_layers,*
[05/05 14:53:56     12s] 					set vars(show_layers_lsw_is_current) 1
[05/05 14:53:56     12s] 					foreach tmpLayer $metalLayers {
[05/05 14:53:56     12s] 						# First hide all layers; we only do that after we are sure we have
[05/05 14:53:56     12s] 						# at least one layer which should be shown.
[05/05 14:53:56     12s] 						setLayerPreference $tmpLayer -isVisible 0
[05/05 14:53:56     12s] 					}
[05/05 14:53:56     12s] 					set vars(got_show_layers) 1
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 				setLayerPreference $layer -isVisible 1
[05/05 14:53:56     12s] 				# record the show layers
[05/05 14:53:56     12s] 				set vars(show_layers_lsw_layers,$layer) 1
[05/05 14:53:56     12s] 				break
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_is_lsw_layers_saved {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set lNames [array names vars lsw_layers,*]
[05/05 14:53:56     12s] 	if { [llength $lNames]<=0 } {
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_record_lsw_layers {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set metalLayers [mgc_rve_get_all_metal_layers]
[05/05 14:53:56     12s] 	foreach layer $metalLayers {
[05/05 14:53:56     12s] 		set isVisible [getLayerPreference $layer -isVisible]
[05/05 14:53:56     12s] 		set vars(lsw_layers,$layer) $isVisible 
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_restore_lsw_layers {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lNames [array names vars lsw_layers,*]
[05/05 14:53:56     12s] 	set metalLayers [string map [list "lsw_layers," ""] $lNames]
[05/05 14:53:56     12s] 	foreach layer $metalLayers {
[05/05 14:53:56     12s] 		set isVisible $vars(lsw_layers,$layer)
[05/05 14:53:56     12s] 		# realtime/innovus-common-ui/capture_restore_layer_visibility
[05/05 14:53:56     12s] 		# NOK: get_layer_preference allM3Cont -is_visible => 2
[05/05 14:53:56     12s] 		# if { $isVisible } { set isVisible 1 }
[05/05 14:53:56     12s] 		# set_layer_preference M3Cont -is_visible 0
[05/05 14:53:56     12s] 		# => set_layer_preference allM3Cont -is_visible 2
[05/05 14:53:56     12s] 		# CUI mode only allow {0 1} as value for -is_visible, while legacy mode allow {0 1 2}.
[05/05 14:53:56     12s] 		# the value of 2 must have some special undocumented meaning.
[05/05 14:53:56     12s] 		if { $isVisible==2 && [is_common_ui_mode] } {
[05/05 14:53:56     12s] 			eval_legacy "setLayerPreference $layer -isVisible $isVisible"
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			setLayerPreference $layer -isVisible $isVisible
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_restore_show_layers_lsw_layers {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set lNames [array names vars show_layers_lsw_layers,*]
[05/05 14:53:56     12s] 	if { [llength $lNames]>0 } {
[05/05 14:53:56     12s] 		set metalLayers [mgc_rve_get_all_metal_layers]
[05/05 14:53:56     12s] 		foreach tmpLayer $metalLayers {
[05/05 14:53:56     12s] 			setLayerPreference $tmpLayer -isVisible 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set lswLayers [string map [list "show_layers_lsw_layers," ""] $lNames]
[05/05 14:53:56     12s] 		foreach layer $lswLayers {
[05/05 14:53:56     12s] 			setLayerPreference $layer -isVisible 1
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set vars(show_layers_lsw_is_current) 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::mgc_rve_toggle_visible_layer_set {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if { $vars(show_layers_lsw_is_current) } {
[05/05 14:53:56     12s] 		mgc_rve_restore_lsw_layers
[05/05 14:53:56     12s] 		set vars(show_layers_lsw_is_current) 0
[05/05 14:53:56     12s] 		redraw
[05/05 14:53:56     12s] 	} elseif { [array names vars show_layers_lsw_layers,*]!="" } {
[05/05 14:53:56     12s] 		mgc_rve_restore_show_layers_lsw_layers
[05/05 14:53:56     12s] 		set vars(show_layers_lsw_is_current) 1
[05/05 14:53:56     12s] 		redraw
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupLayoutExport {} {
[05/05 14:53:56     12s] 	mgc_enc::ShowNote \
[05/05 14:53:56     12s] "Calibre uses the Encounter streamOut
[05/05 14:53:56     12s] command to export layout."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupNetlistExport {} {
[05/05 14:53:56     12s] 	mgc_enc::ShowNote \
[05/05 14:53:56     12s] "Calibre uses the Encounter saveNetlist
[05/05 14:53:56     12s] command to export netlists."
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::DisplayFileContents {w fname} {
[05/05 14:53:56     12s] 	global _ui_fonts
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {![winfo exists $w.txtf]} {
[05/05 14:53:56     12s] 		set txt [uiutils_MakeScrolledText $w.txtf "both" -font $_ui_fonts(Mono) -wrap none -relief flat -height 40]
[05/05 14:53:56     12s] 		pack $w.txtf -side top -fill both -expand 1
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		set txt $w.txtf.txt
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	$txt config -state normal	
[05/05 14:53:56     12s] 	$txt delete 1.0 end
[05/05 14:53:56     12s] 	set af [open $fname r]
[05/05 14:53:56     12s] 	$txt insert end [read $af]
[05/05 14:53:56     12s] 	close $af
[05/05 14:53:56     12s] 	$txt config -state disabled
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupAboutDialog {} {
[05/05 14:53:56     12s] 	global env _ui_fonts
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set twin ".twin"
[05/05 14:53:56     12s] 	if {[winfo exists $twin]} {
[05/05 14:53:56     12s] 		wm deiconify $twin
[05/05 14:53:56     12s] 		raise $twin
[05/05 14:53:56     12s] 		return #t
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set afile [file join $env(MGC_HOME) shared pkgs icv tools queryenc calencREADME]
[05/05 14:53:56     12s] 	if {![file exists $afile] || ![file readable $afile]} {
[05/05 14:53:56     12s] 		uimessage_Note . "Could not read information file:\n\$MGC_HOME/shared/pkgs/icv/tools/queryenc/calencREADME"
[05/05 14:53:56     12s] 		return #t
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	toplevel $twin
[05/05 14:53:56     12s] 	wm withdraw $twin
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	wm protocol $twin WM_DELETE_WINDOW "wm withdraw $twin"
[05/05 14:53:56     12s] 	bind $twin <Escape> "wm withdraw $twin"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vfile [file join $env(MGC_HOME) pkgs icv dependencies version]
[05/05 14:53:56     12s] 	set vtext ""
[05/05 14:53:56     12s] 	if {[catch {set vf [open $vfile r]}]==0} {
[05/05 14:53:56     12s] 		gets $vf vtext
[05/05 14:53:56     12s] 		close $vf
[05/05 14:53:56     12s] 		set vtext "($vtext)"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	wm title $twin "About the Calibre Encounter/Innovus Interface $vtext"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	DisplayFileContents $twin $afile
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	#uiprocs_PositionWindow $twin . "center"
[05/05 14:53:56     12s] 	mgc_enc::PositionWindowOnRight $twin
[05/05 14:53:56     12s] 	
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckEnv {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 	if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/05 14:53:56     12s] 		ShowError "MGC_HOME environment variable is not set!"
[05/05 14:53:56     12s] 		return ""
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	initServerSocket $vars(socket_number) $vars(socket_host)
[05/05 14:53:56     12s] 	return [file join $env(MGC_HOME) "bin" "calibre"]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::StartGUI {cmd cell type} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     append cmd " -gui -${type}"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set doTriggerSetup 1
[05/05 14:53:56     12s]     if {$type eq "rve"} {
[05/05 14:53:56     12s]         set doTriggerSetup 0
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$doTriggerSetup} {
[05/05 14:53:56     12s]         set key [calculateTriggerKey]
[05/05 14:53:56     12s]         set ::env(MGC_CALIBRE_INTERACTIVE_TRIGGER_KEY) $key
[05/05 14:53:56     12s]         lappend vars(CI_trigger_keys) $key
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set retVal ""
[05/05 14:53:56     12s]     if {[catch {set fid [open "| $cmd" "r+"]} emsg]==0} {
[05/05 14:53:56     12s]         fconfigure $fid -buffering line -blocking 0
[05/05 14:53:56     12s]         fileevent $fid readable "mgc_enc::ReadGUI $fid $cell $type"
[05/05 14:53:56     12s]         set vars($type,$cell) $fid
[05/05 14:53:56     12s]         set retVal $fid
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {$doTriggerSetup} {
[05/05 14:53:56     12s]         unset ::env(MGC_CALIBRE_INTERACTIVE_TRIGGER_KEY)
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return $retVal
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ReadGUI {fid cell type {cmd ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	read $fid
[05/05 14:53:56     12s] 	if {[eof $fid]} {
[05/05 14:53:56     12s] 		fconfigure $fid -blocking 1
[05/05 14:53:56     12s] 		catch {close $fid}
[05/05 14:53:56     12s] 		if {$cmd ne ""} {
[05/05 14:53:56     12s] 		    # need to specify $cmd for custom
[05/05 14:53:56     12s] 		    set vars($type,$cmd,$cell) ""
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 		    set vars($type,$cell) ""
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # Check if the process associated with the with the cell and tool type (drc, lvs, etc) has already been started
[05/05 14:53:56     12s] # For a custom menu item, the third param "cmd" must be specified
[05/05 14:53:56     12s] @proc mgc_enc::CheckGUI {cell type {cmd ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	if {$cmd eq ""} {
[05/05 14:53:56     12s] 	    if {[info exists vars($type,$cell)]} {
[05/05 14:53:56     12s] 	        return $vars($type,$cell)
[05/05 14:53:56     12s] 	    }
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 	    if {[info exists vars($type,$cmd,$cell)]} {
[05/05 14:53:56     12s] 	        return $vars($type,$cmd,$cell)
[05/05 14:53:56     12s] 	    }
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return ""
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runDRC {lcell} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell drc]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rdrc_RunDRC $lcell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "drc"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rdrc_SetupDRC $lcell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runDFM {lcell} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell dfm]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rdfm_RunDFM $lcell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "dfm"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rdfm_SetupDFM $lcell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runLVS {lcell {scell ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$scell==""} {set scell $lcell}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell lvs]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rlvs_RunLVS $lcell $scell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "lvs"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rlvs_SetupLVS $lcell $scell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runPEX {lcell {scell ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$scell==""} {set scell $lcell}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell pex]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rpex_RunPEX $lcell $scell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "pex"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rpex_SetupPEX $lcell $scell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runXACT {lcell {scell ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$scell==""} {set scell $lcell}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell xact]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rxact_RunXACT $lcell $scell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "xact"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rxact_SetupXACT $lcell $scell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runPERC {lcell {scell ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {$scell==""} {set scell $lcell}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell pex]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rperc_RunPERC $lcell $scell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "perc"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rperc_SetupPERC $lcell $scell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runYE {lcell} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckGUI $lcell ye]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		puts $fid "rye_RunYE $lcell"
[05/05 14:53:56     12s] 		return 1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartGUI $cmd $lcell "ye"]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	puts $fid "rye_SetupYE $lcell"
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runCommand {cmd} {
[05/05 14:53:56     12s] 	if {[catch {eval exec $cmd} cmsg]} {
[05/05 14:53:56     12s] 		TranscriptMessage $cmsg
[05/05 14:53:56     12s] 		return [SetReturnVal 0]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	puts $cmsg
[05/05 14:53:56     12s] 	return [SetReturnVal 1]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ############################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::StartRVE {cmd {params ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	append cmd " -gui -rve $params"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {[catch {set fid [open "| $cmd" "r+"]} emsg]==0} {
[05/05 14:53:56     12s] 		fconfigure $fid -buffering line -blocking 0
[05/05 14:53:56     12s] 		fileevent $fid readable "mgc_enc::ReadRVE $fid"
[05/05 14:53:56     12s] 		lappend vars(rve_fids) $fid
[05/05 14:53:56     12s] 		return $fid
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		return ""
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::ReadRVE {fid} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	read $fid
[05/05 14:53:56     12s] 	if {[eof $fid]} {
[05/05 14:53:56     12s] 		close $fid
[05/05 14:53:56     12s] 		set fid_index [lsearch $vars(rve_fids) $fid]
[05/05 14:53:56     12s] 		if {$fid_index!=-1} {
[05/05 14:53:56     12s] 			set vars(rve_fids) [lreplace $vars(rve_fids) $fid_index $fid_index]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::CheckRVE {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	if {[info exists vars(rve_fids)] && [llength $vars(rve_fids)]!=0} {
[05/05 14:53:56     12s] 		return [lindex $vars(rve_fids) 0]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return ""
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runRVE {{params ""}} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [CheckRVE]
[05/05 14:53:56     12s] 	if {$fid!=""} {
[05/05 14:53:56     12s] 		if {![uimessage_YesNo . "RVE is already running!\nDo you want to start another session?"]} {
[05/05 14:53:56     12s] 			puts $fid rve_PopWindows
[05/05 14:53:56     12s] 			flush $fid
[05/05 14:53:56     12s] 			return 1
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set cmd [CheckEnv]
[05/05 14:53:56     12s] 	if {$cmd==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set fid [StartRVE $cmd $params]
[05/05 14:53:56     12s] 	if {$fid==""} {return 0}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::openRDBFileInRVE {rdbFileName} {
[05/05 14:53:56     12s]     if {[CheckRVE] eq ""} {
[05/05 14:53:56     12s]         runRVE $rdbFileName
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         SendCmdToClient rve_open_rdb_file $rdbFileName
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::openDBInRVE {dbName {topCell ""}} {
[05/05 14:53:56     12s]     if {[CheckRVE] eq ""} {
[05/05 14:53:56     12s]         runRVE "$dbName $topCell"
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s]         set cmd [list rve_open_db $dbName]
[05/05 14:53:56     12s]         if {$topCell ne ""} {
[05/05 14:53:56     12s]             lappend cmd $topCell
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         eval SendCmdToClient $cmd
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runCalibre {prog} {
[05/05 14:53:56     12s]     if {[DesignLoaded 1]} {
[05/05 14:53:56     12s]         if [string match "AUTOFIX" $prog] {
[05/05 14:53:56     12s]             set cmd calibre_autofix
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             if {$prog eq "RVE"} {
[05/05 14:53:56     12s]                 set param ""
[05/05 14:53:56     12s]             } else {
[05/05 14:53:56     12s]                 set param [getCellName [getTopCell]]
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set cmd "mgc_enc::run${prog} $param"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         eval $cmd
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupExport {type} {
[05/05 14:53:56     12s] 	SetExportOptions $type 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetExportOptionsCancel {w type} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(showDlgRunTimeTmp$type) $vars(showDlgRunTime$type)
[05/05 14:53:56     12s] 	set vars(exportDlgStatus) 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetExportOptionsOK {w type txt} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(exportDlgStatus) 1
[05/05 14:53:56     12s] 	set vars(showDlgRunTime$type) $vars(showDlgRunTimeTmp$type)
[05/05 14:53:56     12s] 	set vars(exportOptions$type) [string trim [$txt get 1.0 end]]
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SaveRVELayerPreference {w} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set types { {{Tcl Script} {.tcl}} {{All Files} *} }
[05/05 14:53:56     12s] 	set fName [tk_getSaveFile -filetypes $types]
[05/05 14:53:56     12s] 	if { $fName=="" } { return 0 }
[05/05 14:53:56     12s] 	if {[catch {set fp [open $fName w]}]} {
[05/05 14:53:56     12s] 		uimessage_Error $w "Could not open layer preference file $fName"
[05/05 14:53:56     12s] 		return 0
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	for {set i 0} {$i<16} {incr i} {
[05/05 14:53:56     12s] 		set width 1
[05/05 14:53:56     12s] 		if { [string is integer -strict $vars(rve_${i}_width)] } {
[05/05 14:53:56     12s] 			set width $vars(rve_${i}_width)
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set stipple [string tolower $vars(rve_${i}_pattern)]
[05/05 14:53:56     12s] 		if { $stipple=="other" } {
[05/05 14:53:56     12s] 			set stipple [getLayerPreference rve_$i -stipple]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set visible [getLayerPreference rve_$i -isVisible]
[05/05 14:53:56     12s] 		set sLine "setLayerPreference rve_$i -color $vars(rve_${i}_color) -isVisible $visible -isSelectable $vars(rve_${i}_selectable) -lineWidth $width"
[05/05 14:53:56     12s] 		if { $stipple=="" || $stipple=="none" } {
[05/05 14:53:56     12s] 			set stipple [getLayerPreference rve_$i -stippleData] 
[05/05 14:53:56     12s] 			if { $stipple!="" } { append sLine " -stippleData $stipple" }
[05/05 14:53:56     12s] 		} else {
[05/05 14:53:56     12s] 			append sLine " -stipple $stipple"
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		puts $fp $sLine
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	close $fp
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetupRVECancel {w} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vars(setupRVEStatus) 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetupRVEOK {w} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vars(setupRVEStatus) 1
[05/05 14:53:56     12s] 	for {set i 0} {$i<16} {incr i} {
[05/05 14:53:56     12s] 		set width 1
[05/05 14:53:56     12s] 		if { [string is integer -strict $vars(rve_${i}_width)] } {
[05/05 14:53:56     12s] 			set width $vars(rve_${i}_width)
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		set stipple [string tolower $vars(rve_${i}_pattern)]
[05/05 14:53:56     12s] 		if { $stipple!="other" } {
[05/05 14:53:56     12s] 			setLayerPreference rve_$i -stipple $stipple
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		setLayerPreference rve_$i -color $vars(rve_${i}_color) -isSelectable $vars(rve_${i}_selectable) -lineWidth $width
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetupSocketCancel {w} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set vars(setupSocketStatus) 0
[05/05 14:53:56     12s] 	set vars(tmp_socket_number) $vars(socket_number)
[05/05 14:53:56     12s] 	set vars(tmp_socket_host) $vars(socket_host)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetupSocketOK {w} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set portNum $vars(tmp_socket_number)
[05/05 14:53:56     12s] 	set host $vars(tmp_socket_host)
[05/05 14:53:56     12s] 	if { [string is integer -strict $portNum] && $portNum>=-1 && $portNum<=65535 } {
[05/05 14:53:56     12s] 		set vars(setupSocketStatus) 1
[05/05 14:53:56     12s] 		if { $portNum!=-1 } {
[05/05 14:53:56     12s] 			if { [mgc_enc::initServerSocket $portNum $host] } {
[05/05 14:53:56     12s] 				set vars(socket_number) $portNum
[05/05 14:53:56     12s] 				set vars(socket_host) $host
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		uimessage_Error . "Socket port number must be an integer between -1 and 65535."
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # DR 1362158 Setup commands (RVE, Export GDS, Export Verilog, etc) not working in Innovus Common UI mode.  Avoid 'update' or 'update idle'
[05/05 14:53:56     12s] @proc mgc_enc::WaitForUpdate {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	set ::mgc_enc::vars(waitUpdateVar) 0
[05/05 14:53:56     12s] 	after idle [list set ::mgc_enc::vars(waitUpdateVar) 1]
[05/05 14:53:56     12s] 	while { !$::mgc_enc::vars(waitUpdateVar) } {
[05/05 14:53:56     12s] 		tkwait variable ::mgc_enc::vars(waitUpdateVar)
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::AddFrameLabel {f text {center 0} {fg ""} {bg ""}} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    if ![winfo exists $f] {frame $f}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    set p [winfo parent $f]
[05/05 14:53:56     12s]    set p_bg [$p cget -bg] ;# get parent's background so we can match it
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Figure out the widget handle to create so it will be unique
[05/05 14:53:56     12s]    set i 1
[05/05 14:53:56     12s]    while 1 {
[05/05 14:53:56     12s]       if ![winfo exists $p.frameLABEL__$i] { break }
[05/05 14:53:56     12s]       incr i
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    # A pady of "1" is VERY important because it prevents labeled frames
[05/05 14:53:56     12s]    # in TK4.2 from having the top pixel row of the label cropped.
[05/05 14:53:56     12s]    # We use extra spaces around the text to provide padding between
[05/05 14:53:56     12s]    # the text and the 3D exterior of the frame.
[05/05 14:53:56     12s]    set lbl [label "$p.frameLABEL__$i" -pady 1 -text " $text "]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    if {$bg == ""} { set bg $p_bg }
[05/05 14:53:56     12s]    if {$fg == ""} {
[05/05 14:53:56     12s]       # Check if there's a default stored in the options database
[05/05 14:53:56     12s]       set fg [option get $lbl frameLabelFG Color]
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    if {$fg != ""} { set fg "-fg $fg" }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Set the label's background and foreground colors
[05/05 14:53:56     12s]    eval $lbl conf -bg "$bg" "$fg"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]    # Check if label has one or two lines
[05/05 14:53:56     12s]    if {[llength [split $$text "\n"]] == 1} {
[05/05 14:53:56     12s]       set Y "-14"
[05/05 14:53:56     12s]    } else {
[05/05 14:53:56     12s]       set Y "-20"
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    if $center {
[05/05 14:53:56     12s]       place $lbl -in $f -relx .5 -y $Y -anc n
[05/05 14:53:56     12s]    } else {
[05/05 14:53:56     12s]       place $lbl -in $f -x 5 -y $Y
[05/05 14:53:56     12s]    }
[05/05 14:53:56     12s]    return $lbl
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::SetExportOptions {type run_time} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	append w .calibreExportOptionsDlg $type
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set txt $w.top.opts.txt
[05/05 14:53:56     12s] 	set mode_f $w.top.mode
[05/05 14:53:56     12s] 	set btns_f $w.top.btns
[05/05 14:53:56     12s] 	if {[winfo exists $w] == 0} {
[05/05 14:53:56     12s] 		toplevel $w
[05/05 14:53:56     12s] 		wm title $w "Calibre $type Export Options"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		# Set the dialog up so that its width and height are resizable
[05/05 14:53:56     12s] 		wm resizable $w 1 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		wm withdraw $w
[05/05 14:53:56     12s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetExportOptionsCancel $w $type"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		frame $w.top
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack [frame $w.top.sp1] -pady 2m -padx 2m
[05/05 14:53:56     12s]                 
[05/05 14:53:56     12s] 		pack [frame $w.top.opts -relief groove -bd 2] -pady 2m -expand yes -fill both -padx 2m -side top
[05/05 14:53:56     12s] 		set options_f $w.top.opts
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set cmd_name ""
[05/05 14:53:56     12s] 		switch $type {
[05/05 14:53:56     12s] 			"GDS"       { set cmd_name "streamOut" }
[05/05 14:53:56     12s] 			"DEF"       { set cmd_name "defOut" }	    ;# write_def
[05/05 14:53:56     12s] 			"Verilog"   { set cmd_name "saveNetlist" }  ;# write_netlist
[05/05 14:53:56     12s] 			default     { }
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		AddFrameLabel $options_f "Options for the \"$cmd_name\" command:" 0 
[05/05 14:53:56     12s] 		pack [text $options_f.txt -wrap word -height 5 -width 60] -side top -expand yes -fill both -padx 1m -pady 1.2m
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		bind $w <Escape> "mgc_enc::SetExportOptionsCancel $w $type"
[05/05 14:53:56     12s] 		bind $w <Return> "mgc_enc::SetExportOptionsOK $w $type $txt"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		frame $mode_f
[05/05 14:53:56     12s] 		checkbutton $mode_f.show_at_runtime -var mgc_enc::vars(showDlgRunTimeTmp$type) -text "Show dialog before export"
[05/05 14:53:56     12s] 		label $mode_f.label -pady 1 -text "File:"
[05/05 14:53:56     12s] 		entry $mode_f.entry -textvariable mgc_enc::vars(exportFileName) -state disabled
[05/05 14:53:56     12s] 		pack $mode_f -pady 0.5m -padx 2m -anchor s -fill x 
[05/05 14:53:56     12s] 		
[05/05 14:53:56     12s] 		frame $btns_f -relief raised -bd 1 
[05/05 14:53:56     12s] 		pack $btns_f -side bottom -fill x -anchor s
[05/05 14:53:56     12s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetExportOptionsOK $w $type $txt"
[05/05 14:53:56     12s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetExportOptionsCancel $w $type"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	
[05/05 14:53:56     12s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 		
[05/05 14:53:56     12s] 		focus $btns_f.ok
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $w.top -side top -fill both -expand yes
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		#uiprocs_PositionWindow $w . "center"
[05/05 14:53:56     12s] 		mgc_enc::PositionWindowOnRight $w
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(showDlgRunTimeTmp$type) $vars(showDlgRunTime$type)
[05/05 14:53:56     12s] 	if {$run_time} {
[05/05 14:53:56     12s] 		pack forget $mode_f.show_at_runtime
[05/05 14:53:56     12s] 		pack $mode_f.label -pady 1  -anchor w -side left
[05/05 14:53:56     12s] 		pack $mode_f.entry -anchor e -side right -expand yes -fill x
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		pack forget $mode_f.label 
[05/05 14:53:56     12s] 		pack forget $mode_f.entry 
[05/05 14:53:56     12s] 		pack $mode_f.show_at_runtime -pady 0.5 -expand yes -fill x -padx 2m
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	$txt delete 1.0 end
[05/05 14:53:56     12s] 	$txt insert end $vars(exportOptions$type)
[05/05 14:53:56     12s] 	set insert_line [$txt get "insert linestart" "insert lineend"]
[05/05 14:53:56     12s] 	if {[string equal "" $insert_line]} {
[05/05 14:53:56     12s] 	# If insert cursor is at the beginning of an empty line, move it to
[05/05 14:53:56     12s] 	# the end of the previous one.
[05/05 14:53:56     12s] 		set idx [$txt index "end - 1 char"]
[05/05 14:53:56     12s] 		set row_count [lindex [split $idx .] 0]
[05/05 14:53:56     12s] 		if {$row_count > 1} {
[05/05 14:53:56     12s] 			set insert_row [expr {$row_count - 1}]
[05/05 14:53:56     12s] 			$txt mark set insert $insert_row.end
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	wm transient $w .
[05/05 14:53:56     12s] 	wm deiconify $w
[05/05 14:53:56     12s] 	mgc_enc::WaitForUpdate
[05/05 14:53:56     12s] 	raise $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# wait for return value to be set after grabbing focus
[05/05 14:53:56     12s] 	grab set $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	tkwait variable mgc_enc::vars(exportDlgStatus)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	grab release $w   ;# Make sure we let go of grab
[05/05 14:53:56     12s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $mgc_enc::vars(exportDlgStatus)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupRVE {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	append w .calibreSetupRVE
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set btns_f $w.top.btns
[05/05 14:53:56     12s] 	if {[winfo exists $w] == 0} {
[05/05 14:53:56     12s] 		toplevel $w
[05/05 14:53:56     12s] 		wm title $w "Calibre Setup RVE Highlight Layers"
[05/05 14:53:56     12s] 		# Set the dialog up so that its width and height are resizable
[05/05 14:53:56     12s] 		wm resizable $w 1 1
[05/05 14:53:56     12s] 		wm withdraw $w
[05/05 14:53:56     12s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetupRVECancel $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		frame $w.top
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		bind $w <Escape> "mgc_enc::SetupRVECancel $w"
[05/05 14:53:56     12s] 		bind $w <Return> "mgc_enc::SetupRVEOK $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set options_f [frame $w.top.opts -relief groove -bd 2]
[05/05 14:53:56     12s] 		set pref_f [frame $options_f.pref_f]
[05/05 14:53:56     12s] 		label $pref_f.title_0 -pady 1 -text "Layer" -anchor w
[05/05 14:53:56     12s] 		label $pref_f.title_1 -pady 1 -text "Color" -anchor center
[05/05 14:53:56     12s] 		label $pref_f.title_2 -pady 1 -text "Stipple" -width 7 -anchor center
[05/05 14:53:56     12s] 		label $pref_f.title_3 -pady 1 -text "Selectable" -anchor center
[05/05 14:53:56     12s] 		label $pref_f.title_4 -pady 1 -text "Width" -width 3 -anchor center
[05/05 14:53:56     12s] 		grid $pref_f.title_0 $pref_f.title_1 $pref_f.title_2 $pref_f.title_3 $pref_f.title_4 -sticky nsew
[05/05 14:53:56     12s] 		grid columnconfigure $pref_f 0 -weight 1
[05/05 14:53:56     12s] 		set bg [$w cget -background]
[05/05 14:53:56     12s] 		for {set i 0} {$i<16} {incr i} {
[05/05 14:53:56     12s] 			label $pref_f.label_$i -text "rve_$i" -anchor w
[05/05 14:53:56     12s] 			frame $pref_f.color_$i -width 24p -height 24p -borderwidth 0
[05/05 14:53:56     12s] 			set c [canvas $pref_f.color_$i.c -height 24 -width 24 -borderwidth 0]
[05/05 14:53:56     12s] 			pack $c -fill none -expand 0
[05/05 14:53:56     12s] 			menubutton $pref_f.pattern_$i -menu $pref_f.pattern_$i.menu -width 7 -relief raised -bd 2 -anchor center -indicatoron 1 -textvariable mgc_enc::vars(rve_${i}_pattern)
[05/05 14:53:56     12s] 			checkbutton $pref_f.selectable_$i -anchor center -variable mgc_enc::vars(rve_${i}_selectable)
[05/05 14:53:56     12s] 			spinbox $pref_f.width_$i -state readonly -readonlybackground $bg -width 3 -from 1 -to 20 -increment 1 -bd 1 -textvariable mgc_enc::vars(rve_${i}_width)
[05/05 14:53:56     12s] 			grid $pref_f.label_$i $pref_f.color_$i $pref_f.pattern_$i $pref_f.selectable_$i $pref_f.width_$i -sticky nsew
[05/05 14:53:56     12s] 			set m [menu $pref_f.pattern_$i.menu]
[05/05 14:53:56     12s] 			foreach item $vars(rve_supported_patterns) {
[05/05 14:53:56     12s] 				$m add radiobutton -label $item -var mgc_enc::vars(rve_${i}_pattern) -value $item
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 			bind $c <Button-1> "mgc_enc::rve_choose_color $i" 
[05/05 14:53:56     12s] 			trace variable mgc_enc::vars(rve_${i}_color)   w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/05 14:53:56     12s] 			trace variable mgc_enc::vars(rve_${i}_pattern) w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/05 14:53:56     12s] 			trace variable mgc_enc::vars(rve_${i}_width)   w "mgc_enc::rve_highlight_pattern_changed $i $c $pref_f.pattern_$i"
[05/05 14:53:56     12s] 			set vars(rve_${i}_color) $vars(rve_${i}_color)
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $pref_f -pady 1m -padx 2m -anchor s -fill x 
[05/05 14:53:56     12s] 		pack $options_f -pady 2m -expand yes -fill both -padx 2m -side top
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		frame $btns_f -relief raised -bd 1 
[05/05 14:53:56     12s] 		pack $btns_f -side bottom -fill x -anchor s
[05/05 14:53:56     12s] 		button $btns_f.save -width 7 -text "Save..." -command "mgc_enc::SaveRVELayerPreference $w"
[05/05 14:53:56     12s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetupRVEOK $w"
[05/05 14:53:56     12s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetupRVECancel $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $btns_f.save -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		focus $btns_f.ok
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $w.top -side top -fill both -expand yes
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		#uiprocs_PositionWindow $w . "center"
[05/05 14:53:56     12s] 		mgc_enc::PositionWindowOnRight $w
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	for {set i 0} {$i<16} {incr i} {
[05/05 14:53:56     12s] 		if { ![catch {getLayerPreference rve_$i -color} color] } {
[05/05 14:53:56     12s] 			set vars(rve_${i}_color) $color
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		if { ![catch {getLayerPreference rve_$i -stipple} stipple] } {
[05/05 14:53:56     12s] 			set bOther 1
[05/05 14:53:56     12s] 			foreach item $vars(rve_supported_patterns) {
[05/05 14:53:56     12s] 				if { [string equal -nocase $item $stipple] || $stipple=="" } { 
[05/05 14:53:56     12s] 					set vars(rve_${i}_pattern) $item
[05/05 14:53:56     12s] 					set bOther 0
[05/05 14:53:56     12s] 					break
[05/05 14:53:56     12s] 				}
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 			if { $bOther } { set vars(rve_${i}_pattern) Other }
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		if { ![catch {getLayerPreference rve_$i -isSelectable} isSelectable] } {
[05/05 14:53:56     12s] 			if { [string is boolean -strict $isSelectable] } {
[05/05 14:53:56     12s] 				set vars(rve_${i}_selectable) $isSelectable
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		if { ![catch {getLayerPreference rve_$i -lineWidth} lineWidth] } {
[05/05 14:53:56     12s] 			if { [string is integer -strict $lineWidth] } {
[05/05 14:53:56     12s] 				set vars(rve_${i}_width) $lineWidth
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	wm transient $w .
[05/05 14:53:56     12s] 	wm deiconify $w
[05/05 14:53:56     12s] 	mgc_enc::WaitForUpdate
[05/05 14:53:56     12s] 	raise $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# wait for return value to be set after grabbing focus
[05/05 14:53:56     12s] 	grab set $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	tkwait variable mgc_enc::vars(setupRVEStatus)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	grab release $w   ;# Make sure we let go of grab
[05/05 14:53:56     12s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $mgc_enc::vars(setupRVEStatus)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::setupSocket {} {
[05/05 14:53:56     12s] 	variable vars
[05/05 14:53:56     12s] 	append w .calibreSetupSocket
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set btns_f $w.top.btns
[05/05 14:53:56     12s] 	if {[winfo exists $w] == 0} {
[05/05 14:53:56     12s] 		toplevel $w
[05/05 14:53:56     12s] 		wm title $w "Calibre Setup Socket"
[05/05 14:53:56     12s] 		# Set the dialog up so that its width and height are resizable
[05/05 14:53:56     12s] 		wm resizable $w 1 1
[05/05 14:53:56     12s] 		wm withdraw $w
[05/05 14:53:56     12s] 		wm protocol $w WM_DELETE_WINDOW "mgc_enc::SetupSocketCancel $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		frame $w.top
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		bind $w <Escape> "mgc_enc::SetupSocketCancel $w"
[05/05 14:53:56     12s] 		bind $w <Return> "mgc_enc::SetupSocketOK $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		set options_f [frame $w.top.opts -relief groove -bd 2]
[05/05 14:53:56     12s] 		set socket_f [frame $options_f.socket_f]
[05/05 14:53:56     12s] 		set host_f   [frame $options_f.host_f]
[05/05 14:53:56     12s] 		pack [label $socket_f.label -pady 1 -text "Socket Number (-1 for auto):" -width 27 -anchor w] -side left
[05/05 14:53:56     12s] 		pack [entry $socket_f.entry -textvariable mgc_enc::vars(tmp_socket_number) -validate key -validatecommand "mgc_integer_only %P"] -side left -fill x -expand 1
[05/05 14:53:56     12s] 		pack [label $host_f.label -pady 1 -text "Host Name (empty for localhost):" -width 27 -anchor w] -side left
[05/05 14:53:56     12s] 		pack [entry $host_f.entry -textvariable mgc_enc::vars(tmp_socket_host) -validate key -validatecommand "mgc_no_white_spaces %P"] -side left -fill x -expand 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $socket_f -pady 0.5m -padx 2m -anchor s -fill x 
[05/05 14:53:56     12s] 		pack $host_f   -pady 0.5m -padx 2m -anchor s -fill x 
[05/05 14:53:56     12s] 		pack $options_f -pady 2m -expand yes -fill both -padx 2m -side top
[05/05 14:53:56     12s]  
[05/05 14:53:56     12s] 		frame $btns_f -relief raised -bd 1 
[05/05 14:53:56     12s] 		pack $btns_f -side bottom -fill x -anchor s
[05/05 14:53:56     12s] 		button $btns_f.ok -width 7 -text "OK" -command "mgc_enc::SetupSocketOK $w"
[05/05 14:53:56     12s] 		button $btns_f.cancel -width 7 -text "Cancel" -command "mgc_enc::SetupSocketCancel $w"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		pack $btns_f.ok -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 		pack $btns_f.cancel -expand 1 -padx 5m -pady 2m -side left
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		focus $btns_f.ok
[05/05 14:53:56     12s] 		pack $w.top -side top -fill both -expand yes
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		#uiprocs_PositionWindow $w . "center"
[05/05 14:53:56     12s] 		mgc_enc::PositionWindowOnRight $w
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set vars(tmp_socket_number) $vars(socket_number)
[05/05 14:53:56     12s] 	set vars(tmp_socket_host) $vars(socket_host)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	wm transient $w .
[05/05 14:53:56     12s] 	wm deiconify $w
[05/05 14:53:56     12s] 	mgc_enc::WaitForUpdate
[05/05 14:53:56     12s] 	raise $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# wait for return value to be set after grabbing focus
[05/05 14:53:56     12s] 	grab set $w
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	tkwait variable mgc_enc::vars(setupSocketStatus)
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	grab release $w   ;# Make sure we let go of grab
[05/05 14:53:56     12s] 	wm withdraw $w    ;# To allow reuse we just hide window
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	return $mgc_enc::vars(setupSocketStatus)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::clearHighlights {} {
[05/05 14:53:56     12s] 	mgc_rve_delete_markers "" 1
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getVersion {} {
[05/05 14:53:56     12s] 	if { [info commands eval_legacy] == "eval_legacy" } {
[05/05 14:53:56     12s] 		set version [::get_db program_version]
[05/05 14:53:56     12s] 	} else {
[05/05 14:53:56     12s] 		set version [::getVersion] ;# 15.13-s048_1
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	return $version
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::versionIsPre9 {} {
[05/05 14:53:56     12s]     set version [getVersion]
[05/05 14:53:56     12s]     regsub {\..*$} $version {} majVersion
[05/05 14:53:56     12s]     if {[string match "0*" $majVersion]} {
[05/05 14:53:56     12s]         set majVersion [string range $majVersion 1 end]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {$majVersion < 9} {
[05/05 14:53:56     12s]         return 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return 0
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::PositionWindowOnRight {w} {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {[mgc_enc::versionIsPre9]} {
[05/05 14:53:56     12s]         uiprocs_PositionWindow $w . "center"
[05/05 14:53:56     12s]     } else {
[05/05 14:53:56     12s] 	    global _ui_vars
[05/05 14:53:56     12s] 	    set geom [guiGet main -geometry]
[05/05 14:53:56     12s] 	    scan $geom "%dx%d+%d+%d" width height p_x p_y
[05/05 14:53:56     12s] 	    set x [expr $width+$p_x]
[05/05 14:53:56     12s] 	    set y $p_y
[05/05 14:53:56     12s] 	    wm withdraw $w
[05/05 14:53:56     12s] 	    mgc_enc::WaitForUpdate
[05/05 14:53:56     12s] 	    wm geometry $w +$x+$y
[05/05 14:53:56     12s] 	    if {$_ui_vars(IsPC)} {
[05/05 14:53:56     12s] 		    mgc_enc::WaitForUpdate      ;# required on pc to get positioning to occur
[05/05 14:53:56     12s] 	    }
[05/05 14:53:56     12s] 	    wm deiconify $w
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # Default layer preferences for RVE highlight
[05/05 14:53:56     12s] @proc mgc_enc::loadDefaultRVELayerPreference {} {
[05/05 14:53:56     12s] 	setLayerPreference rve_0  -color green      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_1  -color darkblue   -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_2  -color slateblue  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_3  -color turquoise  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_4  -color lightgray  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_5  -color wheat      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_6  -color goldenrod  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_7  -color yellow     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_8  -color sandybrown -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_9  -color coral      -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_10 -color red        -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_11 -color tomato     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_12 -color firebrick  -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_13 -color purple     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_14 -color violet     -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] 	setLayerPreference rve_15 -color tan        -isVisible 1 -isSelectable 1 -lineWidth 5 -stipple none
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # Here starts several procs to support user customization of the Calibre menu.
[05/05 14:53:56     12s] @proc mgc_enc::setMenuCmds {menu_cmds} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set vars(menuCmds) $menu_cmds
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getMenuCmds {} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     return $vars(menuCmds)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getAllCalibreMenuCmds {} {
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set ret_list [list]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     foreach m $vars(menuCmds) {
[05/05 14:53:56     12s]         if {[lindex $m 0] eq "command"} {
[05/05 14:53:56     12s]             set label [lindex $m 1]
[05/05 14:53:56     12s]             if {$label ne ""} {
[05/05 14:53:56     12s]                 append label "/"
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             append label [lindex $m 2]
[05/05 14:53:56     12s]             set cmd [lindex $m 6]
[05/05 14:53:56     12s]             lappend ret_list [list $label $cmd]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return $ret_list
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::applyCustomMenu {commonMenuFile encMenuFile} {
[05/05 14:53:56     12s]     global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set tclsh [file join $env(MGC_HOME) bin tclsh]
[05/05 14:53:56     12s]     set custom_parser [file join $env(MGC_HOME) shared pkgs icv tools custom custom_menu.tcl]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set outPath [file join [getTempDir] encInp.[pid].customMenu]
[05/05 14:53:56     12s]     set readOK 1
[05/05 14:53:56     12s]     if {[catch {exec $tclsh $custom_parser -common_file $commonMenuFile -viewer_file $encMenuFile -output_file $outPath} msg]} {
[05/05 14:53:56     12s]         regsub {child process exited abnormally} $msg {} msg
[05/05 14:53:56     12s]         puts "\n$msg"
[05/05 14:53:56     12s]         set readOK 0
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set first 1
[05/05 14:53:56     12s]     set menuCmds [list]
[05/05 14:53:56     12s]     set fp [open $outPath r]
[05/05 14:53:56     12s]     while {[gets $fp cmd]!=-1} {
[05/05 14:53:56     12s]         if {$first} {
[05/05 14:53:56     12s]         # Ignore header line.
[05/05 14:53:56     12s]             set first 0
[05/05 14:53:56     12s]             continue
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         set splist [split $cmd ","]
[05/05 14:53:56     12s]         lappend menuCmds $splist
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     close $fp
[05/05 14:53:56     12s]     file delete -force $outPath
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$readOK && [info exists env(MGC_CALIBRE_VIEWER_MENU_CMDS)]} {
[05/05 14:53:56     12s]         puts "Successfully read Calibre menu customization file \"$env(MGC_CALIBRE_VIEWER_MENU_CMDS)\""
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     return $menuCmds
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::runUserCmd {cmdIdx} {
[05/05 14:53:56     12s]     variable userCmds
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s]     global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {![info exists userCmds($cmdIdx)]} {
[05/05 14:53:56     12s]         return
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     foreach {label command commandType envVars code} $userCmds($cmdIdx) {break}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {[string match "::CalibreInterface::execCalibre*" $command] || [string match "::CalibreInterface::execNewCalibre*" $command] || $commandType eq "BI"} {
[05/05 14:53:56     12s]         # This is a builtin; call the function.
[05/05 14:53:56     12s]         return [eval $command]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set curr_cell_name ""
[05/05 14:53:56     12s]     if {$commandType ne "RVE" && $commandType ne "CUSTOM"} {
[05/05 14:53:56     12s]         if {[getTopCell]==0} {
[05/05 14:53:56     12s]             ShowError "No layout exists.\nPlease load a layout before attempting to run $commandType."
[05/05 14:53:56     12s]             return
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set curr_cell_name [getCellName [getTopCell]]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {$code ne ""} {
[05/05 14:53:56     12s]         if {[catch {eval $code} msg]} {
[05/05 14:53:56     12s]             ShowError "Problem executing code snippet specified with -code.
[05/05 14:53:56     12s]                 Error message:
[05/05 14:53:56     12s]                 $msg
[05/05 14:53:56     12s]                 "
[05/05 14:53:56     12s]             return
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if {[mgc_enc::CheckEnv] eq ""} {
[05/05 14:53:56     12s]         ShowError "Can't start RVE server"
[05/05 14:53:56     12s]         return
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # A custom command.
[05/05 14:53:56     12s]     set tool [string tolower $commandType]
[05/05 14:53:56     12s]     set do_trigger 0
[05/05 14:53:56     12s]     set doSetup 0
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # check if the process was already started (if MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL)
[05/05 14:53:56     12s]     set fid ""
[05/05 14:53:56     12s]     if { [info exists ::env(MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL)] &&
[05/05 14:53:56     12s]         $::env(MGC_CALIBRE_VIEWER_MENU_CMDS_SINGLE_TOOL) ne "0" } {
[05/05 14:53:56     12s]         set fid [CheckGUI $curr_cell_name $tool $command]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     if {$fid eq ""} {
[05/05 14:53:56     12s]         # We need to start the process.
[05/05 14:53:56     12s]         # we will call rdrc_SetupDRC not rdrc_RunDRC (or lvs, etc..)
[05/05 14:53:56     12s]         set doSetup 1
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         # Write a script to setup the environment
[05/05 14:53:56     12s]         set scriptPath [file join [getTempDir] encounterScript.[pid].$commandType]
[05/05 14:53:56     12s]         if {[catch {set wf [open $scriptPath w]} msg]} {
[05/05 14:53:56     12s]             ShowError "Cannot create temporary file $scriptPath.
[05/05 14:53:56     12s] Error message:
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] $msg
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] "
[05/05 14:53:56     12s]             return
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         puts $wf "#!/bin/sh"
[05/05 14:53:56     12s]         foreach envpair $envVars {
[05/05 14:53:56     12s]             if {[string match "=*" $envpair]} {
[05/05 14:53:56     12s]             # We want to unset the envar.
[05/05 14:53:56     12s]                 regsub {=} $envpair {} envarname
[05/05 14:53:56     12s]                 puts $wf "unset $envarname"
[05/05 14:53:56     12s]             } else {
[05/05 14:53:56     12s]             # We want to set the envar.
[05/05 14:53:56     12s]                 regsub {=.*} $envpair {} exportvar
[05/05 14:53:56     12s]                 puts $wf $envpair
[05/05 14:53:56     12s]                 puts $wf "export $exportvar"
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         puts $wf ""
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         # Standard socket server stuff.
[05/05 14:53:56     12s]         puts $wf "MGC_CGI_MONITOR_STDIN=1"
[05/05 14:53:56     12s]         puts $wf "export MGC_CGI_MONITOR_STDIN"
[05/05 14:53:56     12s]         puts $wf "MGC_CALIBRE_LAYOUT_SERVER_NAME=Cadence:Encounter"
[05/05 14:53:56     12s]         puts $wf "export MGC_CALIBRE_LAYOUT_SERVER_NAME"
[05/05 14:53:56     12s]         set sockNum [GetDefaultSocket]
[05/05 14:53:56     12s]         foreach {host port} $sockNum {break}
[05/05 14:53:56     12s]         puts $wf "MGC_CALIBRE_LAYOUT_SERVER=$host:$port"
[05/05 14:53:56     12s]         puts $wf "export MGC_CALIBRE_LAYOUT_SERVER"
[05/05 14:53:56     12s]         puts $wf "MGC_RVE_HILIGHT_SHORT_TEXT_CMDS=1"
[05/05 14:53:56     12s]         puts $wf "export MGC_RVE_HILIGHT_SHORT_TEXT_CMDS"
[05/05 14:53:56     12s]         puts $wf ""
[05/05 14:53:56     12s]         puts $wf $command
[05/05 14:53:56     12s]         if {![info exists env(MGC_CALIBRE_ECHO_VIEWER_MENU_CMDS)]} {
[05/05 14:53:56     12s]             puts $wf "rm $scriptPath"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         close $wf
[05/05 14:53:56     12s]         file attributes $scriptPath -permissions 0777
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if {$commandType ne "RVE" && $commandType ne "CUSTOM"} {
[05/05 14:53:56     12s]             if {[namespace eval "::" {info procs "mgc_start_calibre_trigger"}] ne ""} {
[05/05 14:53:56     12s]                 set do_trigger 1
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         if {$do_trigger} {
[05/05 14:53:56     12s]             mgc_start_calibre_trigger $tool $curr_cell_name
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if {[catch {set fid [open "| $scriptPath 2>@ stdout" "r+"]} cmsg]==0} {
[05/05 14:53:56     12s]             fconfigure $fid -blocking 0 -buffering line
[05/05 14:53:56     12s]             if {$commandType eq "RVE"} {
[05/05 14:53:56     12s]                 fileevent $fid readable [list mgc_enc::ReadRVE $fid]
[05/05 14:53:56     12s]                 lappend vars(rve_fids) $fid
[05/05 14:53:56     12s]             } elseif {$commandType ne "CUSTOM"} {
[05/05 14:53:56     12s]                 fileevent $fid readable [list mgc_enc::ReadGUI $fid $curr_cell_name $tool $command]
[05/05 14:53:56     12s]                 # See CheckGUI. Need to remember the fid by tool, command, and cell for a custom command
[05/05 14:53:56     12s]                 set vars(${tool},${command},${curr_cell_name}) $fid
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if {[info exists env(MGC_CALIBRE_ECHO_VIEWER_MENU_CMDS)]} {
[05/05 14:53:56     12s]             puts "Starting verification menu user command $scriptPath"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     # Now the process was either already started, or just started.  For CI we need to send
[05/05 14:53:56     12s]     # either rdrc_SetupDRC or rdrc_RunDRC (or lvs, etc..). The rdrc_RunDRC cmd will also pop the CI window
[05/05 14:53:56     12s]     if {$fid ne ""} {
[05/05 14:53:56     12s]         if {$commandType ne "CUSTOM"} {
[05/05 14:53:56     12s]             #set alib [get_attribute $lib_obj full_name]
[05/05 14:53:56     12s]             #set aview [get_attribute $lib_obj view_name]
[05/05 14:53:56     12s]             if {$doSetup} {
[05/05 14:53:56     12s]                 set rcmd r${tool}_Setup$commandType
[05/05 14:53:56     12s]             } else {
[05/05 14:53:56     12s]                 set rcmd r${tool}_Run$commandType
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             puts $fid "$rcmd $curr_cell_name"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::getUserCmds {} {
[05/05 14:53:56     12s]     variable userCmds
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set ret_list [list]
[05/05 14:53:56     12s]     foreach key [lsort -dict [array names userCmds]] {
[05/05 14:53:56     12s]         regsub -all {&} $userCmds($key) {} value
[05/05 14:53:56     12s]         lappend ret_list "$key $value"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return $ret_list
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::createUserMenuCommand {cmd label commandType command envVars code} {
[05/05 14:53:56     12s]     variable userCmds
[05/05 14:53:56     12s]     variable vars
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set idx $vars(userCmdIdx)
[05/05 14:53:56     12s]     incr vars(userCmdIdx)
[05/05 14:53:56     12s]     set userCmds($idx) [list $label $command $commandType $envVars $code]
[05/05 14:53:56     12s]     lappend cmd -command [list mgc_enc::runUserCmd $idx]
[05/05 14:53:56     12s]     eval $cmd
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc getTempDir {} {
[05/05 14:53:56     12s]     set tempDir ""
[05/05 14:53:56     12s]     if { [info exists ::env(MGC_TMPDIR)] && [file isdirectory $::env(MGC_TMPDIR)] && [file writable $::env(MGC_TMPDIR)] } {
[05/05 14:53:56     12s]         set tempDir $::env(MGC_TMPDIR)
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if { $tempDir eq "" && [info exists ::env(MGC_HOME)] && [file exists $::env(MGC_HOME)] } {
[05/05 14:53:56     12s]         set path [file join $::env(MGC_HOME) tmp]
[05/05 14:53:56     12s]         if { [file isdirectory $path] && [file writable $path] } {
[05/05 14:53:56     12s]             set tempDir $path
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if { $tempDir eq "" && [file exists "/usr/tmp"] && [file writable "/usr/tmp"]} {
[05/05 14:53:56     12s]         set tempDir "/usr/tmp"
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if { $tempDir eq "" && [info exists ::env(HOME)] } {
[05/05 14:53:56     12s]         if { [file exists $::env(HOME)] && [file writable $::env(HOME)] } {
[05/05 14:53:56     12s]             set tempDir $::env(HOME)
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     if { $tempDir eq "" && [file writable "."] } {
[05/05 14:53:56     12s]         set tempDir "."
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s]     return $tempDir
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # End customization support code.
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] #===============================================================================
[05/05 14:53:56     12s] # Innovus Legacy and Common UI mode APIs
[05/05 14:53:56     12s] #===============================================================================
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @if { [mgc_enc_is_common_ui_mode] } {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# Innovus Common UI mode APIs: is_common_ui_mode
[05/05 14:53:56     12s] 	proc mgc_enc::is_common_ui_mode {} { return 1 }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	interp alias {} mgc_enc::getAllLayers {} ::get_all_layers
[05/05 14:53:56     12s] 	interp alias {} mgc_env::streamOut    {} ::write_stream
[05/05 14:53:56     12s] 	interp alias {} mgc_enc::redraw       {} ::gui_redraw
[05/05 14:53:56     12s] 	interp alias {} mgc_enc::fit          {} ::gui_fit
[05/05 14:53:56     12s] 	interp alias {} mgc_enc::zoomBox      {} ::zoom_box
[05/05 14:53:56     12s] 	interp alias {} mgc_enc::zoomOut      {} ::zoom_out
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# DR1368504: zoom_box command no longer available in Innovus 18.10
[05/05 14:53:56     12s] 	if { [info commands gui_zoom]=="gui_zoom" } {
[05/05 14:53:56     12s] 		proc mgc_enc::zoomBox {args} {
[05/05 14:53:56     12s] 			gui_zoom -rect $args
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		proc mgc_enc::zoomIn {} {
[05/05 14:53:56     12s] 			gui_zoom -in
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		proc mgc_enc::zoomOut {} {
[05/05 14:53:56     12s] 			gui_zoom -out
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiFind {args} {
[05/05 14:53:56     12s] 		return [eval gui_find_ui $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiAdd {args} {
[05/05 14:53:56     12s] 		return [eval gui_add_ui $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGet {args} {
[05/05 14:53:56     12s] 		return [eval gui_get_ui $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiSet {args} {
[05/05 14:53:56     12s] 		return [eval gui_set_ui $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiViewBox {} {
[05/05 14:53:56     12s] 		return [gui_view_box]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetBox {} {
[05/05 14:53:56     12s] 		return [gui_get_box]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetPoly {} {
[05/05 14:53:56     12s] 		return [gui_get_coords]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetCoord {} {
[05/05 14:53:56     12s] 		return [gui_get_coord]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getLayerByName {layerName} {
[05/05 14:53:56     12s] 		# realtime/innovus-common-ui/cto_file_layer_visibility
[05/05 14:53:56     12s] 		# with edi_tcl_flow_half_adder in CUI mode:
[05/05 14:53:56     12s] 		#    OK: eval_legacy "dbGetLayerByName M0" => 0x7faf0f2ce800
[05/05 14:53:56     12s] 		#   NOK: get_db layers -if { .name=="M0" } => ""
[05/05 14:53:56     12s] 		# see also ::calibre::realtime::getLayerByName
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		return [eval_legacy "dbGetLayerByName $layerName"]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 		if { 0 } {
[05/05 14:53:56     12s] 			set layers [get_all_layers metal]
[05/05 14:53:56     12s] 			set layer [get_db layers -if { .name==$layerName }]
[05/05 14:53:56     12s] 			if { $layer=="" } {
[05/05 14:53:56     12s] 				set layer 0
[05/05 14:53:56     12s] 			}
[05/05 14:53:56     12s] 			return $layer
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getTopCell {} {
[05/05 14:53:56     12s] 		set design [get_db current_design]
[05/05 14:53:56     12s] 		if { $design=="" } {
[05/05 14:53:56     12s] 			set design 0
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return $design
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getCellName {cell} {
[05/05 14:53:56     12s] 		return [get_db $cell .name]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	#-------------------------------------------------------------------------------
[05/05 14:53:56     12s] 	# getLayerPreference/setLayerPreference
[05/05 14:53:56     12s] 	#-------------------------------------------------------------------------------
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::mapLegacyArgs {map legacyArgs} {
[05/05 14:53:56     12s] 		set newArgs [list]
[05/05 14:53:56     12s] 		foreach arg $legacyArgs {
[05/05 14:53:56     12s] 			lappend newArgs [string map $map $arg]
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return $newArgs
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::mapLegacyLayerPreferenceArgs {legacyArgs} {
[05/05 14:53:56     12s] 		set map {-isVisible -is_visible -isSelectable -is_selectable -lineWidth -line_width -stippleData -stipple_data}
[05/05 14:53:56     12s] 		set newArgs [mapLegacyArgs $map $legacyArgs]
[05/05 14:53:56     12s] 		return $newArgs
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getLayerPreference {args} {
[05/05 14:53:56     12s] 		set cmd "get_layer_preference [mapLegacyLayerPreferenceArgs $args]"
[05/05 14:53:56     12s] 		return [eval $cmd]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::setLayerPreference {args} {
[05/05 14:53:56     12s] 		set cmd "set_layer_preference [mapLegacyLayerPreferenceArgs $args]"
[05/05 14:53:56     12s] 		return [eval $cmd]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiRect {layer x1 y1 x2 y2} {
[05/05 14:53:56     12s] 		return [create_gui_shape -layer $layer -rect [list $x1 $y1 $x2 $y2]]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiLine {layer args} {
[05/05 14:53:56     12s] 		return [create_gui_shape -layer $layer -line $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiPoly {layer args} {
[05/05 14:53:56     12s] 		return [create_gui_shape -layer $layer -polygon $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiText {layer txt x y size} {
[05/05 14:53:56     12s] 		return [create_gui_text -layer $layer -label $txt -pt [list $x $y] -height $size]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::deleteGuiObj {obj} {
[05/05 14:53:56     12s] 		set selected [get_db selected]
[05/05 14:53:56     12s] 		deselect_obj -all
[05/05 14:53:56     12s] 		select_obj $obj
[05/05 14:53:56     12s] 		gui_delete_object -selected
[05/05 14:53:56     12s] 		select_obj $selected
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::deleteCustomLayer {layer} {
[05/05 14:53:56     12s] 		eval_legacy "::deleteCustomLayer $layer"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportCmd {fileName args} {
[05/05 14:53:56     12s] 		set map { \
[05/05 14:53:56     12s] 			-attachInstanceName  -attach_inst_name     \
[05/05 14:53:56     12s] 			-attachNetName       -attach_net_name      \
[05/05 14:53:56     12s] 			-attachNetProp       -attach_net_attribute \
[05/05 14:53:56     12s] 			-dieAreaAsBoundary   -die_area_as_boundary \
[05/05 14:53:56     12s] 			-libName             -lib_name             \
[05/05 14:53:56     12s] 			-mapFile             -map_file             \
[05/05 14:53:56     12s] 			-noStructureName     -no_structure_name    \
[05/05 14:53:56     12s] 			-outputMacros        -output_macros        \
[05/05 14:53:56     12s] 			-reportFile          -report_file          \
[05/05 14:53:56     12s] 			-structureName       -structure_name       \
[05/05 14:53:56     12s] 			-uniquifyCellNames   -uniquify_cell_names  \
[05/05 14:53:56     12s] 			-units               -unit                 \
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return "write_stream $fileName [join [mapLegacyArgs $map $args]]"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportDefCmd {fileName args} {
[05/05 14:53:56     12s] 	# common ui: write_def
[05/05 14:53:56     12s] 	# legacy: defOut
[05/05 14:53:56     12s] 		set map { \
[05/05 14:53:56     12s] 			-addHalfWireExtensionOnPin  -add_half_wire_extension_on_pin     \
[05/05 14:53:56     12s] 			-allLayers            -all_layers          \
[05/05 14:53:56     12s] 			-bumpAsPin            -bump_as_pin         \
[05/05 14:53:56     12s] 			-cutRow               -cut_row             \
[05/05 14:53:56     12s] 			-earlyGlobalRoute     -early_global_route  \
[05/05 14:53:56     12s] 			-ioRow                -io_row              \
[05/05 14:53:56     12s] 			-noCoreCells          -no_core_cells       \
[05/05 14:53:56     12s] 			-noSpecialNet         -no_special_net      \
[05/05 14:53:56     12s] 			-noStdCells           -no_std_cells        \
[05/05 14:53:56     12s] 			-noTracks             -no_tracks           \
[05/05 14:53:56     12s] 			-outputMaskLayers     -output_mask_Layers  \
[05/05 14:53:56     12s] 			-scanChain            -scan_chain          \
[05/05 14:53:56     12s] 			-usedVia              -used_via            \
[05/05 14:53:56     12s] 			-withShield           -with_shield         \
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return "write_def $fileName [join [mapLegacyArgs $map $args]]"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportVerilogCmd {fileName args} {
[05/05 14:53:56     12s] 	# common ui: write_netlist
[05/05 14:53:56     12s] 	# legacy: saveNetlist
[05/05 14:53:56     12s] 		set map { \
[05/05 14:53:56     12s] 			-excludeCellInst      -exclude_insts_of_cells \
[05/05 14:53:56     12s] 			-excludeLeafCell      -exclude_leaf_cells     \
[05/05 14:53:56     12s] 			-excludeTopCellPGPort -exclude_top_pg_ports   \
[05/05 14:53:56     12s] 			-flattenBus           -flatten_bus            \
[05/05 14:53:56     12s] 			-includeBumpCell      -include_bump_cells     \
[05/05 14:53:56     12s] 			-includePhysicalCell  -include_phys_cells     \
[05/05 14:53:56     12s] 			-includePhysicalInst  -include_phys_insts     \
[05/05 14:53:56     12s] 			-includePowerGround   -include_pg_ports       \
[05/05 14:53:56     12s] 			-keepAllBackslash     -keep_all_backslash     \
[05/05 14:53:56     12s] 			-lineLength           -line_length            \
[05/05 14:53:56     12s] 			-omitFloatingPort     -omit_floating_ports    \
[05/05 14:53:56     12s] 			-onlyLeafCell         -only_leaf_cells        \
[05/05 14:53:56     12s] 			-onlyMacro            -only_blocks            \
[05/05 14:53:56     12s] 			-onlyStdCell          -only_std_cells         \
[05/05 14:53:56     12s] 			-replaceTieConnection -update_tie_connections \
[05/05 14:53:56     12s] 			-topCell              -top_module             \
[05/05 14:53:56     12s] 			-topModuleFirst       -top_module_first       \
[05/05 14:53:56     12s] 			-usePGPorts           -use_pg_ports           \
[05/05 14:53:56     12s] 		}
[05/05 14:53:56     12s] 		return "write_netlist $fileName [join [mapLegacyArgs $map $args]]"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] } else {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	# Innovus legacy mode APIs
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::is_common_ui_mode {} { return 0 }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiFind {args} {
[05/05 14:53:56     12s] 		return [eval uiFind $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiAdd {args} {
[05/05 14:53:56     12s] 		return [eval uiAdd $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGet {args} {
[05/05 14:53:56     12s] 		return [eval uiGet $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiSet {args} {
[05/05 14:53:56     12s] 		return [eval uiSet $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiViewBox {} {
[05/05 14:53:56     12s] 		return [ui_view_box]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetBox {} {
[05/05 14:53:56     12s] 		return [uiGetBox]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetPoly {} {
[05/05 14:53:56     12s] 		return [uiGetCoords]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::guiGetCoord {} {
[05/05 14:53:56     12s] 		return [uiGetCoord]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getLayerByName {layerName} {
[05/05 14:53:56     12s] 		return [dbGetLayerByName $layerName]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getTopCell {} {
[05/05 14:53:56     12s] 		return [dbgTopCell]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getCellName {cell} {
[05/05 14:53:56     12s] 		return [dbCellName $cell]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiRect {layer x1 y1 x2 y2} {
[05/05 14:53:56     12s] 		return [addCustomBox $layer $x1 $y1 $x2 $y2]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiLine {layer x1 y1 x2 y2} {
[05/05 14:53:56     12s] 		return [addCustomLine $layer $x1 $y1 $x2 $y2]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiPoly {layer args} {
[05/05 14:53:56     12s] 		return [eval addCustomLine $layer $args]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::createGuiText {layer txt x y size} {
[05/05 14:53:56     12s] 		return [addCustomText $layer $txt $x $y $size]
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::deleteGuiObj {obj} {
[05/05 14:53:56     12s] 		dbDeleteObj $obj
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::deleteCustomLayer {layer} {
[05/05 14:53:56     12s] 		::deleteCustomLayer $layer
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportCmd {fileName args} {
[05/05 14:53:56     12s] 		return "streamOut $fileName [join $args]"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportDefCmd {fileName args} {
[05/05 14:53:56     12s] 		return "defOut [join $args] $fileName"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	proc mgc_enc::getExportVerilogCmd {fileName args} {
[05/05 14:53:56     12s] 		return "saveNetlist $fileName [join $args]"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # Based on Encounter documentation: The initialization files are read in the following sequence:
[05/05 14:53:56     12s] # 1. .encrc in the home directory
[05/05 14:53:56     12s] # 2. .encrc in the working directory
[05/05 14:53:56     12s] # 3. enc.pref.tcl in the working directory
[05/05 14:53:56     12s] # 4. .enc in the home directory
[05/05 14:53:56     12s] # 5. enc.tcl in the installation/etc directory
[05/05 14:53:56     12s] # 6. enc.tcl in the home directory
[05/05 14:53:56     12s] # 7. enc.tcl in the working directory
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @catch { mgc_enc::initRveHighlightPatterns }
[05/05 14:53:56     12s] @catch { mgc_enc::loadDefaultRVELayerPreference }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ################################################################################
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @if {[info exists env(MGC_RVE_INIT_SOCKET_AT_STARTUP)]} {
[05/05 14:53:56     12s] 	mgc_enc::initServerSocket
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @proc mgc_enc::show_banner {} {
[05/05 14:53:56     12s] 	global env
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	if {![info exists env(MGC_HOME)] || $env(MGC_HOME)==""} {
[05/05 14:53:56     12s] 		ShowError "MGC_HOME environment variable is not set!"
[05/05 14:53:56     12s] 		return
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 	set version ""
[05/05 14:53:56     12s] 	set vfile [file join $env(MGC_HOME) pkgs icv dependencies version]
[05/05 14:53:56     12s] 	if {[file exists $vfile] && [file readable $vfile]} {
[05/05 14:53:56     12s] 		set f [open $vfile r]
[05/05 14:53:56     12s] 		set version [gets $f]
[05/05 14:53:56     12s] 		close $f
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] 	puts "//"
[05/05 14:53:56     12s] 	puts "//  Calibre Encounter/Innovus Interface * ($version) *"
[05/05 14:53:56     12s] 	puts "//"
[05/05 14:53:56     12s] 	puts "//                           Copyright Siemens 1996-2020     "
[05/05 14:53:56     12s] 	puts "//                             All Rights Reserved."
[05/05 14:53:56     12s] 	puts "//         THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION"
[05/05 14:53:56     12s] 	puts "//            WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION"
[05/05 14:53:56     12s] 	puts "//              OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS."
[05/05 14:53:56     12s] 	puts "//"
[05/05 14:53:56     12s] 	# RealTime and CI interface are no longer in beta.
[05/05 14:53:56     12s] 	if { 0 } {
[05/05 14:53:56     12s] 		puts "//        This software is in pre-production form and is considered to be"
[05/05 14:53:56     12s] 		puts "//        beta code that is subject to the terms of the current Mentor"
[05/05 14:53:56     12s] 		puts "//        Graphics End-User License Agreement or your signed agreement"
[05/05 14:53:56     12s] 		puts "//        with Mentor Graphics that contains beta terms, whichever applies."
[05/05 14:53:56     12s] 		puts "//"
[05/05 14:53:56     12s] 	}
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @mgc_enc::show_banner
[05/05 14:53:56     12s] //
[05/05 14:53:56     12s] //  Calibre Encounter/Innovus Interface * (v2021.1_33.19) *
[05/05 14:53:56     12s] //
[05/05 14:53:56     12s] //                           Copyright Siemens 1996-2020     
[05/05 14:53:56     12s] //                             All Rights Reserved.
[05/05 14:53:56     12s] //         THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION
[05/05 14:53:56     12s] //            WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION
[05/05 14:53:56     12s] //              OR ITS LICENSORS AND IS SUBJECT TO LICENSE TERMS.
[05/05 14:53:56     12s] //
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/encounter.tcl'.
[05/05 14:53:56     12s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/enc_rdb.tcl' ...
[05/05 14:53:56     12s] #************************************************************************CPY11*#
[05/05 14:53:56     12s] #*   Copyright Mentor Graphics Corporation 2014  All Rights Reserved.    CPY12*#
[05/05 14:53:56     12s] #*                                                                       CPY13*#
[05/05 14:53:56     12s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/05 14:53:56     12s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/05 14:53:56     12s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/05 14:53:56     12s] #*                                                                       CPY17*#
[05/05 14:53:56     12s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/05 14:53:56     12s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/05 14:53:56     12s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/05 14:53:56     12s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/05 14:53:56     12s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/05 14:53:56     12s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/05 14:53:56     12s] #*   particular purpose.                                                 CPY1E*#
[05/05 14:53:56     12s] #*                                                                       CPY1F*#
[05/05 14:53:56     12s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/05 14:53:56     12s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/05 14:53:56     12s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/05 14:53:56     12s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/05 14:53:56     12s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/05 14:53:56     12s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/05 14:53:56     12s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/05 14:53:56     12s] #*   to the claim                                                        CPY1N*#
[05/05 14:53:56     12s] #************************************************************************CPY1O*#
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # This contains Tcl procs specific to integration of Encounter with RVE and Calibre
[05/05 14:53:56     12s] # Interactive for creating DRC markers and route blockages.
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @source [file join $::env(MGC_HOME) shared pkgs icv tools querytcl import_rdb.tcl]
[05/05 14:53:56     12s] ### Start verbose source output (echo_comments mode) for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/querytcl/import_rdb.tcl' ...
[05/05 14:53:56     12s] #************************************************************************CPY11*#
[05/05 14:53:56     12s] #*   Copyright Mentor Graphics Corporation 2014  All Rights Reserved.    CPY12*#
[05/05 14:53:56     12s] #*                                                                       CPY13*#
[05/05 14:53:56     12s] #*   THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION         CPY14*#
[05/05 14:53:56     12s] #*   WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS         CPY15*#
[05/05 14:53:56     12s] #*   LICENSORS AND IS SUBJECT TO LICENSE TERMS.                          CPY16*#
[05/05 14:53:56     12s] #*                                                                       CPY17*#
[05/05 14:53:56     12s] #*   DISCLAIMER OF WARRANTY:  Unless otherwise agreed in writing,        CPY18*#
[05/05 14:53:56     12s] #*   Mentor Graphics software and associated files are provided          CPY19*#
[05/05 14:53:56     12s] #*   "as is" and without warranty.  Mentor Graphics has no obligation    CPY1A*#
[05/05 14:53:56     12s] #*   to support or otherwise maintain software.  Mentor Graphics         CPY1B*#
[05/05 14:53:56     12s] #*   makes no warranties, express or implied with respect to software    CPY1C*#
[05/05 14:53:56     12s] #*   including any warranty of merchantability or fitness for a          CPY1D*#
[05/05 14:53:56     12s] #*   particular purpose.                                                 CPY1E*#
[05/05 14:53:56     12s] #*                                                                       CPY1F*#
[05/05 14:53:56     12s] #*   LIMITATION OF LIABILITY: Mentor Graphics is not liable for any      CPY1G*#
[05/05 14:53:56     12s] #*   property damage, personal injury, loss of profits, interruption     CPY1H*#
[05/05 14:53:56     12s] #*   of business, or for any other special, consequential or             CPY1I*#
[05/05 14:53:56     12s] #*   incidental damages, however caused, whether for breach of           CPY1J*#
[05/05 14:53:56     12s] #*   warranty, contract, tort (including negligence), strict             CPY1K*#
[05/05 14:53:56     12s] #*   liability or otherwise. In no event shall Mentor Graphics'          CPY1L*#
[05/05 14:53:56     12s] #*   liability exceed the amount paid for the product giving rise        CPY1M*#
[05/05 14:53:56     12s] #*   to the claim                                                        CPY1N*#
[05/05 14:53:56     12s] #************************************************************************CPY1O*#
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] # This contains Tcl procs specific to integration of ICCompiler and EDI with RVE and Calibre
[05/05 14:53:56     12s] # Interactive for creating DRC markers and route guides/blockages.
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @if {[info exists env(CALIBRE_HOME)] && ($env(CALIBRE_HOME) != "")} {
[05/05 14:53:56     12s]     set env(MGC_HOME) $env(CALIBRE_HOME)
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @namespace eval Calibre::import_rdb {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     namespace export *
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     ################################################################################
[05/05 14:53:56     12s]     # Parse the list of arguments into an array
[05/05 14:53:56     12s]     ################################################################################
[05/05 14:53:56     12s]     proc ParseArguments { argList } {
[05/05 14:53:56     12s]       array set retArguments {}
[05/05 14:53:56     12s]       set standAloneArgIdx 0
[05/05 14:53:56     12s]       set argListLength [llength $argList]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       for {set argIndex 0} {$argIndex < $argListLength} {incr argIndex} {
[05/05 14:53:56     12s]         set thisArgument [lindex $argList $argIndex]
[05/05 14:53:56     12s]         if { ([string index $thisArgument 0] eq "-") && (![string is digit [string index $thisArgument 1]]) } {
[05/05 14:53:56     12s]           # This arg is a switch
[05/05 14:53:56     12s]           if { [expr {$argIndex+1}] < $argListLength } {
[05/05 14:53:56     12s]             # Check next argument
[05/05 14:53:56     12s]             set nextArgument [lindex $argList [expr {$argIndex+1}]]
[05/05 14:53:56     12s]             if { ([string index $nextArgument 0] ne "-") || ([string is digit [string index $nextArgument 1]]) } {
[05/05 14:53:56     12s]               set retArguments($thisArgument) $nextArgument
[05/05 14:53:56     12s]               incr argIndex
[05/05 14:53:56     12s]               continue
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]           }
[05/05 14:53:56     12s]           # This arg is a flag
[05/05 14:53:56     12s]           set retArguments($thisArgument) ""
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]           # This arg is a stand-alone argument
[05/05 14:53:56     12s]           set retArguments($standAloneArgIdx) $thisArgument
[05/05 14:53:56     12s]           incr standAloneArgIdx
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       return [array get retArguments]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/querytcl/import_rdb.tcl'.
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @namespace eval Calibre {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     namespace export convert_to_drc_errors convert_to_route_blockages import_drc_errors import_route_blockages
[05/05 14:53:56     12s]     namespace import ::Calibre::import_rdb::*
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc import_drc_errors { fileName } {
[05/05 14:53:56     12s]         return [::Calibre::marker_if::import_file $fileName]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc import_route_blockages { fileName } {
[05/05 14:53:56     12s]         return [::Calibre::route_if::import_file $fileName]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc convert_rdb { import_proc args } {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       set calibre "$::env(MGC_HOME)/bin/calibre"
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       set rve_com [list $calibre -rve]
[05/05 14:53:56     12s]       lappend rve_com [join $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       array unset arguments
[05/05 14:53:56     12s]       array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       set to_import_file ""
[05/05 14:53:56     12s]       if { ![info exists arguments(-output_file)] } {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [info exists ::env(MGC_TMPDIR)] } {
[05/05 14:53:56     12s]           if { [file exists $::env(MGC_TMPDIR)] } {
[05/05 14:53:56     12s]             set to_import_file $::env(MGC_TMPDIR)
[05/05 14:53:56     12s]           }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $to_import_file eq "" && [info exists ::env(MGC_HOME)] } {
[05/05 14:53:56     12s]           if { [file exists $::env(MGC_HOME)] } {
[05/05 14:53:56     12s]             set to_import_file $::env(MGC_HOME)
[05/05 14:53:56     12s]             set to_import_file "$to_import_file/tmp"
[05/05 14:53:56     12s]             if { ![file exists $to_import_file] } {
[05/05 14:53:56     12s]               set to_import_file ""
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]           }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $to_import_file eq "" && [file exists "/usr/tmp"] } {
[05/05 14:53:56     12s]           set to_import_file "/usr/tmp"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $to_import_file eq "" } {
[05/05 14:53:56     12s]           set to_import_file "."
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         # Temporary file for storing Stuttgard commands
[05/05 14:53:56     12s]         set to_import_file "$to_import_file/mgc_rve_rdb[pid]"
[05/05 14:53:56     12s]         lappend rve_com -output_file $to_import_file
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       # lappend rve_com -no_command_in_transcript
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       # Run RVE
[05/05 14:53:56     12s]       set rveStatus [catch {eval exec $rve_com} result]
[05/05 14:53:56     12s]       puts $result
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       if { $rveStatus ne 0 } {
[05/05 14:53:56     12s]         puts "\nConversion failed.\n"
[05/05 14:53:56     12s]         return 1
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       if { $to_import_file eq "" } {
[05/05 14:53:56     12s]         puts "RDB conversion successful."
[05/05 14:53:56     12s]         return 0
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       set retStatus [catch {eval $import_proc $to_import_file} result]
[05/05 14:53:56     12s]       if { $retStatus ne 0 } {
[05/05 14:53:56     12s]       	puts $result
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       if { ($to_import_file ne "") && [file exists $to_import_file] } {
[05/05 14:53:56     12s]         if { (![info exists ::env(MGC_RVE_HILIGHT_DEBUG)]) || \
[05/05 14:53:56     12s]              ($::env(MGC_RVE_HILIGHT_DEBUG) == 0) } {
[05/05 14:53:56     12s]           file delete $to_import_file
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]       return $retStatus
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc convert_to_drc_errors { args } {
[05/05 14:53:56     12s]       puts "\nCommand:  convert_to_drc_errors $args\n"
[05/05 14:53:56     12s]       set retStatus [catch {eval convert_rdb Calibre::import_drc_errors -wrapper ::Calibre::convert_to_drc_errors -convert_to edi_drc $args} result]
[05/05 14:53:56     12s]       if { $retStatus ne 0 } {
[05/05 14:53:56     12s]       	return 0
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       return 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc convert_to_route_blockages { args } {
[05/05 14:53:56     12s]       puts "\nCommand:  convert_to_route_blockages $args\n"
[05/05 14:53:56     12s]       set retStatus [catch {eval convert_rdb Calibre::import_route_blockages -wrapper ::Calibre::convert_to_route_blockages -convert_to edi_blk $args} result]
[05/05 14:53:56     12s]       if { $retStatus ne 0 } {
[05/05 14:53:56     12s]       	return 0
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       return 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @namespace eval Calibre::marker_if {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     namespace export mgc_rve_add_start mgc_rve_add_cell       \
[05/05 14:53:56     12s]               mgc_rve_add_rectangle mgc_rve_define_rectangle  \
[05/05 14:53:56     12s]               mgc_rve_add_end                                 \
[05/05 14:53:56     12s]               mra_check                                       \
[05/05 14:53:56     12s]               mra_start             mra_cell                  \
[05/05 14:53:56     12s]               mra_rect              mrd_rect                  \
[05/05 14:53:56     12s]               mra_end                                         \
[05/05 14:53:56     12s]               import_file
[05/05 14:53:56     12s]     namespace import ::Calibre::import_rdb::*
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     set         currentCellName         ""
[05/05 14:53:56     12s]     set         currentCheckName        ""
[05/05 14:53:56     12s]     array unset createdCheckTypes
[05/05 14:53:56     12s]     set         currentLayers           [list]
[05/05 14:53:56     12s]     set         currentCheckText        ""
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc register_cell { sticky cell args } {
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set curr_init_top_cell [dbCellName [dbgTopCell]]
[05/05 14:53:56     12s]         if { ($curr_init_top_cell ne "") && ($cell ne $curr_init_top_cell) } {
[05/05 14:53:56     12s]             set currentCellName         ""
[05/05 14:53:56     12s]             puts "Error: '$cell' should be opened and set as the top cell."
[05/05 14:53:56     12s]             return ""
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s]         if { [info exists arguments(-precision)] } {
[05/05 14:53:56     12s]           set precision $arguments(-precision)
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]           set precision  1000
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         ::mgc_enc::mgc_rve_context $cell $precision
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $sticky } {
[05/05 14:53:56     12s]             set currentCellName $cell
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $cell
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_check_internal { sticky name_pos args } {
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckTypes
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s]         variable currentCheckText
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [llength $args] < 1 } {
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $name_pos == 1 } {
[05/05 14:53:56     12s]             set cell [join [lindex $args 0]]
[05/05 14:53:56     12s]             set route_view [eval mra_cell ${cell} $args]
[05/05 14:53:56     12s]             if { $route_view eq "" } {
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         } else {   # name_pos <= 0
[05/05 14:53:56     12s]             if { $currentCellName eq "" } {
[05/05 14:53:56     12s]                 puts "Error: cell should be set first."
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set cell $currentCellName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $name_pos >= 0 } {
[05/05 14:53:56     12s]             set check [join [lindex $args $name_pos]]
[05/05 14:53:56     12s]         } else {   # name_pos < 0
[05/05 14:53:56     12s]             if { $currentCheckName eq "" } {
[05/05 14:53:56     12s]                 puts "Error: check should be set first."
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set check $currentCheckName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set check_type_name [join [list ${cell} ${check}] /]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set check_text   ""
[05/05 14:53:56     12s]         set check_layers [list]
[05/05 14:53:56     12s]         if { [info exists createdCheckTypes(${check_type_name})] } {
[05/05 14:53:56     12s]             set check_text_and_layers $createdCheckTypes(${check_type_name})
[05/05 14:53:56     12s]             set check_text   [lindex check_text_and_layers 0]
[05/05 14:53:56     12s]             set check_layers [lindex check_text_and_layers 1]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $sticky } {
[05/05 14:53:56     12s]             set currentCheckText $check_text
[05/05 14:53:56     12s]             set currentLayers $check_layers
[05/05 14:53:56     12s]             set currentCheckName ${check}
[05/05 14:53:56     12s]             if { [info exists arguments(-text_desc)] } {
[05/05 14:53:56     12s]                 set currentCheckText $arguments(-text_desc)
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             if { [info exists arguments(-layer)] } {
[05/05 14:53:56     12s]                 set currentLayers $arguments(-layer)
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set createdCheckTypes($check_type_name) [list $currentCheckText $currentLayers]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $check_layers
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_clear { {cell ""} } {
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckTypes
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s]         variable currentCheckText
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set         currentCellName     ""
[05/05 14:53:56     12s]         set         currentCheckName     ""
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset createdCheckTypes
[05/05 14:53:56     12s]         array set   createdCheckTypes       {}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set         currentLayers           [list]
[05/05 14:53:56     12s]         set         currentCheckText        ""
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $cell
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_drc_error { de_pos shape args } {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckTypes
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s]         variable currentCheckText
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [llength $args] < 1 } {
[05/05 14:53:56     12s]             puts "Error: invalid parameters for creating Encounter DRC Error: mgc_rve_add_rectangle $args."
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $currentCellName eq "" } {
[05/05 14:53:56     12s]             return 0
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $de_pos >= 1 } {
[05/05 14:53:56     12s]             set cell [join [lindex $args 0]]
[05/05 14:53:56     12s]             set drc_layout_cell [eval mra_cell ${cell} $args]
[05/05 14:53:56     12s]             if { $drc_layout_cell eq "" } {
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set cell $currentCellName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $de_pos >= 2 } {
[05/05 14:53:56     12s]             set check [join [lindex $args 1]]
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set check $currentCheckName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set layers {}
[05/05 14:53:56     12s]         if { [info exists arguments(-layer)] } {
[05/05 14:53:56     12s]             set layers $arguments(-layer)
[05/05 14:53:56     12s]         } elseif { [llength $currentLayers] != 0 } {
[05/05 14:53:56     12s]             set layers $currentLayers
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set drc_info ""
[05/05 14:53:56     12s]         if { [info exists arguments(-info)] } {
[05/05 14:53:56     12s]             set drc_info $arguments(-info)
[05/05 14:53:56     12s]         } elseif { $currentCheckText ne "" } {
[05/05 14:53:56     12s]             set drc_info [list $currentCheckText]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set edi_com [list createMarker -type Calibre -subtype ${check}]
[05/05 14:53:56     12s]         if { $drc_info ne "" } {
[05/05 14:53:56     12s]             lappend edi_com -desc $drc_info
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set rects [lindex $args [expr {$de_pos + 1}]]
[05/05 14:53:56     12s]         set count 0
[05/05 14:53:56     12s]         foreach rect $rects {
[05/05 14:53:56     12s]             set edi_com_exe $edi_com
[05/05 14:53:56     12s]             lappend edi_com_exe $shape [join $rect]
[05/05 14:53:56     12s]             if { [llength $layers] != 0 } {
[05/05 14:53:56     12s]                 foreach layer $layers {
[05/05 14:53:56     12s]                     set edi_com_exe_rect $edi_com_exe
[05/05 14:53:56     12s]                     lappend edi_com_exe_rect -layer $layer
[05/05 14:53:56     12s]                     incr count
[05/05 14:53:56     12s]                     eval $edi_com_exe_rect
[05/05 14:53:56     12s]                 }
[05/05 14:53:56     12s]             } else {
[05/05 14:53:56     12s]                 incr count
[05/05 14:53:56     12s]                 eval $edi_com_exe
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $count
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_start { {cell ""} } {
[05/05 14:53:56     12s]         return [mgc_rve_add_clear]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_start {} mra_start
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_cell { cell args } {
[05/05 14:53:56     12s]         set drc_layout_cell [eval register_cell true ${cell} $args]
[05/05 14:53:56     12s]         return $drc_layout_cell
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_cell {} mra_cell
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_check { args } {
[05/05 14:53:56     12s]         set layers [eval mgc_rve_add_check_internal true 0 $args]
[05/05 14:53:56     12s]         return $layers
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_check {} mra_check
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mrd_check { args } {
[05/05 14:53:56     12s]         set layers [eval mgc_rve_add_check_internal true 1 $args]
[05/05 14:53:56     12s]         return $layers
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_define_check {} mrd_check
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_rect { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_drc_error -1 -bbox $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_rectangle {} mra_rect
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mrd_rect { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_drc_error 2 -bbox $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_define_rectangle {} mrd_rect
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_end { {cell ""} } {
[05/05 14:53:56     12s]         return [mgc_rve_add_clear]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_end {} mra_end
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc import_file { fileName } {
[05/05 14:53:56     12s]       mra_start
[05/05 14:53:56     12s]       if {[catch {source $fileName}]} {
[05/05 14:53:56     12s]       	return 0
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       mra_end
[05/05 14:53:56     12s]       return 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] @namespace eval Calibre::route_if {
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     namespace export mgc_rve_add_start      mgc_rve_add_cell         \
[05/05 14:53:56     12s]                      mgc_rve_add_check      mgc_rve_define_check     \
[05/05 14:53:56     12s]                      mgc_rve_add_rectangle  mgc_rve_define_rectangle \
[05/05 14:53:56     12s]                      mgc_rve_add_polygon    mgc_rve_define_polygon   \
[05/05 14:53:56     12s]                      mgc_rve_add_end                                 \
[05/05 14:53:56     12s]                      mra_start              mra_cell                 \
[05/05 14:53:56     12s]                      mra_check              mrd_check                \
[05/05 14:53:56     12s]                      mra_rect               mrd_rect                 \
[05/05 14:53:56     12s]                      mra_poly               mrd_pol                  \
[05/05 14:53:56     12s]                      mra_end                                         \
[05/05 14:53:56     12s]                      import_file
[05/05 14:53:56     12s]     namespace import ::Calibre::import_rdb::*
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     array set   createdCheckLayers      {}
[05/05 14:53:56     12s]     set         currentCellName         ""
[05/05 14:53:56     12s]     set         currentCheckName        ""
[05/05 14:53:56     12s]     array unset createdCheckCount
[05/05 14:53:56     12s]     set         currentLayers           [list]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_open_cell { sticky cell args } {
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { ${cell} eq "" } {
[05/05 14:53:56     12s]             return ""
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set curr_init_top_cell [dbCellName [dbgTopCell]]
[05/05 14:53:56     12s]         if { ($curr_init_top_cell ne "") && (${cell} ne $curr_init_top_cell) } {
[05/05 14:53:56     12s]             set currentCellName         ""
[05/05 14:53:56     12s]             puts "Error: '$cell' should be opened and set as the top cell."
[05/05 14:53:56     12s]             return ""
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s]         if { [info exists arguments(-precision)] } {
[05/05 14:53:56     12s]           set precision $arguments(-precision)
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]           set precision  1000
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s]         ::mgc_enc::mgc_rve_context ${cell} $precision
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $sticky } {
[05/05 14:53:56     12s]             set currentCellName ${cell}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return ${cell}
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_clear {} {
[05/05 14:53:56     12s]         variable createdCheckLayers
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckCount
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset createdCheckLayers
[05/05 14:53:56     12s]         array set   createdCheckLayers      {}
[05/05 14:53:56     12s]         set         currentCellName         ""
[05/05 14:53:56     12s]         set         currentCheckName        ""
[05/05 14:53:56     12s]         array unset createdCheckCount
[05/05 14:53:56     12s]         array set   createdCheckCount       {}
[05/05 14:53:56     12s]         set         currentLayers           [list]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_check_internal { sticky name_pos args } {
[05/05 14:53:56     12s]         variable createdCheckLayers
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckCount
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [llength $args] < 1 } {
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [info exists arguments(-text_desc)] } {
[05/05 14:53:56     12s]           set text_desc $arguments(-text_desc)
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]           set text_desc  ""
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $name_pos == 1 } {
[05/05 14:53:56     12s] 	        set cell [join [lindex $args 0]]
[05/05 14:53:56     12s] 	        set drc_cell [eval mgc_rve_open_cell $sticky ${cell} $args]
[05/05 14:53:56     12s] 	        if { $drc_cell eq "" } {
[05/05 14:53:56     12s] 	            return {}
[05/05 14:53:56     12s] 	        }
[05/05 14:53:56     12s]     	} else {   # name_pos <= 0
[05/05 14:53:56     12s]             if { $currentCellName == "" } {
[05/05 14:53:56     12s] 	            puts "Error: cell has not been defined."
[05/05 14:53:56     12s] 	            return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set cell $currentCellName
[05/05 14:53:56     12s]     	}
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $name_pos >= 0 } {
[05/05 14:53:56     12s]             set check [join [lindex $args $name_pos]]
[05/05 14:53:56     12s]         } else {   # name_pos < 0
[05/05 14:53:56     12s]             if { $currentCheckName eq "" } {
[05/05 14:53:56     12s]                 puts "Error: check should be set first."
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set check $currentCheckName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set check_type_name [join [list ${cell} ${check}] /]
[05/05 14:53:56     12s]         if { [info exists createdCheckLayers(${check_type_name})] } {
[05/05 14:53:56     12s]             set check_layers $createdCheckTypes(${check_type_name})
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set createdCheckCount(${check_type_name}) 0
[05/05 14:53:56     12s]             set check_layers [list]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $sticky } {
[05/05 14:53:56     12s]             set currentLayers $check_layers
[05/05 14:53:56     12s]             set currentCheckName ${check}
[05/05 14:53:56     12s]             if { [info exists arguments(-layer)] } {
[05/05 14:53:56     12s]                 set currentLayers $arguments(-layer)
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s]             set createdCheckLayers(${check_type_name}) $currentLayers
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return [list ${cell} ${check}]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mgc_rve_add_route_blockages { shape coords_pos breakup args } {
[05/05 14:53:56     12s]         variable currentCellName
[05/05 14:53:56     12s]         variable currentCheckName
[05/05 14:53:56     12s]         variable createdCheckCount
[05/05 14:53:56     12s]         variable currentLayers
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [llength $args] < 1 } {
[05/05 14:53:56     12s]             puts "Error: invalid parameters for creating Encounter route blockage: mgc_rve_add_rectangle/polygon $args."
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]        	set check_name_pos [expr {$coords_pos - 2}]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $check_name_pos >= 0 } {
[05/05 14:53:56     12s]             set cell_and_check [eval mgc_rve_add_check_internal false $check_name_pos $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]             if { [llength $cell_and_check] <= 1 } {
[05/05 14:53:56     12s]                 return {}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]             set cell [lindex $cell_and_check 0]
[05/05 14:53:56     12s]             set checkName       [lindex $cell_and_check 1]
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set cell            $currentCellName
[05/05 14:53:56     12s]             set checkName       $currentCheckName
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $cell eq "" } {
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $checkName eq "" } {
[05/05 14:53:56     12s]             puts "Error: check should've been set first."
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         array unset arguments
[05/05 14:53:56     12s]         array set arguments [::Calibre::import_rdb::ParseArguments $args]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { [info exists arguments(-layer)] } {
[05/05 14:53:56     12s]             set layers $arguments(-layer)
[05/05 14:53:56     12s]         } elseif { [llength $currentLayers] != 0 } {
[05/05 14:53:56     12s]             set layers $currentLayers
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             puts "Error: need -layer parameter to create route blockage '[lindex $args $coords_pos]'."
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         if { $breakup } {
[05/05 14:53:56     12s]             set coords [lindex $args $coords_pos]
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set coords [list [lindex $args $coords_pos]]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set rb_name_pos [expr {$coords_pos - 1}]
[05/05 14:53:56     12s]         if { $rb_name_pos >= 0 } {
[05/05 14:53:56     12s]             set rb_name [lindex $args $rb_name_pos]
[05/05 14:53:56     12s]         } else {
[05/05 14:53:56     12s]             set rb_name "mgc_rve_check"
[05/05 14:53:56     12s]             append rb_name _${cell}
[05/05 14:53:56     12s]             append rb_name _${checkName}
[05/05 14:53:56     12s]             foreach layer $layers {
[05/05 14:53:56     12s]                 append rb_name _${layer}
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]             set check_type_name [join [list ${cell} ${checkName}] /]
[05/05 14:53:56     12s]             append rb_name _$createdCheckCount(${check_type_name})
[05/05 14:53:56     12s]             incr createdCheckCount(${check_type_name})
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set edi_com [list createRouteBlk -layer $layers]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set extra_name ""
[05/05 14:53:56     12s]         if { [llength $coords] > 1 } {
[05/05 14:53:56     12s]             set extra_name "_"
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set count 0
[05/05 14:53:56     12s]         set retVal {}
[05/05 14:53:56     12s]         foreach coord $coords {
[05/05 14:53:56     12s]             set edi_com_exe $edi_com
[05/05 14:53:56     12s]             lappend edi_com_exe $shape [join [join $coord]]
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]             set rb_name_exe $rb_name
[05/05 14:53:56     12s]             if { $extra_name ne "" } {
[05/05 14:53:56     12s]                 append rb_name_exe $extra_name $count
[05/05 14:53:56     12s]                 incr count
[05/05 14:53:56     12s]             }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]             lappend edi_com_exe -name $rb_name_exe
[05/05 14:53:56     12s]             lappend retVal [eval $edi_com_exe]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $retVal
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_start { {cell ""} args } {
[05/05 14:53:56     12s]         mgc_rve_add_clear
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         set drc_cell ""
[05/05 14:53:56     12s]         if { $cell ne "" } {
[05/05 14:53:56     12s]         	set drc_cell [eval mgc_rve_open_cell true ${cell} $args]
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return $drc_cell
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_start {} mra_start
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_cell { cell args } {
[05/05 14:53:56     12s]        	set drc_cell [eval mgc_rve_open_cell true ${cell} $args]
[05/05 14:53:56     12s]         return $drc_cell
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_cell {} mra_cell
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_check { args } {
[05/05 14:53:56     12s]         set cell_and_check [eval mgc_rve_add_check_internal true 0 $args]
[05/05 14:53:56     12s]         if { [llength $cell_and_check] <= 1 } {
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return [lindex $cell_and_check 1]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_check {} mra_check
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mrd_check { args } {
[05/05 14:53:56     12s]         set cell_and_check [eval mgc_rve_add_check_internal true 1 $args]
[05/05 14:53:56     12s]         if { [llength $cell_and_check] <= 1 } {
[05/05 14:53:56     12s]             return {}
[05/05 14:53:56     12s]         }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]         return [lindex $cell_and_check 1]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_define_check {} mrd_check
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_rect { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_route_blockages -box 0 true $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_rectangle {} mra_rect
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mrd_rect { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_route_blockages -box 3 true $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_define_rectangle {} mrd_rect
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_poly { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_route_blockages -polygon 0 false $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_polygon {} mra_poly
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mrd_poly { args } {
[05/05 14:53:56     12s]         return [eval mgc_rve_add_route_blockages -polygon 3 false $args]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_define_polygon {} mrd_poly
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc mra_end { {cell ""} } {
[05/05 14:53:56     12s]         return [mgc_rve_add_clear]
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     interp alias {} mgc_rve_add_end {} mra_end
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s]     proc import_file { fileName } {
[05/05 14:53:56     12s]       mra_start
[05/05 14:53:56     12s]       if {[catch {source $fileName}]} {
[05/05 14:53:56     12s]       	return 0
[05/05 14:53:56     12s]       }
[05/05 14:53:56     12s]       mra_end
[05/05 14:53:56     12s]       return 1
[05/05 14:53:56     12s]     }
[05/05 14:53:56     12s] }
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ### End verbose source output for '/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/shared/pkgs/icv/tools/queryenc/enc_rdb.tcl'.
[05/05 14:53:56     12s] 
[05/05 14:53:56     12s] ERROR: Current execution environment is VCO=aok. Software tree is for environment VCO=aoi.
[05/05 14:53:56     12s] //  ERROR while loading Calibre interface: couldn't open "/proj/cad/mentor_2021/aoi_cal_2021.1_33.19/tmp/encInp.1320363.customMenu": no such file or directory
[05/05 14:53:56     12s] @file 61:
[05/05 14:53:56     12s] @file 62: }
[05/05 14:53:56     12s] #@ End verbose source /proj/cad/mentor_2021/aoi_cal_2021.1_33.19/lib/cal_enc.tcl
[05/05 14:53:56     12s] 0
[05/05 14:53:56     12s] @innovus 3> 